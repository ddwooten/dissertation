/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderaddclustermember.c                         */
/*                                                                           */
/* Created:       2016/03/03 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Checks to see if passed stream material is real or not.      */
/*              If real, adds to the passed cluster.                         */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderClusterMems          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERAddClusterMember:"

void ADERAddClusterMember(long ader_cluster, char* ader_strm_mem_id,
                         double ader_strm_mem_id_index)
{

    long ader_cluster_ent = 0;

    if(strncmp("NULL", ader_strm_mem_id, 4) != 0)
    {

        /* This is for the initial assignment of stream members to ADER */
        /* clusters. Prevents 'source-less' groups from creating clusters */

        ader_cluster_ent = NewItem(ader_cluster + ADER_CLUSTER_ENT_PTR,
                                   ADER_CLUSTER_ENT_BLOCK_SIZE);

        WDB[ader_cluster_ent + ADER_CLUSTER_ENT_ID] = ader_strm_mem_id_index;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderallocateclpmemory.c                        */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Allocates arrays of doubles according to the size needed by  */
/*              the material comp matrix. Stores these in a an array of      */
/*              double pointers                                              */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                       TESTADERAllocateClpMemory           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERAllocateClpMemory"

double** ADERAllocateClpMemory(long ader_mat_matrix_data)
{

    double **clp_arrays = NULL;
    long ader_mat_matrix_column = 0, ader_mat_matrix_column_row = 0;
    long counter = 0;

    /* First, allocate space for the return value                             */

    clp_arrays = calloc(9, sizeof(double*));

    /* Get the number of non-zero elements in the material comp matrix        */

    ader_mat_matrix_column = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(ader_mat_matrix_column > VALID_PTR)
    {

    	ader_mat_matrix_column_row = (long)RDB[ader_mat_matrix_column + ADER_MAT_MATRIX_COL_ROWS_PTR];

    	while(ader_mat_matrix_column_row > VALID_PTR)
    	{

    		if(fabs(RDB[ader_mat_matrix_column_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]) > 1E-33)
    		{

    			counter++;

    		}

    		ader_mat_matrix_column_row = NextItem(ader_mat_matrix_column_row);

    	}

    	ader_mat_matrix_column = NextItem(ader_mat_matrix_column);

    }

    /* Allocate space for the column lower bounds array, store to clp_arrays  */

    clp_arrays[0] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS],
    		               sizeof(double));

    /* Allocate space for the column upper bounds array, store to clp_arrays  */

    clp_arrays[1] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS],
    		               sizeof(double));

    /* Allocate space for the index column starts array, store to clp_arrays  */

    clp_arrays[2] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] + 1,
    		               sizeof(double));

    /* Allocate space for the objective row, store to clp_arrays              */

    clp_arrays[3] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS],
    		               sizeof(double));

    /* Allocate space for the row lower bounds array, store to clp_arrays     */

    clp_arrays[4] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS],
    		               sizeof(double));

    /* Allocate space for the row indices array, store to clp_arrays    */

    clp_arrays[5] = calloc(counter, sizeof(double));

    /* Allocate space for the row upper bounds array, store to clp_arrays     */

    clp_arrays[6] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS],
    		               sizeof(double));

    /* Allocate space for the solution array, store to clp_arrays, increase by*/
    /* 1 to store the objective value                                         */

    clp_arrays[7] = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] + 1,
    		               sizeof(double));

    /* Allocate space for the values array, store to clp_arrays               */

    clp_arrays[8] = calloc(counter, sizeof(double));

    return(clp_arrays);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderaveragevalue.c                             */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calculates and returns the weighted average of the three     */
/*              values passed in. Based off of AverageTransmuXS              */
/*                                                                           */
/* Comments:This function is called from                                     */
/*                           ADERSetMaterialCompMatrixClusterMemRhoRowEntries*/
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERAverageValue:"

double ADERAverageValue(double bos_value, double eos_value, double ps1_value,
                        double t1, double t2, long dep)
{

    double average_value = 0, weight_bos = 0, weight_eos = 0, weight_ps1 = 0;

    /* The following comment and next three calculations are taken from       */
    /* AverageTransmuXS                                                       */

    /* average (integrate) general 2nd order polynomial from t1 to t2      */
    /* This works with lower order fits too, the higher order coefficient, */
    /* or rather the weights for them just are 0 */

    weight_bos = RDB[DATA_BURN_FIT_C2W2]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3 +
                 RDB[DATA_BURN_FIT_C1W2]*(t2*t2-t1*t1)/(t2-t1)/2 +
                 RDB[DATA_BURN_FIT_C0W2];

    weight_eos = RDB[DATA_BURN_FIT_C2W3]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3 +
                 RDB[DATA_BURN_FIT_C1W3]*(t2*t2-t1*t1)/(t2-t1)/2 +
                 RDB[DATA_BURN_FIT_C0W3];

    weight_ps1 = RDB[DATA_BURN_FIT_C2W1]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3 +
                 RDB[DATA_BURN_FIT_C1W1]*(t2*t2-t1*t1)/(t2-t1)/2 +
                 RDB[DATA_BURN_FIT_C0W1];

    average_value = weight_bos * bos_value + weight_eos * eos_value +
                    weight_ps1 * ps1_value;

    /* These are the situations in which an average value should not be       */
    /* calculated, rather it should be overwritten                            */

    if(((long)RDB[DATA_BURN_DECAY_CALC] == YES) ||
       ((long)RDB[dep + DEP_HIS_STEP_TYPE] == DEP_STEP_DEC_STEP) ||
       ((long)RDB[dep + DEP_HIS_STEP_TYPE] == DEP_STEP_DEC_TOT))
    {

        average_value = 0.0;

    }
    else if(average_value < 0.0)
    {

        average_value = bos_value;

    }

    return(average_value);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderbuildclpmodel.c                            */
/*                                                                           */
/* Created:       2016/04/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Populates the arrays created by ADERAllocateClpMemory with   */
/*              the material comp matrix data as needed by Clp. Additionally */
/*              returns the number of non-zero elements as this is needed by */
/*              ADERSolveClpModel                                            */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                       TESTADERBuildClpModel               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERBuildClpModel"

long ADERBuildClpModel(long ader_mat_matrix_data,   double *column_lower_bounds,
                       double *column_upper_bounds, double *index_column_starts,
		               double *objective_row,       double *row_lower_bounds,
		               double *row_indices,         double *row_upper_bounds,
					   double *values)
{

    long ader_mat_matrix_column  = 0, ader_mat_matrix_column_row = 0;
    long ader_mat_matrix_row_bound = 0, row_num = 0;
    long col_num = 0, num_ent = 0;

    /* First set the first entry of index_coumn_starts to 0. This is because  */
    /* index_column_starts is 1 + the number of columns long                  */

    index_column_starts[0] = 0.0;

    /* Loop through the columns to set column information                     */

    ader_mat_matrix_column = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(ader_mat_matrix_column > VALID_PTR)
    {

    	/* Assign column bounds                                               */

    	column_lower_bounds[col_num] = log10(RDB[ader_mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND]);

    	column_upper_bounds[col_num] = log10(RDB[ader_mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND]);

    	/* Set the starting row number for this column                        */

    	row_num = 0;

    	/* Loop through the rows in this column                               */

    	ader_mat_matrix_column_row = (long)RDB[ader_mat_matrix_column + ADER_MAT_MATRIX_COL_ROWS_PTR];

    	/* Do not execute the last row here, that is the objective row and it */
    	/* gets its own array                                                 */

    	while((ader_mat_matrix_column_row > VALID_PTR) &&
    	      (row_num < ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1)))
    	{

            /* Store the row index where this value is found              */

            row_indices[num_ent] = (double)row_num;

            /* Store the value found at this matrix position              */

            values[num_ent] = log10(RDB[ader_mat_matrix_column_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

            /* Increment the number of values stored                      */

            num_ent++;

    		/* Increment the number of rows processed                         */

    		row_num++;

    		ader_mat_matrix_column_row = NextItem(ader_mat_matrix_column_row);

    	}

    	/* Populate the objective row. It is the last row in every column     */

    	objective_row[col_num] = log10(RDB[ader_mat_matrix_column_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

    	/* Increment the column number                                        */

    	col_num++;

    	/* Store the number of entries ( which also the index in the values   */
    	/* and row indices arrays where the next column's information starts )*/
    	/* in the index_column_starts array                                   */

    	index_column_starts[col_num] = (double)num_ent;

    	ader_mat_matrix_column = NextItem(ader_mat_matrix_column);

        /* Reset the row counter                                                  */

        row_num = 0;

    }

    /* Now, loop through the row bounds information and populate the row      */
    /* bounds, the objective row doens't have bounds so don't bother          */

    ader_mat_matrix_row_bound = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    while((ader_mat_matrix_row_bound > VALID_PTR) &&
    	  (row_num < ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1)))
    {

    	/* Assign the row bounds                                              */

    	row_lower_bounds[row_num] = log10(RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND]);

    	row_upper_bounds[row_num] = log10(RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

    	/* Increment the row counter                                          */

    	row_num++;

    	ader_mat_matrix_row_bound = NextItem(ader_mat_matrix_row_bound);

    }

    /* return the number of entries, but increment so that it reflects the    */
    /* actual number of entries which is currently one less than the number   */

    num_ent++;

    return(num_ent);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderburnmaterials.c                            */
/*                                                                           */
/* Created:       2016/20/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles stepping through burnup substeps for ADER materials. */
/*              Handles composition vector assignment for ADER material      */
/*              burnup. Calls ADERMakeBurnMatrix to make the burn matrix and */
/*              ships this matrix off to a solver routine. Finally, it parses*/
/*              the results in the material composition lists                */
/*                                                                           */
/* Comments:This function is called from BurnMaterials                       */
/*                                                                           */
/*          DEV WARNING!!!: This function deviates from the forms seen in    */
/*                          BurnMaterials0 and BurnMaterialsCI due to the    */
/*                          nature of how AverageTransmuXS stores its data.  */
/*                          Because the rea structure is shared between      */
/*                          materials when constructing a burnup matrix with */
/*                          multiple materials the XS for each material must */
/*                          be computed just prior to use. As such the XS    */
/*                          calculation steps have been moved inside the     */
/*                          ADERMakeBurnMatrix routine.                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERBurnMaterials:"

void ADERBurnMaterials(long burn_ci_flag, long mat, long mode,
		               long num_sub_steps, long step, long type)
{

	double **ader_burn_matrix_size_data = NULL, *ader_burn_matrix_starts = NULL;
	double *ader_burn_matrix_col_storage  = NULL, *ader_burn_matrix_N0 = NULL;
	double *ader_burn_matrix_num_ents = NULL;
	double *ader_burn_matrix_num_rows = NULL, *solution_vector = NULL, t1 = 0, t2 = 0, total_time = 0;
	long ader_data = 0;
	long ader_mat_data = 0, ader_mat_cluster_mem = 0, ader_mat_cluster_mem_ader_data = 0;
	long ader_mat_cluster_mem_ader_iso = 0, ader_mat_cluster_mem_ent = 0, i = 0, mat_iso = 0;
	long nuc = 0, num_samples = 0, omp_id = 0, predictor = 0, sub_step = 0;
	struct ccsMatrix *burn_matrix = NULL;

	omp_id = OMP_THREAD_NUM;

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Get the step length                                                    */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

#ifdef ADER_TEST

	if((strncmp("FLiBeFuel", GetText(mat + MATERIAL_PTR_NAME), 9) == 0) &&
	   (step == 0))
	{

		TESTADERCountStream(mat);

		TESTADERGetBurnMatrixSizeData(mat);

		TESTADERGetIsoBurnMatrixIndex(mat);

		TESTADERMapDensityVector();

		TESTADERGetBurnMatrixValue();

		TESTADERMakeBurnMatrix();

	}

#endif

	/* Get the burn matrix size data                                          */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

	/* Get the memory and the pointer for the burnup matrix                   */

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

	/* Copy material compositions                                             */

	if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
	{

		predictor = 1;

	}
	else
	{

		predictor = 0;

	}

    /* Now, map to the N0 vector the data it needs for the solution of the*/
    /* burnup matrix                                                      */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, predictor, total_time);

    /* Now, loop through substeps                                             */

    for(sub_step = 0; sub_step < num_sub_steps; sub_step++)
    {

    	/* Get sub step start and end times                                   */

        t1 = total_time * sub_step / num_sub_steps;
        t2 = total_time * (sub_step + 1) / num_sub_steps;

        /* Fill the burnup matrix                                             */

        ADERMakeBurnMatrix(burn_matrix,
        		           ader_burn_matrix_col_storage, mat,
						   (long)ader_burn_matrix_num_ents[0],
						   (long)ader_burn_matrix_num_rows[0], step, type, t1,
						   t2);

#ifdef ADER_DIAG

	ADEROutputBurnMatrixAsCsv(burn_matrix,
							  (long)ader_burn_matrix_num_rows[0],
							  mat, step, sub_step);

	TESTADERCompareBurnMatrices(burn_matrix, mat, step, sub_step);

	if((step == 0) &&
	   ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP) &&
	   omp_id == 0)
	{

	    ADERPrintListsHierarchy();

	}

#endif

#ifdef ADER_TEST

    FinalTestReport((long)RDB[(long)RDB[(long)RDB[DATA_PTR_ADER] + ADER_TEST_INFO_PTR] + ADER_TEST_NUM_PASSED],
                    (long)RDB[(long)RDB[(long)RDB[DATA_PTR_ADER] + ADER_TEST_INFO_PTR] + ADER_TEST_NUM_FAILED],
                    (long)RDB[(long)RDB[(long)RDB[DATA_PTR_ADER] + ADER_TEST_INFO_PTR] + ADER_TEST_NUM_CASES]);

#endif

        /* Get the material burnup for each cluster member                    */

        if((type != DEP_STEP_DEC_STEP) && (type != DEP_STEP_DEC_TOT) &&
           (burn_ci_flag < 1))
        {

            /* Map to the N0 vector for MaterialBurnup                        */

            if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
            {

                ADERMapDensityVector(ader_burn_matrix_col_storage,
                		             ader_burn_matrix_starts,
                		             0, 0, mat, predictor, total_time);

            }
            else
            {

            	/* On correctors the col_storage vector needs the iso adens   */
            	/* information, not the BOS values                            */

                ADERMapDensityVector(ader_burn_matrix_col_storage,
                		             ader_burn_matrix_starts, 0, 0, mat, 1,
									 total_time);

            }

        	ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

        	while(ader_mat_cluster_mem_ent > VALID_PTR)
        	{

        		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

        		if(MyParallelMat(ader_mat_cluster_mem, YES) == YES)
        		{

        			/* The double use of the ader_burn_matrix-col_storage     */
        			/* vector is correct. The first instance is only used in  */
        			/* predictor steps and the second only on corrector steps */
        			/* The vector is appropriately filled by the above if logic*/

                    MaterialBurnup(mat, ader_burn_matrix_col_storage,
                    		       ader_burn_matrix_col_storage, t1, t2,
								   sub_step, omp_id);

        		}

        		ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

        	}

        }

		/* Start burnup equation timers                                       */

		ResetTimer(TIMER_BATEMAN);
		StartTimer(TIMER_BATEMAN);
		StartTimer(TIMER_BATEMAN_TOTAL);

		/* ADDER's modified burnup matrix is only solved appropriately by the */
		/* CRAM solver                                                        */

		solution_vector = MatrixExponential(burn_matrix,
				                            ader_burn_matrix_N0, (t2 - t1));

		/* Stop the timers                                                    */

		StopTimer(TIMER_BATEMAN);
		StopTimer(TIMER_BATEMAN_TOTAL);

		/* Map the solution_vector over to the N0 vector for the next loop    */

		for(i = 0; i < ader_burn_matrix_num_rows[0]; i++)
		{

			ader_burn_matrix_N0[i] = solution_vector[i];

		}

		/* Check for negative adens in isotopes. This is possible because of  */
		/* mass transfers. Only do this if the user requested it              */

		ader_data = (long)RDB[DATA_PTR_ADER];

		if((long)RDB[ader_data + ADER_NEG_ADENS_OPT] > 0)
		{

	    	ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

	    	while(ader_mat_cluster_mem_ent > VALID_PTR)
	    	{

	    		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

	    		if(MyParallelMat(ader_mat_cluster_mem, YES) == YES)
	    		{

	    			ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

	    			ader_mat_cluster_mem_ader_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

	    			while(ader_mat_cluster_mem_ader_iso > VALID_PTR)
	    			{

	    				if(ader_burn_matrix_N0[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]] < 0.0)
	    				{

	    					mat_iso = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_PTR];

	    					nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

	    					Warn(FUNCTION_NAME, "Isotope %ld in material %s\n\
on burnup substep %ld for burnup step %ld s\n\
has value %1.12E.", (long)RDB[nuc + NUCLIDE_ZAI],
                                 GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME),
								 sub_step, step,
								 ader_burn_matrix_N0[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]]);

	    					ader_burn_matrix_N0[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]] = 0.0;

	    				}

	    				ader_mat_cluster_mem_ader_iso = NextItem(ader_mat_cluster_mem_ader_iso);

	    			}

	    		}

	    		ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

	    	}

		}

    }

    /* Now, this function serves as both BurnMaterialsCI and BurnMaterials0   */
    /* for ADER materials. The following logic control mimics how             */
    /* BurnMaterialsCI and BurnMaterials0 are executed by BurnMaterials       */

    if((burn_ci_flag > 0) && !(((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP) &&
                               ((long)RDB[DATA_BURN_STEP] != 0)))
    {

    	/* Loop through all the materials in this cluster and update their CI */
    	/* stop criterion                                                     */

    	ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

    	while(ader_mat_cluster_mem_ent > VALID_PTR)
    	{

    		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

    		if(MyParallelMat(ader_mat_cluster_mem, YES) == YES)
    		{

    			UpdateCIStop(ader_mat_cluster_mem, ader_burn_matrix_N0, omp_id);

    			/* Additionally and necessarily store the averaged atomic     */
    			/* densities                                                  */

    			num_samples = RDB[DATA_BURN_CI_I] + 1.0;

    			ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

    			ader_mat_cluster_mem_ader_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

    			while(ader_mat_cluster_mem_ader_iso > VALID_PTR)
    			{

    				mat_iso = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_PTR];

    				WDB[mat_iso + COMPOSITION_ADENS_AVE] = (((num_samples - 1) / num_samples) *
    						                                RDB[mat_iso + COMPOSITION_ADENS_AVE]) +
														   ((1 / num_samples) *
														    ader_burn_matrix_N0[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]]);

    				ader_mat_cluster_mem_ader_iso = NextItem(ader_mat_cluster_mem_ader_iso);

    			}

    		}

    		ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

    	}

    }
    else
    {

    	/* Function was run in "BurnMaterials0" mode. The below control logic */
    	/* is needed for when a depletion calculation is run in SIE mode in   */
    	/* which case atomic densities are only updated on the first predictor*/
    	/* and all corrector steps                                            */

        if((RDB[DATA_BURN_SIE] == (double)NO) ||
  	       (!((long)(RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP) &&
  	        (RDB[DATA_BURN_STEP] != 0.0))))
        {

            ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 1,
            		             mat, predictor, total_time);

        }

    }

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

	/* Deallocate the burn matrix                                             */

	ccsMatrixFree(burn_matrix);

	/* Deallocate the solution_vector                                         */

	free(solution_vector);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercheckmaterialclusterisotopes.c             */
/*                                                                           */
/* Created:       2016/2/16 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function checks if a material is part of a cluster and  */
/*           and calls ADERMatchMaterialClusterIsotopes if so                */
/*                                                                           */
/* Comments: This function is called from ProcessMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCheckMaterialClusterIsotopes:"

void ADERCheckMaterialClusterIsotopes(long mat)
{

    long mat_ader_data = 0, mat_cluster_parent = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cluster_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    if(mat_cluster_parent > VALID_PTR)
    {

        ADERMatchMaterialClusterIsotopes(mat);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercheckmaterialremovaltables.c               */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls function to check that no removal tables have the      */
/*              same isotopes.                                               */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                       ADERCheckMaterialRemovalTables      */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCheckMaterialRemovalTables:"

void ADERCheckMaterialRemovalTables(long mat, long passed_ader_mat_stream)
{

    long ader_mat_stream = 0, mat_ader_data = 0;

    /* Get the mat_ader_data                                                  */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Loop through the material's streams                                    */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        /* Only be concerned with removal table streams                       */

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Furthermore, only be concerned if the stream's source is this      */
        /* material                                                           */

        if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Here's the recursive magic. If there is a passed in stream,        */
        /* compare the two. If not, pass in a stream                          */

        if(passed_ader_mat_stream > VALID_PTR)
        {

        	/* Don't want to compare the same removal table...                */

        	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
        			  GetText(passed_ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

                ADERCompareMaterialRemovalTables(ader_mat_stream, mat,
                                                 passed_ader_mat_stream);

        	}

        }
        else
        {

            ADERCheckMaterialRemovalTables(mat, ader_mat_stream);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        /* Only be concerned with removal type streams                        */

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Furthermore, only be concerned if the stream's source is this      */
        /* material                                                           */

        if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Here's the recursive magic. If there is a passed in stream,        */
        /* compare the two. If not, pass in a stream                          */

        if(passed_ader_mat_stream > VALID_PTR)
        {

        	/* Don't want to compare the same removal table...                */

        	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
        			  GetText(passed_ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

                ADERCompareMaterialRemovalTables(ader_mat_stream, mat,
                                                 passed_ader_mat_stream);

        	}

        }
        else
        {

            ADERCheckMaterialRemovalTables(mat, ader_mat_stream);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        /* Only be concerned with removal type streams                        */

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Furthermore, only be concerned if the stream's source is this      */
        /* material                                                           */

        if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Here's the recursive magic. If there is a passed in stream,        */
        /* compare the two. If not, pass in a stream                          */

        if(passed_ader_mat_stream > VALID_PTR)
        {

        	/* Don't want to compare the same removal table...                */

        	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
        			  GetText(passed_ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

                ADERCompareMaterialRemovalTables(ader_mat_stream, mat,
                                                 passed_ader_mat_stream);

        	}

        }
        else
        {

            ADERCheckMaterialRemovalTables(mat, ader_mat_stream);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        /* Only be concerned with removal type streams                        */

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Furthermore, only be concerned if the stream's source is this      */
        /* material                                                           */

        if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) != 0)
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Here's the recursive magic. If there is a passed in stream,        */
        /* compare the two. If not, pass in a stream                          */

        if(passed_ader_mat_stream > VALID_PTR)
        {

        	/* Don't want to compare the same removal table...                */

        	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
        			  GetText(passed_ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

                ADERCompareMaterialRemovalTables(ader_mat_stream, mat,
                                                 passed_ader_mat_stream);

        	}

        }
        else
        {

            ADERCheckMaterialRemovalTables(mat, ader_mat_stream);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderclearaderxsdata.c                          */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Clears ADER XS data to be inline with CalculateTransmuXS and */
/*              ScoreTransmuXS                                               */
/*                                                                           */
/* Comments:This function is called from ClearPrivateData and ClearPrivateRes*/
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERClearAderXSData:"

void ADERClearAderXSData()
{

	long ader_mat_iso = 0, mat = 0, mat_ader_data = 0;

	/* loop through all the mats ( this may need to change for parallel proc  */

	mat = (long)RDB[DATA_PTR_M0];

	while(mat > VALID_PTR)
	{

		mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

		/* Check to see if material is under ADER control                     */

		if(mat_ader_data > VALID_PTR)
		{

			/* Check to see if material has reactivity data                   */

			if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
			{

				/* Loop through the material isotopes                         */

				ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

				while(ader_mat_iso > VALID_PTR)
				{

					/* Clear the current XS data                              */

					WDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] = 0.0;

					WDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR] = 0.0;

					WDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR] = 0.0;

					ader_mat_iso = NextItem(ader_mat_iso);

				}

			}

		}

		mat = NextItem(mat);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderclearmaterialcompmatrixclustermempresrowbounds.c */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Clears the existing row bounds of pres rows to prepare for   */
/*              new bound information                                        */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds         */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERClearMaterialCompMatrixClusterMemPresRowBounds:"

void ADERClearMaterialCompMatrixClusterMemPresRowBounds(long ader_mat_matrix_data,
		                                                long mat)
{

	long ader_mat_pres = 0, mat_ader_data  = 0;

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Loop through any preservation entries                                  */

	ader_mat_pres = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

	while(ader_mat_pres > VALID_PTR)
	{

		/* If its a mols preserve, clear the bounds                           */

		if(strcmp("mols", GetText(ader_mat_pres + ADER_MAT_PRESERVE_ENT)) == 0)
		{

	    	ADERSetMaterialCompMatrixRowBounds(0, 0, ader_mat_matrix_data,
	    			                           (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
											   0.0);

		}

		ader_mat_pres = NextItem(ader_mat_pres);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderclearpropstreamamts.c                      */
/*                                                                           */
/* Created:       2017/01/13 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to clear prop stream cur and adj amts        */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                       TESTADERClearPropStreamAmts         */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERClearPropStreamAmts:"

void ADERClearPropStreamAmts(long adj, long mat)
{

	long ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0, cluster_ader_data = 0;
	long cluster_mem_stream = 0;
	long mat_ader_data = 0;

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Loop through ader mat cluster members                                 */

	ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_ent > VALID_PTR)
	{

		/* Get the actual material index                                      */

		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

		cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

		/* Loop through the cluster's streams                                 */

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			/* Select prop streams                                            */

			if(strncmp("prop", GetText(cluster_mem_stream + ADER_MAT_STREAM_FORM), 4) == 0)
			{

				ADERClearTargetPropStreamAmts(cluster_mem_stream, adj);

			}

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			/* Select prop streams                                            */

			if(strncmp("prop", GetText(cluster_mem_stream + ADER_MAT_STREAM_FORM), 4) == 0)
			{

				ADERClearTargetPropStreamAmts(cluster_mem_stream, adj);

			}

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			/* Select prop streams                                            */

			if(strncmp("prop", GetText(cluster_mem_stream + ADER_MAT_STREAM_FORM), 4) == 0)
			{

				ADERClearTargetPropStreamAmts(cluster_mem_stream, adj);

			}

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			/* Select prop streams                                            */

			if(strncmp("prop", GetText(cluster_mem_stream + ADER_MAT_STREAM_FORM), 4) == 0)
			{

				ADERClearTargetPropStreamAmts(cluster_mem_stream, adj);

			}

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercleartargetpropstreamamts.c                */
/*                                                                           */
/* Created:       2017/01/13 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Clears the CUR_AMT and ADJ_AMT for a given prop stream and   */
/*              its sum streams if it has any                                */
/*                                                                           */
/* Comments:This function is called from ADERClearPropStreamAmts             */
/*                                       ADERClearTargetPropStreamAmts       */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERClearTargetPropStreamAmts:"

void ADERClearTargetPropStreamAmts(long ader_mat_stream, long adj)
{

	long ader_mat_stream_sum = 0, ader_mat_stream_sum_ent = 0;

	if(adj == 0)
	{

		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.0;

		WDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] = 0.0;

	}
	else
	{

		WDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] = 0.0;

	}

	/* If the stream has summation streams, loop through those        */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	while(ader_mat_stream_sum_ent > VALID_PTR)
	{

		ader_mat_stream_sum = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

		ADERClearTargetPropStreamAmts(ader_mat_stream_sum, adj);

		ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercomparematerialremovaltables.c             */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Checks that two removal tables have distinct entries         */
/*                                                                           */
/* Comments:This function is called from ADERCheckMaterialRemovalTables      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCompareMaterialRemovalTables:"

void ADERCompareMaterialRemovalTables(long ader_mat_stream, long mat,
                                      long passed_ader_mat_stream)
{

    long ader_mat_stream_iso = 0, passed_ader_mat_stream_iso = 0;

    /* Loop through the removal table's isotopes                              */

    ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

    while(ader_mat_stream_iso > VALID_PTR)
    {

        /* Now, loop through the passed in removal table's isotopes           */

        passed_ader_mat_stream_iso = (long)RDB[passed_ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

        while(passed_ader_mat_stream_iso > VALID_PTR)
        {

            /* Compare the ZAIs, if they are equal, this is an error, a       */
            /* material may not have multiple removal tables with matching    */
            /* isotopes                                                       */

            if((long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] == (long)RDB[passed_ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI])
            {

                Error(0, "Removal table %s and \n removal table %s both are \
assigned to \n material %s ( via ADER stream entries ) and have at least two \n \
of the same isotope - with ZAI of %ld. This isotope may not have been defined \n \
explicitly for either removal table, rather, it may been added as a member \n \
of an element in both tables. Materials are not allowed to be the source of \n \
multiple removal tables with matching isotopes.\n",
                      GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                      GetText(passed_ader_mat_stream + ADER_MAT_STREAM_ID),
                      GetText(mat + MATERIAL_PTR_NAME),
                      (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI]);

            }

            passed_ader_mat_stream_iso = NextItem(passed_ader_mat_stream_iso);

        }

        ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercopymaterialflux.c                         */
/*                                                                           */
/* Created:       2016/04/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Copies averaging values for various material fluxes for use  */
/*              SIE burnup modes.                                            */
/*                                                                           */
/* Comments:This function is called from StoreTransmuXS                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCopyMaterialFlux:"

void ADERCopyMaterialFlux(double flx, double flx_new_avg, double flx_old_avg,
                          long mat)
{

    long mat_ader_data = 0;

    /* Check to see if material is under ADER control, if not, return         */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(mat_ader_data < VALID_PTR)
    {

        return;

    }

    WDB[mat_ader_data + ADER_MAT_FLUX] = flx;

    WDB[mat_ader_data + ADER_MAT_FLUX_NEW_AVG] = flx_new_avg;

    WDB[mat_ader_data + ADER_MAT_FLUX_OLD_AVG] = flx_old_avg;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercorrecttransportcycle.c                    */
/*                                                                           */
/* Created:       2016/04/08 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls various functions to correct material composition      */
/*              according to the ADER solution. Calls additional transport   */
/*              cycles to account for changes in material composition.       */
/*                                                                           */
/* Comments:This function is called from BurnupCycle                         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCorrectTransportCycle:"

void ADERCorrectTransportCycle(long dep, long step)
{

    long ader_data = 0, i = 0, mat = 0, omp_id = 0;

    omp_id = OMP_THREAD_NUM;

    ader_data = (long)RDB[DATA_PTR_ADER];

    /* The following two function are called here, rather than having been    */
    /* moved in BunrnupCycle, to avoid developer confusion. Their results     */
    /* should not change between calls within the same step, so it simply     */
    /* incurs the computational cost of an unneeded call                      */

    /* Calculate coefficients for the fit to xs/flux/power */

    DepletionPolyFit(dep, step);

    /* Set depletion step size */

    SetDepStepSize(dep, step);

    for(i = 0; i < (long)RDB[ader_data + ADER_TRANS_ITER]; i++)
    {

    	/* Set the ADER trans iter num                                        */

    	WDB[ader_data + ADER_TRANS_ITER_NUM] = (double)i;

        /* This function gets all transport information ( leakage and XS ) for*/
        /* all ader mats                                                      */

        ADERGetTransportInformation(dep, i, step);

        /* Now, loop through mats and apply the ADEROperateMaterial function  */
        /* to all of them. The function will reject those mats not under ADER */
        /* control                                                            */

        /* If OpenMP is enabled this block will spawn off OMP_NUM_THREADS     */
        /* which will all loop through materials but each thread will only    */
        /* process a material who's thread ID number matches the actual thread*/
        /* id number.                                                         */

#ifdef OPEN_MP
#pragma omp parallel private (mat)
#endif
        {

			mat = (long)RDB[DATA_PTR_M0];

			while(mat > VALID_PTR)
			{

				/* This checks if a thread should process this material. If   */
				/* not the material is skipped over and a new one checked     */

				if(MyParallelMat(mat, NO) == NO)
				{

					mat = NextItem(mat);

					continue;

				}

#ifdef ADER_INT_TEST
#ifdef OPEN_MP

				fprintf(outp, "ADER Thread %d reporting in!\n", OMP_THREAD_NUM);

#endif
#endif

				ADEROperateMaterial(0, dep, i, mat, step, 0.0,
						            RDB[DATA_BURN_TIME_INTERVAL]);

				mat = NextItem(mat);

			}

#ifdef OPEN_MP
#pragma omp barrier
#endif

        }

        /* Finish building the matrix                                         */

#ifdef ADER_TEST

		if((i == 0) && (step == 0) &&
		   ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP))
		{

			TESTADERAverageValue(dep, step);

			TESTADERCopyMaterialFlux(step);

			TESTADERFillMatCompMatrixPresMolsRow(step);

			TESTADERMatEleBalBounds(step);

			TESTADERMatEleFutBounds(step);

			TESTADERMatIsoAbsMicXsBos(step);

			TESTADERMatIsoAbsMicXsEosInit(step);

			TESTADERMatIsoAbsMicXsPs1Init(step);

			TESTADERMatIsoBalBounds(step);

			TESTADERMatIsoFutBounds(step);

			TESTADERMatIsoNuBarFisMicXsBos(step);

			TESTADERMatIsoNuBarFisMicXsEosInit(step);

			TESTADERMatIsoNuBarFisMicXsPs1Init(step);

			TESTADERMatIsoRhoRowEntry(dep, step);

			TESTADERMatPresBounds(step);

			TESTADERProcessMatStreamEleUnFixedIsoEleFrac(step);

			TESTADERProcessMatStreamEleUnFixedIsoFrac(step);

			TESTADERProcessMatSumStreamEleUnFixedIsoFrac(step);

			TESTADERMatRemvEleAmount(step);

			TESTADERMatRemvIsoAmount(step);

			TESTADERMatSysLeakageBos(step);

			TESTADERMatSysLeakageEos(step);

			TESTADERMatSysLeakagePs1Init(step);

			TESTADERNormalizeMaterialStreamDensity(step);

			TESTADERTransmuXS(step);

			TESTADERUpdateMaterialCompMatrixStreamIsoFracs(step);

			TESTADERUpdateMaterialCompMatrixSumStreamIsoFracs(step);

			TESTADERUpdateMaterialDiscStreamEffects(step);

			TESTADERUpdateMaterialDiscSumStreamEffects(step);

		}

#endif

		mat = (long)RDB[DATA_PTR_M0];

		while(mat > VALID_PTR)
		{

			ADERUpdateMaterialDiscStreamEffects(0, i, mat);

			mat = NextItem(mat);

		}

#ifdef ADER_TEST

		if((i == 0) && (step == 0) &&
		   ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP))
		{

			TESTADERFixComposition();

		}

#endif

		/* Adjust material compositions and density according to impacts made */
		/* by streams which are discreet in nature                            */

        /* Now that the ADER adjustments have been made, re-run the transport */

		PrepareTransportCycle();

        TransportCycle();

#ifdef ADER_TEST

        /* We skip loop checking for the tests environment to save time       */

        return;
#endif

        /* The eigenvalue predicted, given this material composition, is      */
        /* within bounds, so exit                                             */

        if(Mean((long)RDB[RES_IMP_KEFF], 0) <= RDB[ader_data + ADER_K_MAX] &&
           Mean((long)RDB[RES_IMP_KEFF], 0) >= RDB[ader_data + ADER_K_MIN])
        {

            break;

        }

    }

#ifdef ADER_DIAG

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

    	if((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR)
    	{

	        CalculateTransmuXS(mat, omp_id);

	        ADERMoveCrossSection(mat, step, i);

    	    ADERPrintFinalStepCrossSections(dep, mat, step, 0.0,
    	    		                        RDB[DATA_BURN_TIME_INTERVAL]);

    	}

    	mat = NextItem(mat);

    }

#endif

	/* Set the ADER trans iter num                                        */

	WDB[ader_data + ADER_TRANS_ITER_NUM] = 0.0;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercountstream.c                              */
/*                                                                           */
/* Created:       2016/21/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Counts the number of sum streams in parent streams. Returns  */
/*              the total number of streams in a parent stream. Also provides*/
/*              stream's with their index and their isotopes with their's    */
/*                                                                           */
/* Comments:This function is called from ADERGetBurnMatrixSizeData           */
/*                                       ADERCountStream                     */
/*                                       TESTADERCountStream                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCountStream:"

long ADERCountStream(long ader_mat_stream, long ader_mat_stream_count,
		             long num_rows)
{

	long ader_mat_stream_shadow_stream = 0;
	long ader_mat_stream_sum_ent = 0, ader_mat_stream_sum_stream = 0;

	/* Tunnel into the sum streams of the parent stream if they exist         */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	if(ader_mat_stream_sum_ent > VALID_PTR)
	{

		/* If there are sum streams, pass them to this function               */

		while(ader_mat_stream_sum_ent > VALID_PTR)
		{

			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

			ader_mat_stream_count = ADERCountStream(ader_mat_stream_sum_stream, ader_mat_stream_count, num_rows);

			ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

		}

	}
	else
	{

		/* Once the function finds a stream with no sum components, it will   */
		/* increment the counter and return, also give the stream its index   */
		/* Which should happen before increment                               */

		WDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX] = (double)(ader_mat_stream_count + num_rows);

		/* Give the shadow its index if it exists and if it does, by the way  */
		/* this function is called, it will be a destination stream           */

		ader_mat_stream_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] * -1;

		if(ader_mat_stream_shadow_stream > VALID_PTR)
		{

			WDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_BURN_INDEX] = (double)(ader_mat_stream_count + num_rows);

		}

		ader_mat_stream_count++;

	}

	return(ader_mat_stream_count);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercountstreamisos.c                          */
/*                                                                           */
/* Created:       2016/21/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Counts the number of isotopes with fractions greater than 0  */
/*              in a stream and its sum streams                              */
/*                                                                           */
/* Comments:This function is called from ADERGetBurnMatrixSizeData           */
/*                                       ADERCountStreamIsos                 */
/*                                       TESTADERGetBurnMatrixSizeData       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCountStreamIsos:"

long ADERCountStreamIsos(long ader_mat_stream, long num_non_zero_ents)
{

	long ader_mat_stream_iso = 0;
	long ader_mat_stream_sum_ent = 0, ader_mat_stream_sum_stream = 0;

	/* Tunnel into the sum streams of the parent stream if they exist         */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	if(ader_mat_stream_sum_ent > VALID_PTR)
	{

		/* If there are sum streams, pass them to this function               */

		while(ader_mat_stream_sum_ent > VALID_PTR)
		{

			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

			num_non_zero_ents = ADERCountStreamIsos(ader_mat_stream_sum_stream, num_non_zero_ents);

			ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

		}

	}
	else
	{

		ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_iso > VALID_PTR)
		{

			if(RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] > 0.0)
			{

				num_non_zero_ents++;

			}

			ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

		}

	}

	return(num_non_zero_ents);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateadercndentry.c                       */
/*                                                                           */
/* Created:       2015/11/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles creation of ader "conditions" memory block           */
/*                                                                           */
/* Comments: Cnd is conditions abbreviated. ADERReadAderCndData does all the */
/*           processing. This function is called from ReadInput              */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderCndEntry:"

void ADERCreateAderCndEntry(char* fname, long line, char** params,
                            char* pname, long np, char* word)
{
    long ader_data_ptr = 0, cnd_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new conditions item */

    cnd_ptr = NewItem(ader_data_ptr + ADER_CONDITIONS_PTR, ADER_CND_BLOCK_SIZE);

    /* Put name, file name and line number */

    WDB[cnd_ptr + PARAM_PTR_NAME] = (double)PutText(word);
    WDB[cnd_ptr + PARAM_PTR_FNAME] = (double)PutText(fname);
    WDB[cnd_ptr + PARAM_LINE] = (double)line;

    /* Store the conditions block id name */

    WDB[cnd_ptr + ADER_CND_ID] = (double)PutText(params[j]);

    j++;

    /* Call below function to deal with actual data handling */

    ADERReadAderCndData(fname, cnd_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateadercontrolentry.c                   */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates memory block for ADER listing elements and isotopes  */
/*              to be fully accounted for by a materials group structure.    */
/*                                                                           */
/* Comments:ADERReadAderControlData does all the data processing. This       */
/*          function is called from ReadInput.                               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderControlEntry:"

void ADERCreateAderControlEntry(char* fname, long line, char** params,
                                char* pname, long np, char* word)
{
    long ader_data_ptr = 0, control_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new control table entry */
    control_ptr = NewItem(ader_data_ptr + ADER_CONTROL_PTR,
                        ADER_CONTROL_TBL_BLOCK_SIZE);

    /* Put name, file name and line number for error reporting later if needed */

    WDB[control_ptr + PARAM_PTR_NAME] = (double)PutText(word);
    WDB[control_ptr + PARAM_PTR_FNAME] = (double)PutText(fname);
    WDB[control_ptr + PARAM_LINE] = (double)line;

    /* Store the control table id */

    WDB[control_ptr + ADER_CONTROL_TBL_ID] = (double)PutText(params[j]);

    j++;

    /* Populate control entry data */

    ADERReadAderControlData(fname, control_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateadergroupentry.c                     */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles creation of memory for new ADER groups.              */
/*                                                                           */
/* Comments:ADERReadAderGroupData does all the data processing. This function*/
/*          is called from ReadInput.                                        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderGroupEntry:"

void ADERCreateAderGroupEntry(char* fname, long line, char** params,
                              char* pname, long np, char* word)
{
    long ader_data_ptr = 0, group_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new item */

    group_ptr = NewItem(ader_data_ptr + ADER_GROUPS_PTR, ADER_GRP_BLOCK_SIZE);

    /* Put name, file name and line number */

    WDB[group_ptr + PARAM_PTR_NAME] = (double)PutText(word);
    WDB[group_ptr + PARAM_PTR_FNAME] = (double)PutText(fname);
    WDB[group_ptr + PARAM_LINE] = (double)line;

    /* Store group name */

    WDB[group_ptr + ADER_GRP_ID] = (double)PutText(params[j]);

    j++;

    /* Loop through remaining parameters, putting them in proper places */

    ADERReadAderGroupData(fname, group_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateaderoxidationentry.c                 */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles creation of oxidation entry memory and data pop      */
/*                                                                           */
/* Comments:ADERReadAderOxidationData does all the data processing. This     */
/*          function is called from ReadInput.                               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderOxidationEntry:"

void ADERCreateAderOxidationEntry(char* fname, long line, char** params,
                                  char* pname, long np, char* word)
{
    long ader_data_ptr = 0, oxidation_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new oxidation table entry */
    oxidation_ptr = NewItem(ader_data_ptr + ADER_OXIS_PTR,
                            ADER_OXI_TBL_BLOCK_SIZE);

    /* Put name, file name and line number */

    WDB[oxidation_ptr + PARAM_PTR_NAME] = (double)PutText(word);
    WDB[oxidation_ptr + PARAM_PTR_FNAME] = (double)PutText(fname);
    WDB[oxidation_ptr + PARAM_LINE] = (double)line;

    /* Store oxidation table name */

    WDB[oxidation_ptr + ADER_OXI_TBL_ID] = (double)PutText(params[j]);

    j++;

    /* Populate oxidation entry data */

    ADERReadAderOxidationData(fname, oxidation_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateaderremovalentry.c                     */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles creation of repro table memory. This table is tagged */
/*              as 'removal' in the actual input.                            */
/* Comments:ADERReadAderRemovalData does all the actual processing. This       */
/*          function is called from ReadInput.                               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderRemovalEntry:"

void ADERCreateAderRemovalEntry(char* fname, long line, char** params,
                              char* pname, long np, char* word)
{
    long ader_data_ptr = 0, repro_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new repro table entry */
    repro_ptr = NewItem(ader_data_ptr + ADER_REPROS_PTR,
                        ADER_REPRO_TBL_BLOCK_SIZE);

    /* Put name, file name and line number */

    WDB[repro_ptr + PARAM_PTR_NAME] = (double)PutText(word);
    WDB[repro_ptr + PARAM_PTR_FNAME] = (double)PutText(fname);
    WDB[repro_ptr + PARAM_LINE] = (double)line;

    /* Store repro table name */

    WDB[repro_ptr + ADER_REPRO_TBL_ID] = (double)PutText(params[j]);

    j++;

    /* Populate repro entry data */

    ADERReadAderRemovalData(fname, repro_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreateaderstreamentry.c                    */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles creation of streams entry memory.                    */
/*                                                                           */
/* Comments:ADERReadAderStreamData does all the data processing. This        */
/*          function is called from ReadInput                                */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateAderStreamEntry:"

void ADERCreateAderStreamEntry(char* fname, long line, char** params,
                              char* pname, long np)
{
    long ader_data_ptr = 0, stream_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Create new stream entry */

    stream_ptr = NewItem(ader_data_ptr + ADER_STREAMS_PTR, ADER_STREAM_BLOCK_SIZE);

    /* Populate stream entry data */

    ADERReadAderStreamData(fname, stream_ptr, j, line, params, pname, np);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialclustermemcompmatrixsection.c*/
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the composition groups and streams of a        */
/*              material calling functions to incorporate their existence    */
/*              into the material comp matrix. Also calls functions to       */
/*              handle valence and reactivity entries                        */
/*                                                                           */
/* Comments:This function is called from ADERCreateMaterialCompMatrix        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialClusterMemCompMatrixSection:"

void ADERCreateMaterialClusterMemCompMatrixSection(long ader_mat_cluster_ent_mem,
                                                   long ader_mat_matrix_data)
{

    long ader_mat_cmp = 0, ader_mat_stream = 0;
    long ader_mat_oxi = 0, ader_mat_pres = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[ader_mat_cluster_ent_mem + MATERIAL_ADER_DATA];

    ader_mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(ader_mat_cmp > VALID_PTR)
    {

        /* Process the cmp groups for this cluster mem */

        ADERCreateMaterialCmpGroupCompMatrixSection(ader_mat_cmp,
                                                    ader_mat_matrix_data);

        ader_mat_cmp = NextItem(ader_mat_cmp);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    /* These next four while loops are to process the different streams in */
    /* a material */

    while(ader_mat_stream > VALID_PTR)
    {

        ADERCreateMaterialStreamCompMatrixSection(ader_mat_matrix_data,
                                                  ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERCreateMaterialStreamCompMatrixSection(ader_mat_matrix_data,
                                                  ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERCreateMaterialStreamCompMatrixSection(ader_mat_matrix_data,
                                                  ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERCreateMaterialStreamCompMatrixSection(ader_mat_matrix_data,
                                                  ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Deal with elements and isotopes */

    ADERCreateMaterialEleCompMatrixSection(ader_mat_matrix_data, mat_ader_data);

    ADERCreateMaterialIsoCompMatrixSection(ader_mat_matrix_data, mat_ader_data);

    ader_mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    /* If oxidation control is on, deal with that too */

    if(ader_mat_oxi > VALID_PTR)
    {

        ADERCreateMaterialOxiCompMatrixSection(ader_mat_matrix_data,
                                               ader_mat_oxi);

    }

    /* If reac control is on, deal with that too */

    if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
    {

        ADERCreateMaterialRhoCompMatrixSection(ader_mat_matrix_data,
                                               mat_ader_data);

    }

    /* If any preservation tags exist, deal with these last */

    ader_mat_pres = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    while(ader_mat_pres > VALID_PTR)
    {

        ADERCreateMaterialPresCompMatrixSection(ader_mat_matrix_data,
                                                ader_mat_pres);

        ader_mat_pres = NextItem(ader_mat_pres);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialcmpgroupcompmatrixsection.c  */
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Adds a column for a cmp group. If it is a sum group, also    */
/*              adds a row. Stores col and row information on cmp group      */
/*              If the cmp group has a ratio, adds rows for this as well     */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialCmpGroupCompMatrixSection:"

void ADERCreateMaterialCmpGroupCompMatrixSection(long ader_mat_cmp,
                                                 long ader_mat_matrix_data)
{

    double ader_mat_cmp_rto_max = 0;
    long ader_mat_cmp_col = 0, ader_mat_cmp_rng = 0, ader_mat_cmp_row = 0, ader_mat_cmp_rto = 0;

    /* Check to see if this cmp group has restrictions on its fraction of the material */

    ader_mat_cmp_rng = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RNG_PTR];

    if(ader_mat_cmp_rng > VALID_PTR)
    {
        /* If it does.... */
        /* Create the row for the cmp group, give the bounds, and return the index */

         ader_mat_cmp_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                            RDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MIN],
                                                            RDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MAX]);

         WDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID] = (double)ader_mat_cmp_col;

    }
    else
    {

        /* If it doesn't, create a column for it anyway and give it reasonable bounds */

         ader_mat_cmp_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                            0.0,
                                                            1E+18);

         WDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID] = (double)ader_mat_cmp_col;
    }

    ader_mat_cmp_rto = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RTOS_PTR];

    /* Check if this cmp group has ratios with any other cmp group */

    while(ader_mat_cmp_rto > VALID_PTR)
    {

        ader_mat_cmp_rto_max = RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX];

        /* this tests to see if the ratio was input as a single value ratio */
        /* If so, we only need one row, with equal bounds, to handle this ratio */
        /* If not, we need two rows                                         */

        if(ader_mat_cmp_rto_max < 0.0)
        {

             ader_mat_cmp_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                                0.0, 0.0);

             WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN_ROW_ID] = (double)ader_mat_cmp_row;

             /* We mark the row for the max as negative to avoid processing   */
             /* it later                                                      */

             WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID] = -1.0;

        }
        else
        {

             ader_mat_cmp_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                                -1E+18, 0.0);

             WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN_ROW_ID] = (double)ader_mat_cmp_row;

             ader_mat_cmp_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                                0.0, 1E+18);

             WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID] = (double)ader_mat_cmp_row;

        }

        ader_mat_cmp_rto = NextItem(ader_mat_cmp_rto);

    }

    /* Check is the cmp group is a summation group. If so, give it a row as well */

    if((long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR] > VALID_PTR)
    {

         ader_mat_cmp_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data, 0.0, 0.0);

         WDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID] = (double)ader_mat_cmp_row;

    }
    else
    {

        /* Otherwise we mark it negative to avoid processing it later         */

        WDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID] = -1.0;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialcompmatrix.c                 */
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: If a material is a parent of a cluster ( or a sole member    */
/*              of a cluster ) this function will loop through it's cluster  */
/*              members sending them to                                      */
/*              ADERCreateMaterialClusterMemMatrixSection.                   */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderMaterialAderData     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialCompMatrix:"

void ADERCreateMaterialCompMatrix(long mat)
{

    long mat_ader_data = 0, ader_mat_matrix_data = 0, ader_mat_cluster_ent_data = 0;
    long ader_mat_cluster_ent_mem = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if((long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR] == mat)
    {

        /* only parent materials get matrix data, they will pass on the solution */
        /* to their children */

        ader_mat_matrix_data = NewItem(mat_ader_data + ADER_MAT_MATRIX_PTR,
                                       ADER_MAT_MATRIX_BLOCK_SIZE);

        ader_mat_cluster_ent_data = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

        while(ader_mat_cluster_ent_data > VALID_PTR)
        {

            /* Go through the cluster members, ( the parent is one of them ) */
            /* and process their contributions to the matrix */

            ader_mat_cluster_ent_mem = (long)RDB[ader_mat_cluster_ent_data + ADER_MAT_CLUSTER_MEM_PTR];

            ADERCreateMaterialClusterMemCompMatrixSection(ader_mat_cluster_ent_mem,
                                                          ader_mat_matrix_data);

            ader_mat_cluster_ent_data = NextItem(ader_mat_cluster_ent_data);

        }

        /* Here we create a final row in the matrix for the objective function */

        ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data, 0.0, 0.0);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialcompmatrixcol.c              */
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates a comp matrix column entry, assinging it bounds and  */
/*              populating it's row items with empty rows equal to the       */
/*              current number of rows in the matrix                         */
/*              Returns the index of the created column, one less than the   */
/*              total number of columns                                      */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialCmpGroupCompMatrixSection                      */
/*          ADERCreateMaterialStreamCompMatrixSection                        */
/*          ADERCreateMaterialOxiCompMatrixSection                           */
/*          ADERCreateMaterialRhoCompMatrixSection                           */
/*          ADERCreateMaterialEleCompMatrixSection                           */
/*          ADERCreateMaterialIsoCompMatrixSection                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialCompMatrixCol:"

long ADERCreateMaterialCompMatrixCol(long ader_mat_matrix_data,
                                     double col_lower_bound,
                                     double col_upper_bound)
{

    long ader_mat_matrix_col = 0, ader_mat_matrix_num_cols = 0;
    long i = 0;

    ader_mat_matrix_num_cols = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS];

    ader_mat_matrix_col = NewItem(ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR,
                                  ADER_MAT_MATRIX_COL_BLOCK_SIZE);

    /* set those bounds */

    WDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND] = col_lower_bound;

    WDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND] = col_upper_bound;

    /* Create the column's rows */

    for(i = 0; i < (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS]; i++)
    {

        NewItem(ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR,
                ADER_MAT_MATRIX_COL_ROW_BLOCK_SIZE);

    }

    /* increase the number of columns */

    WDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] = (double)(ader_mat_matrix_num_cols + 1);

    /* We return the OLD number of cols as this represents the index of the */
    /* newly created col, which is one less than the number of actual cols */
    /* when using zero-index notation */

    return(ader_mat_matrix_num_cols);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialcompmatrixrow.c              */
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Adds one row entry to every column in a material comp matrix */
/*              Creates one row bounds entry and populates it as well.       */
/*              Returns the row index of the created row, which is one less  */
/*              than the number of rows in the comp matrix                   */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialCmpGroupCompMatrixSection                      */
/*          ADERCreateMaterialStreamCompMatrixSection                        */
/*          ADERCreateMaterialOxiCompMatrixSection                           */
/*          ADERCreateMaterialRhoCompMatrixSection                           */
/*          ADERCreateMaterialEleCompMatrixSection                           */
/*          ADERCreateMaterialIsoCompMatrixSection                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialCompMatrixRow:"

long ADERCreateMaterialCompMatrixRow(long ader_mat_matrix_data,
                                     double row_lower_bound,
                                     double row_upper_bound)
{

    long ader_mat_matrix_col = 0, ader_mat_matrix_num_rows = 0, ader_mat_matrix_row_bounds = 0;

    ader_mat_matrix_num_rows = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(ader_mat_matrix_col > VALID_PTR)
    {

        /* Add a new row to every column in the matrix (stored column wise )*/

        NewItem(ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR,
                ADER_MAT_MATRIX_COL_ROW_BLOCK_SIZE);

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    /* Create a new row bounds entry for the matrix ( we only store bounds once rather than for every column*/

    ader_mat_matrix_row_bounds = NewItem(ader_mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR,
                                         ADER_MAT_MATRIX_ROW_BOUNDS_BLOCK_SIZE);

    /* set those bounds */

    WDB[ader_mat_matrix_row_bounds + ADER_MAT_MATRIX_ROW_LOWER_BOUND] = row_lower_bound;

    WDB[ader_mat_matrix_row_bounds + ADER_MAT_MATRIX_ROW_UPPER_BOUND] = row_upper_bound;

    /* increase the number of rows */

    WDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] = (double)(ader_mat_matrix_num_rows + 1);

    /* We return the OLD number of rows as this represents the index of the */
    /* newly created row, which is one less than the number of actual rows */
    /* when using zero-index notation */

    return(ader_mat_matrix_num_rows);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialelecompmatrixsection.c       */
/*                                                                           */
/* Created:       2016/02/27 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates rows and columns for every element in a material's   */
/*              comp matrix. These rows are the "BAL" row, or the balance    */
/*              row which requires that the 'future' amount of the element   */
/*              minus the 'delta' amount that ADER adds or takes away be     */
/*              equal to the amount of element in the material at the time   */
/*              It's an elemental BALance row. The "DEL" row represents the  */
/*              material that the ADER streams will bring in or take away.   */
/*              The DELta in the elemental composition. The "FUT" row        */
/*              represents the criteria that the element must satisfy in the */
/*              FUTure.                                                      */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialEleCompMatrixSection:"

void ADERCreateMaterialEleCompMatrixSection(long ader_mat_matrix_data,
                                            long mat_ader_data)
{

    long ader_cnt = 0, ader_cnt_ent = 0, ader_mat_cnt = 0, ader_mat_ele = 0, ader_mat_ele_col = 0;
    long ader_mat_ele_row = 0;
    long controlled = 0;

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	/* Reset the control flag                                             */

    	controlled = 0;

        /* Create the columns for the element, give it bounds, and return its index */
        /* Please see adercreatematerialisocompmatrixsection.c for an explanation  */
        /* of why this variable transfer occurs                                    */

        /* First the delta column is created                                  */

        ader_mat_ele_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                           -1E+18,
                                                           1E+18);

        WDB[ader_mat_ele + ADER_MAT_ELE_DEL_COL_ID] = (double)ader_mat_ele_col;

        /* The newly created column is the last in its list. We grap it's index */
        /* (in the WDB array, not its index in the comp matrix ) and store this */
        /* to speed later operations                                            */

        WDB[ader_mat_ele + ADER_MAT_ELE_MATRIX_DEL_COL_PTR] = (double)LastItem((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR]);

        /* Now the future column is created                                   */

        ader_mat_ele_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                           0.0,
                                                           1E+18);

        WDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID] = (double)ader_mat_ele_col;

        WDB[ader_mat_ele + ADER_MAT_ELE_MATRIX_FUT_COL_PTR] = (double)LastItem((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR]);

        /* Now we search the materials cnt tables to see if this element is controlled */
        /* and then we set the row bounds based on this information                    */

        ader_mat_cnt = (long)RDB[mat_ader_data + ADER_MAT_CNT_TBLS_PTR];

        while(ader_mat_cnt > VALID_PTR)
        {

            /* The mat cnt simply points to the ader cnt */

            ader_cnt = (long)RDB[ader_mat_cnt + ADER_MAT_CNT_TBL_PTR];

            ader_cnt_ent = (long)RDB[ader_cnt + ADER_CONTROL_ENT_PTR];

            while(ader_cnt_ent > VALID_PTR)
            {

                /* go though the ader cnt's entries, if a Z matches this element */
                /* you have a match, break this loop and exit the next */

                if((long)RDB[ader_mat_ele + ADER_MAT_ELE_Z] == (long)RDB[ader_cnt_ent + ADER_CONTROL_ENT_Z])
                {

                    controlled = 1;

                    /* Set the element's control flag                         */

                    WDB[ader_mat_ele + ADER_MAT_ELE_CONTROL_FLAG] = 1.0;

                    break;

                }

                ader_cnt_ent = NextItem(ader_cnt_ent);

            }

            /* Control was found, break the overall cnt loop */

            if(controlled > 0)
            {

                break;

            }

            ader_mat_cnt = NextItem(ader_mat_cnt);

        }

        /* First, create the balance row, being controlled doesn't matter here*/

        ader_mat_ele_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                           0.0,
                                                           0.0);

        WDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID] = (double)ader_mat_ele_row;

        /* Now create the delta row, being controlled doesn't matter here    */

        ader_mat_ele_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                           0.0,
                                                           0.0);

        WDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID] = (double)ader_mat_ele_row;

        /* Create the element's future row, pass back its index and set the bounds */
        /* If the bounds are controlled than the min and max are the same for the fut row */
        /* If not, there is no upper bound */

        if(controlled > 0)
        {

            ader_mat_ele_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                               0.0,
                                                               0.0);

            WDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID] = (double)ader_mat_ele_row;

        }
        else
        {

             ader_mat_ele_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                                -1E+18,
                                                                 0.0);

             WDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID] = (double)ader_mat_ele_row;

        }

        /* Create a fourth row for each element in which the isotopic balance */
        /* will be represented. The previous rows were for group composition  */
        /* balance                                                            */

        ader_mat_ele_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                           0.0, 0.0);

        WDB[ader_mat_ele + ADER_MAT_ELE_ISO_ROW_ID] = (double)ader_mat_ele_row;

        ader_mat_ele = NextItem(ader_mat_ele);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialisocompmatrixsection.c       */
/*                                                                           */
/* Created:       2016/02/27 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates rows and columns for every isotope in a material's   */
/*              comp matrix. These rows are the "BAL" row, or the balance    */
/*              row which requires that the 'future' amount of the isotope   */
/*              minus the 'delta' amount that ADER adds or takes away be     */
/*              equal to the amount of isotope in the material at the time   */
/*              It's an isotopic BALance row. The "DEL" row represents the   */
/*              material that the ADER streams will bring in or take away.   */
/*              The DELta in the isotopic composition. The "FUT" row         */
/*              represents the criteria that the isotope must satisfy in the */
/*              FUTure.                                                      */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialIsoCompMatrixSection:"

void ADERCreateMaterialIsoCompMatrixSection(long ader_mat_matrix_data,
                                            long mat_ader_data)
{
    long ader_cnt = 0, ader_cnt_ent = 0, ader_mat_cnt = 0, ader_mat_iso = 0, ader_mat_iso_col = 0;
    long ader_mat_iso_row = 0, mat_iso = 0, nuc = 0;
    long controlled = 0;

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	controlled = 0;

        /* Create the columns for the isotope, give it bounds, and return its index*/
        /* We use a dummy variable for passing, as otherwise, a very exotic        */
        /* seg-fault occurs because the address of the WDB array changes inside    */
        /* the function returning a value but the address of the WDB array         */
        /* in this function is frozen until the return of the value at which       */
        /* point it is going to a bad memory address                               */

        /* First, create the del col                                          */

        ader_mat_iso_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                           -1E+18,
                                                           1E+18);

        WDB[ader_mat_iso + ADER_MAT_ISO_DEL_COL_ID] = (double)ader_mat_iso_col;

        /* The newly created column is the last in its list. We grab it's index */
        /* (in the WDB array, not its index in the comp matrix ) and store this */
        /* to speed later operations                                            */

        WDB[ader_mat_iso + ADER_MAT_ISO_MATRIX_DEL_COL_PTR] = (double)LastItem((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR]);

        /* Next, create the fut col                                           */

        ader_mat_iso_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                           0.0,
                                                           1E+18);

        WDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID] = (double)ader_mat_iso_col;

        /* Store the column WDB index                                         */

        WDB[ader_mat_iso + ADER_MAT_ISO_MATRIX_FUT_COL_PTR] = (double)LastItem((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR]);

        /* Now we search the materials cnt tables to see if this isotope is controlled */
        /* and then we set the row bounds based on this information                    */

        mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        ader_mat_cnt = (long)RDB[mat_ader_data + ADER_MAT_CNT_TBLS_PTR];

        while(ader_mat_cnt > VALID_PTR)
        {

            /* The mat cnt simply points to the ader cnt */

            ader_cnt = (long)RDB[ader_mat_cnt + ADER_MAT_CNT_TBL_PTR];

            ader_cnt_ent = (long)RDB[ader_cnt + ADER_CONTROL_ENT_PTR];

            while(ader_cnt_ent > VALID_PTR)
            {

                /* go though the ader cnt's entries, if a ZAI matches this isotope */
                /* you have a match, break this loop and exit the next */

                if((long)RDB[nuc + NUCLIDE_ZAI] == (long)RDB[ader_cnt_ent + ADER_CONTROL_ENT_ZAI])
                {

                    controlled = 1;

                    /* Set the isos's control flag                            */

                    WDB[ader_mat_iso + ADER_MAT_ISO_CONTROL_FLAG] = 1.0;

                    break;

                }

                ader_cnt_ent = NextItem(ader_cnt_ent);

            }

            /* Control was found, break the overall cnt loop */

            if(controlled > 0)
            {

                break;

            }

            ader_mat_cnt = NextItem(ader_mat_cnt);

        }

        /* Now, create the bal row                                            */

        ader_mat_iso_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                           0.0,
                                                           0.0);

        WDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID] = (double)ader_mat_iso_row;

        /* Now, create the del row                                            */

        ader_mat_iso_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                           0.0,
                                                           0.0);

        WDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID] = (double)ader_mat_iso_row;

        /* Create the isotope's fut row, pass back its index and set the      */
        /* bounds. If the bounds are controlled than the min and max are the  */
        /* same If not, there is no upper bound                               */

        if(controlled > 0)
        {

         ader_mat_iso_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                            0.0,
                                                            0.0);

         WDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID] = (double)ader_mat_iso_row;

        }
        else
        {

             ader_mat_iso_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                                -1E+18,
                                                                 0.0);

             WDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID] = (double)ader_mat_iso_row;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialoxicompmatrixsection.c       */
/*                                                                           */
/* Created:       2016/02/27 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates a row for the oxidation control in the material      */
/*              comp matrix.                                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialOxiCompMatrixSection:"

void ADERCreateMaterialOxiCompMatrixSection(long ader_mat_matrix_data,
                                            long ader_mat_oxi)
{

    long ader_mat_oxi_row = 0;

    /* Create the row for the oxi control, give the oxi data its row index */
    /* variable transfer is done to avoid seg-fault. Explained in iso matrix section */

     ader_mat_oxi_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                        RDB[ader_mat_oxi + ADER_MAT_OXI_MIN],
                                                        RDB[ader_mat_oxi + ADER_MAT_OXI_MAX]);

     WDB[ader_mat_oxi + ADER_MAT_OXI_ROW_ID] = (double)ader_mat_oxi_row;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialprescompmatrixsection.c      */
/*                                                                           */
/* Created:       2016/03/14 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates a row for a preservation entry in the material       */
/*              comp matrix.                                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialPresCompMatrixSection:"

void ADERCreateMaterialPresCompMatrixSection(long ader_mat_matrix_data,
                                             long ader_mat_pres)
{

    long ader_mat_pres_row = 0;

    ader_mat_pres_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                       0.0,
                                                       0.0);

    WDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID] = (double)ader_mat_pres_row;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialrhocompmatrixsection.c       */
/*                                                                           */
/* Created:       2016/02/27 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates a row for the criticality control in the material    */
/*              comp matrix.                                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialRhoCompMatrixSection:"

void ADERCreateMaterialRhoCompMatrixSection(long ader_mat_matrix_data,
                                            long mat_ader_data)
{

    long ader_mat_rho_row = 0;

    /* Create the rows for the reactivity control, give the material ader data the row indices */
    /* variable transfer used to avoid seg-fault                                               */

    ader_mat_rho_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                       0.0,
													   1E+18);

    WDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID] = (double)ader_mat_rho_row;

    ader_mat_rho_row = ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data,
                                                       -1E+18,
                                                       0.0);

    WDB[mat_ader_data + ADER_MAT_RHO_MIN_ROW_ID] = (double)ader_mat_rho_row;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adercreatematerialstreamcompmatrixsection.c    */
/*                                                                           */
/* Created:       2016/02/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates a column for a stream group. If the stream group is  */
/*              a summation group a row is created the function is called    */
/*              again to create a column for the sum groups.                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialClusterMemCompMatrixSection                    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERCreateMaterialStreamCompMatrixSection:"

void ADERCreateMaterialStreamCompMatrixSection(long ader_mat_matrix_data,
                                               long ader_mat_stream)
{

    long ader_mat_stream_col = 0, ader_mat_stream_row = 0;
    long ader_mat_stream_sum_grp = 0, ader_mat_stream_sum_grp_ent = 0;

    /* If this stream is a shadow of another, i.e. the source end of a two */
    /* material stream, skip processing it. Same if it's a rem type stream */

    if(((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0) ||
       (strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0))
    {

    	/* Set the sum row for rem type streams to -1 before leaving, this    */
    	/* helps with testing                                                 */

    	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
    	{

            WDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID] = -1.0;

    	}

        return;

    }
    else
    {

        /* Give the stream its column index along with actually creating  */
        /* the column and setting the bounds                              */

        ader_mat_stream_col = ADERCreateMaterialCompMatrixCol(ader_mat_matrix_data,
                                                              0.0,
                                                              1E+18);

        WDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID] = (double)ader_mat_stream_col;

        ader_mat_stream_sum_grp_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

        /* If this is a sum-stream, we will need a row for its calculation */

        if(ader_mat_stream_sum_grp_ent > VALID_PTR)
        {

            ader_mat_stream_row = (double)ADERCreateMaterialCompMatrixRow(ader_mat_matrix_data, 0.0, 0.0);

            WDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID] = (double)ader_mat_stream_row;

        }
        else
        {

            /* Otherwise, set this to a negative value so it is not processed */

            WDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID] = -1.0;

        }

        /* Now loop through those sum groups and create matrix entries for them as well */

        ader_mat_stream_sum_grp_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

        while(ader_mat_stream_sum_grp_ent > VALID_PTR)
        {

            ader_mat_stream_sum_grp = (long)RDB[ader_mat_stream_sum_grp_ent + ADER_MAT_GRP_SUM_GRP_PTR];

            ADERCreateMaterialStreamCompMatrixSection(ader_mat_matrix_data,
                                                      ader_mat_stream_sum_grp);

            ader_mat_stream_sum_grp_ent = NextItem(ader_mat_stream_sum_grp_ent);

        }

        /* Now, if this stream has a shadow, i.e. it is a stream in a         */
        /* destination material and has a valid source material, now provide  */
        /* the column and row information to the 'shadow' stream              */

        if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        {

            ADERProcessMaterialShadowStreamCompMatrixSection(ader_mat_stream);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderdeallocatetarget.c                         */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Frees arrays stored in passed in array as well as the passed */
/*              in array                                                     */
/*                                                                           */
/* Comments:This function is called from ADERGetBurnMatrixSizeData           */
/*                                       ADEROperateMaterialCompMatrix       */
/*                                       TESTADERAllocateClpMemory           */
/*                                       TESTADERGetBurnMatrixNumRows        */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERDeallocateTarget:"

void ADERDeallocateTarget(double **target, long target_size)
{

	long i = 0;

	/* Loop through the arrays inside of target ( or rather the pointers )    */
	/* and free them                                                          */

	for(i = 0; i < target_size; i++)
	{

		free(target[i]);

	}

	/*Free the array pointer array                                            */

	free(target);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialclustermemcompmatrixsection.c  */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the composition groups and streams of a        */
/*              material calling functions to incorporate their existence    */
/*              into the material comp matrix. Also calls functions to       */
/*              handle valence and reactivity entries                        */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrix          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialClusterMemCompMatrixSection:"

void ADERFillMaterialClusterMemCompMatrixSection(long ader_mat_cluster_ent_mem,
                                                 long ader_mat_matrix_data)
{

    long ader_mat_cmp = 0, ader_mat_stream = 0;
    long ader_mat_oxi = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[ader_mat_cluster_ent_mem + MATERIAL_ADER_DATA];

    ader_mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(ader_mat_cmp > VALID_PTR)
    {

        /* Process the cmp groups for this cluster mem */

        ADERFillMaterialCmpGroupCompMatrixSection(ader_mat_cmp,
                                                  ader_mat_matrix_data,
                                                  mat_ader_data);

        ader_mat_cmp = NextItem(ader_mat_cmp);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    /* These next four while loops are to process the different streams in */
    /* a material */

    while(ader_mat_stream > VALID_PTR)
    {

        ADERFillMaterialStreamCompMatrixSection(ader_mat_cluster_ent_mem,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERFillMaterialStreamCompMatrixSection(ader_mat_cluster_ent_mem,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERFillMaterialStreamCompMatrixSection(ader_mat_cluster_ent_mem,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ADERFillMaterialStreamCompMatrixSection(ader_mat_cluster_ent_mem,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Deal with elements and isotopes */

    ADERFillMaterialEleCompMatrixSection(ader_mat_matrix_data, mat_ader_data);

    ADERFillMaterialIsoCompMatrixSection(ader_mat_matrix_data, mat_ader_data);

    ader_mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    /* If oxidation control is on, deal with that too */

    if(ader_mat_oxi > VALID_PTR)
    {

        ADERFillMaterialOxiCompMatrixSection(ader_mat_matrix_data,
                                             mat_ader_data);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcmpgroupcompmatrixsection.c    */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to fill in elemental and isotopic fraction   */
/*              data from composition groups in to the element and isotope   */
/*              rows of the comp matrix. Additionally calls functions to     */
/*              handle any ratios associated with the comp group as well as  */
/*              any summation entries.                                       */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCmpGroupCompMatrixSection:"

void ADERFillMaterialCmpGroupCompMatrixSection(long ader_mat_cmp,
                                               long ader_mat_matrix_data,
                                               long mat_ader_data)
{

    long ader_mat_cmp_col = 0, ader_mat_cmp_ele = 0, ader_mat_cmp_iso = 0, ader_mat_cmp_rto = 0;

    ader_mat_cmp_col = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID];

    /* We grab the first element in the group's elemental list and pass it to */
    /* the elemental processing function. */

    ader_mat_cmp_ele = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_ELES_PTR];

    ADERFillMaterialCompMatrixEleData(ader_mat_cmp_ele, ader_mat_cmp_col,
                                      ader_mat_matrix_data, mat_ader_data, 1.0, 1, 1);

    /* We grab the first isotope in the group's elemental list and pass it to */
    /* the isotopic processing function. */

    ader_mat_cmp_iso = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_ISOS_PTR];

    ADERFillMaterialCompMatrixIsoData(ader_mat_cmp_iso, ader_mat_cmp_col,
                                      ader_mat_matrix_data, mat_ader_data, 1.0, 1, 1);

    /* If the group has any ratios, deal with those */

    ader_mat_cmp_rto = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RTOS_PTR];

    while(ader_mat_cmp_rto > VALID_PTR)
    {

        ADERFillMaterialCmpRtoCompMatrixSection(ader_mat_cmp_rto,
                                                ader_mat_matrix_data,
                                                ader_mat_cmp_col,
                                                mat_ader_data);

        ader_mat_cmp_rto = NextItem(ader_mat_cmp_rto);

    }

    /* If the group is a summation group, deal with that */

    if((long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR] > VALID_PTR)
    {

        ADERFillMaterialCmpSumCompMatrixSection(ader_mat_cmp,
                                                ader_mat_matrix_data,
                                                mat_ader_data);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcmprtocompmatrixsection.c      */
/*                                                                           */
/* Created:       2016/03/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sets the passed in group's value to 1 in the matrix for the  */
/*              min, and max if it exists, rto row. Gets column id for second*/
/*              group and sets it's values accordingly.                      */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialCmpGroupCompMatrixSection                        */
/*          For an explanation of how ratios are handled, mathematically, in */
/*          the ADER modification please see the user's manual.              */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCmpRtoCompMatrixSection:"

void ADERFillMaterialCmpRtoCompMatrixSection(long ader_mat_cmp_rto,
                                             long ader_mat_matrix_data,
                                             long ader_mat_matrix_first_col_id,
                                             long mat_ader_data)
{

    long ader_mat_sec_cmp = 0, ader_mat_matrix_sec_col_id = 0;

    /* Go ahead and set the value for the first group, this group's value is  */
    /* always 1                                                               */

    ADERSetMaterialCompMatrixElement(ader_mat_matrix_first_col_id,
                                     (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN_ROW_ID],
                                     ader_mat_matrix_data,
                                     -1.0);

    /* If there is a max row, set the value for the first group               */

    if((long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID] > 0)
    {

        ADERSetMaterialCompMatrixElement(ader_mat_matrix_first_col_id,
                                         (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID],
                                         ader_mat_matrix_data,
                                         -1.0);

    }

    /*Now that the first group is set, deal with the second group in the ratio*/

    ader_mat_sec_cmp = (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

    ader_mat_matrix_sec_col_id = (long)RDB[ader_mat_sec_cmp + ADER_MAT_CMP_COL_ID];

    /* There is always a 'min' rto value, if it's the only one, this is a     */
    /* single value ratio                                                     */

    ADERSetMaterialCompMatrixElement(ader_mat_matrix_sec_col_id,
                                     (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN_ROW_ID],
                                     ader_mat_matrix_data,
                                     RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN]);

    /* If there is a max row, set the value for the first group               */

    if((long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID] > 0)
    {

        ADERSetMaterialCompMatrixElement(ader_mat_matrix_sec_col_id,
                                         (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID],
                                         ader_mat_matrix_data,
                                         RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX]);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcmpsumcompmatrixsection.c      */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a composition groups summation groups and fills*/
/*              the given ader_mat_matrix with the necessary data for        */
/*              handling summation groups in the linear optimization scheme  */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialCmpGroupCompMatrixSection                        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCmpSumCompMatrixSection:"

void ADERFillMaterialCmpSumCompMatrixSection(long ader_mat_cmp,
                                             long ader_mat_matrix_data,
                                             long mat_ader_data)
{

    long ader_mat_cmp_sum_ent = 0, ader_mat_cmp_sum_grp = 0;

    /* Go ahead and set the parent group's ( the one passed in ) value to 1   */
    /* in the matrix                                                          */

    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID],
                                     (long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID],
                                     ader_mat_matrix_data,
                                     1.0);

    /* Now, loop through the comp group's sum groups, setting their matrix    */
    /* matrix values                                                          */

    ader_mat_cmp_sum_ent = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR];

    while(ader_mat_cmp_sum_ent > VALID_PTR)
    {

        ader_mat_cmp_sum_grp = (long)RDB[ader_mat_cmp_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_cmp_sum_grp + ADER_MAT_CMP_COL_ID],
                                         (long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID],
                                         ader_mat_matrix_data,
                                         -RDB[ader_mat_cmp_sum_ent + ADER_MAT_GRP_SUM_GRP_WEIGHT]);

        ader_mat_cmp_sum_ent = NextItem(ader_mat_cmp_sum_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcompmatrix.c                   */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the members of an ader cluster to call         */
/*              functions to fill their comp matrix data                     */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCompMatrix:"

void ADERFillMaterialCompMatrix(long mat)
{

    long mat_ader_data = 0, ader_mat_matrix_data = 0, ader_mat_cluster_ent_data = 0;
    long ader_mat_cluster_ent_mem = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_cluster_ent_data = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent_data > VALID_PTR)
    {

        /* Go through the cluster members, ( the parent is one of them ) */
        /* and fill their matrix entries                                 */

        ader_mat_cluster_ent_mem = (long)RDB[ader_mat_cluster_ent_data + ADER_MAT_CLUSTER_MEM_PTR];

        ADERFillMaterialClusterMemCompMatrixSection(ader_mat_cluster_ent_mem,
                                                    ader_mat_matrix_data);

        ader_mat_cluster_ent_data = NextItem(ader_mat_cluster_ent_data);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcompmatrixeledata.c            */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the composition, or stream, elements passed in */
/*              and find their matching ader_mat_ele which has the correct   */
/*              row to put the fraction in. Column is given by the calling   */
/*              function. The input type is to specify whether the           */
/*              came from a composition group ( type 1 ) or a stream         */
/*              ( type 0 ). These designate either FUT or DEL rows           */
/*              respectively                                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*          ADERFillMaterialStreamCompMatrixSection                          */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCompMatrixEleData:"

void ADERFillMaterialCompMatrixEleData(long ader_mat_ent_ele,
                                       long ader_mat_matrix_col_id,
                                       long ader_mat_matrix_data,
                                       long mat_ader_data,
									   double mult,
                                       long sign, long type)
{

	/* They type variable indicates whether the passed in element or isotope  */
	/* should be put in a future, or a del row                                */

    long ader_mat_ele = 0;

    /* Loop through the elemental list passed in ( the first element is given */
    /* by ader_mat_ent_ele ) and search the mat_ader_data's elemental list for*/
    /* the matching element.                                                  */

    while(ader_mat_ent_ele > VALID_PTR)
    {

        ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

        while(ader_mat_ele > VALID_PTR)
        {

            /* If we found the matching element, place the group fraction for */
            /* that element into the appropriate matrix position              */

            if((long)RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_Z] == (long)RDB[ader_mat_ele + ADER_MAT_ELE_Z])
            {

                if(sign > 0)
                {

                    /* Sign indicates a positive number, so put a positive num*/

                    if(type == 0)
                    {

                        ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID],
                                                         ader_mat_matrix_data,
                                                         RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_FRAC] * mult);

                    }
                    else if(type == 1)
                    {

                        ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID],
                                                         ader_mat_matrix_data,
                                                         RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_FRAC] * mult);

                    }
                    else
                    {

                        Die(FUNCTION_NAME, "Improper 'type' variable passed to ADERFillMaterialCompMatrixEleData \n \
Type must have value of 0 or 1, has value of %ld.\n. Please post this issue, \n \
with all available supporting documentation ( run scripts, etc ) to the \n \
SERPENT users forums.\n", type);

                    }

                }
                else
                {

                    /* Sign indicates a negative number, so put a neg number  */

                    if(type == 0)
                    {

                        ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID],
                                                         ader_mat_matrix_data,
                                                         -RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_FRAC] * mult);

                    }
                    else if(type == 1)
                    {

                        ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID],
                                                         ader_mat_matrix_data,
                                                         -RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_FRAC] * mult);

                    }
                    else
                    {

                        Die(FUNCTION_NAME, "Improper 'type' variable passed to ADERFillMaterialCompMatrixEleData \n \
Type must have value of 0 or 1, has value of %ld.\n. Please post this issue, \n \
with all available supporting documentation ( run scripts, etc ) to the \n \
SERPENT users forums.\n", type);

                    }

                }

                break;

            }

            ader_mat_ele = NextItem(ader_mat_ele);

        }

        ader_mat_ent_ele = NextItem(ader_mat_ent_ele);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcompmatrixisodata.c            */
/*                                                                           */
/* Created:       2016/03/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the composition, or stream, isotopes passed in */
/*              and find their matching ader_mat_iso which has the correct   */
/*              row to put the fraction in. Column is given by the calling   */
/*              function. The input type is to specify whether the           */
/*              came from a composition group ( type 1 ) or a stream         */
/*              ( type 0 ). These designate either FUT or DEL rows           */
/*              respectively                                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialCmpGroupCompMatrixSection                        */
/*          ADERFillMaterialStreamCompMatrixSection                          */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCompMatrixIsoData:"

void ADERFillMaterialCompMatrixIsoData(long ader_mat_ent_iso,
                                       long ader_mat_matrix_col_id,
                                       long ader_mat_matrix_data,
                                       long mat_ader_data,
									   double mult,
                                       long sign, long type)
{

    long ader_mat_iso = 0;

    /* Loop through the isotope list passed in ( the first isotope is given   */
    /* by ader_mat_ent_iso ) and grab the ader_mat_iso that corresponds to it */
    /* to get the row to place the fraction ( times the multiplier ) in       */

    while(ader_mat_ent_iso > VALID_PTR)
    {

        ader_mat_iso = (long)RDB[ader_mat_ent_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

        if(sign > 0)
        {

            /* Sign indicates a positive number, so put a positive number     */

            if(type == 0)
            {

                ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                 (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID],
                                                 ader_mat_matrix_data,
                                                 RDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_FRAC] * mult);

            }
            else if(type == 1)
            {

                ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                 (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID],
                                                 ader_mat_matrix_data,
                                                 RDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_FRAC] * mult);

            }
            else
            {

                Die(FUNCTION_NAME, "Improper 'type' variable passed to ADERFillMaterialCompMatrixEleData \n \
Type must have value of 0 or 1, has value of %ld.\n. Please post this issue, \n \
with all available supporting documentation ( run scripts, etc ) to the \n \
SERPENT users forums.\n", type);

            }

        }
        else
        {

            /* Sign indicates a negative number, so put a negative number     */

            if(type == 0)
            {

                ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                 (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID],
                                                 ader_mat_matrix_data,
                                                 -RDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_FRAC] * mult);

            }
            else if(type == 1)
            {

                ADERSetMaterialCompMatrixElement(ader_mat_matrix_col_id,
                                                 (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID],
                                                 ader_mat_matrix_data,
                                                 -RDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_FRAC] * mult);

            }
            else
            {

                Die(FUNCTION_NAME, "Improper 'type' variable passed to ADERFillMaterialCompMatrixEleData \n \
Type must have value of 0 or 1, has value of %ld.\n. Please post this issue, \n \
with all available supporting documentation ( run scripts, etc ) to the \n \
SERPENT users forums.\n", type);

            }

        }

        ader_mat_ent_iso = NextItem(ader_mat_ent_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialcompmatrixobjrow.c             */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to incorporate the objective function into   */
/*              into the material comp matrix depending on the objective     */
/*              function parameters given by the user                        */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                       TestCases                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialCompMatrixObjRow:"

void ADERFillMaterialCompMatrixObjRow(long mat)
{

    long ader_mat_opt = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    /* Check what opt options the user set, or the default, call appropriate function */

    if(strcmp("action", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE)) == 0)
    {

        if(strcmp("feed", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActFeedCompMatrixSection(mat);

        }
        else if(strcmp("feed_and_remv", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActFeedAndRemvCompMatrixSection(mat);

        }
        else if(strcmp("reac", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActReacCompMatrixSection(mat);

        }
        else if(strcmp("redox", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActRedoxCompMatrixSection(mat);

        }
        else if(strcmp("remv", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActRemvCompMatrixSection(mat);

        }
        else if(strcmp("streams", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActStreamsCompMatrixSection(mat);

        }
        else if(strcmp("transfers", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET)) == 0)
        {

            ADERFillMaterialObjActTransfersCompMatrixSection(mat);

        }
        else
        {

            Error(0, "Opt type and target pair, (%s, %s), for material %s\n \
does not match any acceptable input for these options. Please consult the user's\n \
manual. Currently acceptable input for opt type and target pairs include...\n \
action, feed \n action, feed_and_remv \n action, reac \n action, redox \n \
action, remv \n action, transfers \n \
grp, [name of group assigned to material by 'conditions' block] \n \
spec_stream, [name of stream assigned to material]\n\n",
                  GetText(ader_mat_opt + ADER_MAT_OPT_TYPE),
                  GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET),
                  GetText(mat + MATERIAL_PTR_NAME));

        }

    }
    else if(strcmp("group", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE)) == 0)
    {

        ADERFillMaterialObjGrpCompMatrixSection(GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET), mat);

    }
    else if(strcmp("spec_stream", GetText(ader_mat_opt + ADER_MAT_OPT_TYPE)) == 0)
    {

        ADERFillMaterialObjStreamCompMatrixSection(GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET), mat);

    }
    else
    {

        Error(0, "Opt type and target pair, (%s, %s), for material %s\n \
does not match any acceptable input for these options. Please consult the user's\n \
manual. Currently acceptable input for opt type and target pairs include...\n \
action, feed \n action, feed_and_remv \n action, reac \n action, redox \n \
action, remv \n action, transfers \n \
grp, [name of group assigned to material by 'conditions' block] \n \
spec_stream, [name of stream assigned to material]\n\n",
              GetText(ader_mat_opt + ADER_MAT_OPT_TYPE),
              GetText(ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET),
              GetText(mat + MATERIAL_PTR_NAME));

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialelecompmatrixsection.c         */
/*                                                                           */
/* Created:       2016/03/24 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills in element data for each mat element. Also populates   */
/*              element isotopic balance rows with isotopic data             */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialEleCompMatrixSection:"

void ADERFillMaterialEleCompMatrixSection(long ader_mat_matrix_data,
                                          long mat_ader_data)
{

    long ader_mat_ele = 0, ader_mat_ele_iso = 0, ader_mat_iso = 0;

    /* Loop through all the elements in the material                          */

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

        /* First, put the element's delta value in the balance row            */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_COL_ID],
                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        /* Next, put the element's delta value in the delta row               */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_COL_ID],
                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        /* Next, put the element's future value in the balance row            */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID],
                                         ader_mat_matrix_data, 1.0);

        /* Next, put the element's future value in the future composition row*/

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        /* Now place the element's future value in the iso balance row        */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
                                         (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISO_ROW_ID],
                                         ader_mat_matrix_data, 1.0);

        /* Now, loop through the element's isotopes and set their values in   */
        /* the isotopic balance row                                           */

        ader_mat_ele_iso = (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISOS_PTR];

        while(ader_mat_ele_iso > VALID_PTR)
        {

            ader_mat_iso = (long)RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
                                             (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISO_ROW_ID],
                                             ader_mat_matrix_data, -1.0);

            ader_mat_ele_iso = NextItem(ader_mat_ele_iso);

        }

        ader_mat_ele = NextItem(ader_mat_ele);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialisocompmatrixsection.c         */
/*                                                                           */
/* Created:       2016/03/24 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills in isotopic data for each mat isotope.                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialIsoCompMatrixSection:"

void ADERFillMaterialIsoCompMatrixSection(long ader_mat_matrix_data,
                                          long mat_ader_data)
{

    long ader_mat_iso = 0;

    /* Loop through all the elements in the material                          */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

        /* First, place the isotopes delta value in the balance row           */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_COL_ID],
                                         (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        /* Next, place the isotopes delta value in the delta row              */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_COL_ID],
                                         (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        /* Next, place the isotopes future value in the balance row            */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
                                         (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID],
                                         ader_mat_matrix_data, 1.0);

        /* Next, place the isotopes future value in the future row            */

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
                                         (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID],
                                         ader_mat_matrix_data, -1.0);

        ader_mat_iso = NextItem(ader_mat_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactfeedandremvcompmatrixsection.c*/
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all feed and removal streams*/
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActFeedAndRemvCompMatrixSection:"

void ADERFillMaterialObjActFeedAndRemvCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process feed streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process remv streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactfeedcompmatrixsection.c  */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all feed streams            */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActFeedCompMatrixSection:"

void ADERFillMaterialObjActFeedCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process feed streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactreaccompmatrixsection.c  */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all reac streams            */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActReacCompMatrixSection:"

void ADERFillMaterialObjActReacCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process reac streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactredoxcompmatrixsection.c */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all redox streams           */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActRedoxCompMatrixSection:"

void ADERFillMaterialObjActRedoxCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process redox streams                                              */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactremvcompmatrixsection.c  */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all remv streams            */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActRemvCompMatrixSection:"

void ADERFillMaterialObjActRemvCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process remv streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjactstreamscompmatrixsection.c*/
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all streams                 */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActStreamsCompMatrixSection:"

void ADERFillMaterialObjActStreamsCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process feed streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process redox streams                                              */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process reac streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process remv streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	/* Skip removal tables and destination end streams                */

        	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
        	   (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
        	{

                ader_mat_stream = NextItem(ader_mat_stream);

                continue;

        	}
        	else
        	{

				/* If this is the parent material no correction is needed */

				if(ader_mat_cluster_mem == mat)
				{

					adens_corr_factor = 1.0;

				}
				else
				{

					/* The stream must be normalized to the parent material   */

					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

					adens_corr_factor = src_mat_adens / parent_mat_adens;

				}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

        	}

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjacttransferscompmatrixsection.c*/
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize all streams which connect   */
/*              two actual materials                                         */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjActTransfersCompMatrixSection:"

void ADERFillMaterialObjActTransfersCompMatrixSection(long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process feed streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* Only process streams which connect two actual materials. Thus, */
            /* these streams will have a shadow stream. For normalization     */
            /* purposes only process the source side                          */

            if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material*/

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process redox streams                                              */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* Only process streams which connect two actual materials. Thus, */
            /* these streams will have a shadow stream. For normalization     */
            /* purposes only process the source side                          */

            if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process reac streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* Only process streams which connect two actual materials. Thus, */
            /* these streams will have a shadow stream. For normalization     */
            /* purposes only process the source side                          */

            if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process remv streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* Only process streams which connect two actual materials. Thus, */
            /* these streams will have a shadow stream. For normalization     */
            /* purposes only process the source side                          */

            if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjgrpcompmatrixsection.c      */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', groups */
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize the selected group          */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjGrpCompMatrixSection:"

void ADERFillMaterialObjGrpCompMatrixSection(char* ader_mat_opt_target, long mat)
{

	double adens_corr_factor = 0, cluster_mem_adens = 0, parent_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_cmp, mat_ader_data = 0;

    /* Go ahead and grab the parent mat's adens, it's going to be needed      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their groups              */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        /* Go ahead and grab the cluster mem's adens, it's going to be needed */

        cluster_mem_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Loop through groups                                               */

        ader_mat_cmp = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_CMPS_PTR];

        while(ader_mat_cmp > VALID_PTR)
        {

            /* If the name of the target and the group match, add to matrix   */

            if(strcmp(GetText(ader_mat_cmp + ADER_MAT_CMP_ID),
               ader_mat_opt_target) == 0)
            {

            	/* If this cluster member is the parent, it doesn't need a    */
            	/* correction factor                                          */

            	if(ader_mat_cluster_mem == mat)
            	{

            		adens_corr_factor = 1.0;

            	}
            	else
            	{

            		/* Else it does                                           */

            		adens_corr_factor = parent_mat_adens / cluster_mem_adens;

            	}

                ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID],
                                                 ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                 ader_mat_matrix_data, adens_corr_factor);

            }

            ader_mat_cmp = NextItem(ader_mat_cmp);

        }

        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialobjstreamcompmatrixsection.c   */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's, and its cluster members', streams*/
/*              setting the material composition optimization matrix entries */
/*              in the objective row to optimize the selected stream         */
/*                                                                           */
/* Comments:This function is called from ADERFillMaterialCompMatrixObjRow    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialObjStreamCompMatrixSection:"

void ADERFillMaterialObjStreamCompMatrixSection(char* ader_mat_opt_target, long mat)
{

	double adens_corr_factor = 0, parent_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_cluster_ader_data = 0, ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_matrix_data = 0, ader_mat_stream = 0, ader_mat_stream_shadow = 0;
    long ader_mat_stream_src_mat = 0, mat_ader_data = 0;

    /* This will be needed later for adens normalization                      */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Only parent materials are processed for this so they have matrix data  */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Cycle through the cluster members to process their streams             */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        ader_mat_cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Process feed streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* If the name of the target and the stream match, add to matrix  */

            if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
               ader_mat_opt_target) == 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    Error(0, "Removal table %s entered as stream optimization \n \
target for material %s. \n \
Removal tables are not allowed as optimization targets.\n",
                          GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(mat + MATERIAL_PTR_NAME));

            	}
            	else if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
            	{

            		/* Skip destination sides of shadow streams               */

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process redox streams                                              */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* If the name of the target and the stream match, add to matrix  */

            if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
               ader_mat_opt_target) == 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    Error(0, "Removal table %s entered as stream optimization \n \
target for material %s. \n \
Removal tables are not allowed as optimization targets.\n",
                          GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(mat + MATERIAL_PTR_NAME));

            	}
            	else if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
            	{

            		/* Skip destination sides of shadow streams               */

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process reac streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* If the name of the target and the stream match, add to matrix  */

            if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
               ader_mat_opt_target) == 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    Error(0, "Removal table %s entered as stream optimization \n \
target for material %s. \n \
Removal tables are not allowed as optimization targets.\n",
                          GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(mat + MATERIAL_PTR_NAME));

            	}
            	else if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
            	{

            		/* Skip destination sides of shadow streams               */

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }

        /* Process remv streams                                               */

        ader_mat_stream = (long)RDB[ader_mat_cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

            /* If the name of the target and the stream match, add to matrix  */

            if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
               ader_mat_opt_target) == 0)
            {

            	/* Skip removal tables                                            */

            	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
            	{

                    Error(0, "Removal table %s entered as stream optimization \n \
target for material %s. \n \
Removal tables are not allowed as optimization targets.\n",
                          GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(mat + MATERIAL_PTR_NAME));

            	}
            	else if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR)
            	{

            		/* Skip destination sides of shadow streams               */

                    ader_mat_stream = NextItem(ader_mat_stream);

                    continue;

            	}
            	else
            	{

    				/* If this is the parent material no correction is needed */

    				if(ader_mat_cluster_mem == mat)
    				{

    					adens_corr_factor = 1.0;

    				}
    				else
    				{

    					/* The stream must be normalized to the parent material   */

    					src_mat_adens = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

    					adens_corr_factor = src_mat_adens / parent_mat_adens;

    				}

                    ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                                     ((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1),
                                                     ader_mat_matrix_data, adens_corr_factor);

            	}

            }

            ader_mat_stream = NextItem(ader_mat_stream);

        }


        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialoxicompmatrixsection.c         */
/*                                                                           */
/* Created:       2016/03/24 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills in oxidation data for a material comp matrix           */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialOxiCompMatrixSection:"

void ADERFillMaterialOxiCompMatrixSection(long ader_mat_matrix_data,
                                          long mat_ader_data)
{

    long ader_mat_ele = 0, ader_mat_oxi = 0, ader_oxi = 0, ader_oxi_ele = 0, found = 0;

    /* Grab the material's oxidation data                                     */

    ader_mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    /* Grab the associated ADER Oxidation table                               */

    ader_oxi = (long)RDB[ader_mat_oxi + ADER_MAT_OXI_TBL_PTR];

    /* Now, loop through the ADER oxidation table. For each entry, loop       */
    /* through the mat's elements. Once a matching element for the oxidation  */
    /* entry has been found, the matrix value can be set                      */

    ader_oxi_ele = (long)RDB[ader_oxi + ADER_OXI_ELES_PTR];

    while(ader_oxi_ele > VALID_PTR)
    {

        found = 0;

        ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

        while(ader_mat_ele > VALID_PTR)
        {

            if((long)RDB[ader_oxi_ele + ADER_OXI_ELE_Z] == (long)RDB[ader_mat_ele + ADER_MAT_ELE_Z])
            {

                found = 1;

                break;

            }

            ader_mat_ele = NextItem(ader_mat_ele);

        }

        /* If no matching element was found for an oxidation entry            */
        /* ...something has gone terribly wrong                               */

        if(found < 1)
        {

            Die(FUNCTION_NAME, "No matching element found in material's ADER data \n \
for oxidation table entry having Z value of %ld. This is not a user input error.\n \
Please post on the SERPENT user's group forum as many details regarding the events \n \
leading up to this bug as possible.\n", (long)RDB[ader_oxi_ele + ADER_OXI_ELE_Z]);

        }

        ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
                                         (long)RDB[ader_mat_oxi + ADER_MAT_OXI_ROW_ID],
                                         ader_mat_matrix_data,
                                         (RDB[ader_oxi_ele + ADER_OXI_ELE_VAL] * RDB[ader_oxi_ele + ADER_OXI_ELE_WEIGHT]));

        ader_oxi_ele = NextItem(ader_oxi_ele);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialprescompmatrixsection.c        */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to incorporate different 'preservation'      */
/*              options into the material comp matrix based on pres type     */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADEROperateMaterial                                              */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialPresCompMatrixSection:"

void ADERFillMaterialPresCompMatrixSection(long ader_mat_cluster_ent_mem,
                                           long ader_mat_matrix_data,
                                           long ader_mat_pres)
{

    /* These if statements call the appropriate function depending on the pres*/
    /* type                                                                   */

    if(strncmp("mols", GetText(ader_mat_pres + ADER_MAT_PRESERVE_ENT), 4) == 0)
    {

        ADERFillMaterialPresMolsCompMatrixSection(ader_mat_cluster_ent_mem,
                                                  ader_mat_matrix_data,
                                                  ader_mat_pres);

    }

    /* Put future if statements here to add more 'preserve' options           */

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialpresmolscompmatrixsection.c    */
/*                                                                           */
/* Created:       2016/03/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's stream entries filling in the     */
/*              given preservation row with -1s for src streams and 1s for   */
/*              dest streams. This ensures that 'mols' input and removed by  */
/*              streams are equal. Additionally streams are normalized by    */
/*              material density                                             */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialPresCompMatrixSection                            */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialPresMolsCompMatrixSection:"

void ADERFillMaterialPresMolsCompMatrixSection(long ader_mat_cluster_ent_mem,
                                               long ader_mat_matrix_data,
                                               long ader_mat_pres)
{

	double adens_corr_factor = 0, dest_mat_adens = 0, src_mat_adens = 0;
    long ader_mat_stream = 0, ader_mat_stream_shadow = 0, ader_mat_stream_src_mat = 0;
    long mat_ader_data = 0;

    mat_ader_data = (long)RDB[ader_mat_cluster_ent_mem + MATERIAL_ADER_DATA];

    /* Go through the material's streams and set their matrix entries for     */
    /* this preserve row to reflect that feed amounts must equal removal      */
    /* amounts, skip rem type streams                                         */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
		{

    		ader_mat_stream = NextItem(ader_mat_stream);

    		continue;

		}
    	else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
                       GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

    		/* If this stream has a shadow, which would be a source material  */
    		/* based stream, we must correct for differing atomic densities   */

    		ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    		if(ader_mat_stream_shadow > 0)
    		{

    			ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

    			dest_mat_adens = RDB[ader_mat_cluster_ent_mem + MATERIAL_ADENS];

    			src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

    			adens_corr_factor = (src_mat_adens / dest_mat_adens) *
 			                        (RDB[ader_mat_stream_src_mat + MATERIAL_VOLUME] /
						             RDB[ader_mat_cluster_ent_mem + MATERIAL_VOLUME]);

    		}
    		else
    		{

    			adens_corr_factor = 1.0;

    		}

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, adens_corr_factor);

        }
        else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, -1.0);

        }
        else
        {

            Die(FUNCTION_NAME, "Stream %s in material %s does not have the material\n \
as either a source or a destination. This is not a user input error.\n \
Please post on the SERPENT user's group forum as many details regarding the events \n \
leading up to this bug as possible.\n", GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME));

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
		{

    		ader_mat_stream = NextItem(ader_mat_stream);

    		continue;

		}
    	else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
                       GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

    		/* If this stream has a shadow, which would be a source material  */
    		/* based stream, we must correct for differing atomic densities   */

    		ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    		if(ader_mat_stream_shadow > 0)
    		{

    			ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

    			dest_mat_adens = RDB[ader_mat_cluster_ent_mem + MATERIAL_ADENS];

    			src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

    			adens_corr_factor = (src_mat_adens / dest_mat_adens) *
 			                        (RDB[ader_mat_stream_src_mat + MATERIAL_VOLUME] /
						             RDB[ader_mat_cluster_ent_mem + MATERIAL_VOLUME]);

    		}
    		else
    		{

    			adens_corr_factor = 1.0;

    		}

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, adens_corr_factor);

        }
        else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, -1.0);

        }
        else
        {

            Die(FUNCTION_NAME, "Stream %s in material %s does not have the material\n \
as either a source or a destination. This is not a user input error.\n \
Please post on the SERPENT user's group forum as many details regarding the events \n \
leading up to this bug as possible.\n", GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME));

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
		{

    		ader_mat_stream = NextItem(ader_mat_stream);

    		continue;

		}
    	else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
                       GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

    		/* If this stream has a shadow, which would be a source material  */
    		/* based stream, we must correct for differing atomic densities   */

    		ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    		if(ader_mat_stream_shadow > 0)
    		{

    			ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

    			dest_mat_adens = RDB[ader_mat_cluster_ent_mem + MATERIAL_ADENS];

    			src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

    			adens_corr_factor = (src_mat_adens / dest_mat_adens) *
 			                        (RDB[ader_mat_stream_src_mat + MATERIAL_VOLUME] /
						             RDB[ader_mat_cluster_ent_mem + MATERIAL_VOLUME]);

    		}
    		else
    		{

    			adens_corr_factor = 1.0;

    		}

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, adens_corr_factor);

        }
        else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, -1.0);

        }
        else
        {

            Die(FUNCTION_NAME, "Stream %s in material %s does not have the material\n \
as either a source or a destination. This is not a user input error.\n \
Please post on the SERPENT user's group forum as many details regarding the events \n \
leading up to this bug as possible.\n", GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME));

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
		{

    		ader_mat_stream = NextItem(ader_mat_stream);

    		continue;

		}
    	else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
                       GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

    		/* If this stream has a shadow, which would be a source material  */
    		/* based stream, we must correct for differing atomic densities   */

    		ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    		if(ader_mat_stream_shadow > 0)
    		{

    			ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

    			dest_mat_adens = RDB[ader_mat_cluster_ent_mem + MATERIAL_ADENS];

    			src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

    			adens_corr_factor = (src_mat_adens / dest_mat_adens) *
 			                        (RDB[ader_mat_stream_src_mat + MATERIAL_VOLUME] /
						             RDB[ader_mat_cluster_ent_mem + MATERIAL_VOLUME]);

    		}
    		else
    		{

    			adens_corr_factor = 1.0;

    		}

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, adens_corr_factor);

        }
        else if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
        {

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
                                             ader_mat_matrix_data, -1.0);

        }
        else
        {

            Die(FUNCTION_NAME, "Stream %s in material %s does not have the material\n \
as either a source or a destination. This is not a user input error.\n \
Please post on the SERPENT user's group forum as many details regarding the events \n \
leading up to this bug as possible.\n", GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME));

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfillmaterialstreamcompmatrixsection.c      */
/*                                                                           */
/* Created:       2016/03/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to fill in material comp matrix data for     */
/*              material streams and their sum streams.                      */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialClusterMemCompMatrixSection                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFillMaterialStreamCompMatrixSection:"

void ADERFillMaterialStreamCompMatrixSection(long ader_mat_cluster_ent_mem,
                                             long ader_mat_matrix_data,
                                             long ader_mat_stream)
{

	double dest_mat_adens = 0, adens_multiplier = 0, src_mat_adens = 0;
    long ader_mat_stream_sum_stream = 0, ader_mat_stream_sum_stream_ent = 0;
    long mat_ader_data = 0, shadow_stream = 0, sign = 0, src_mat = 0;

    /* Go ahead and give adens_multiplier a default value of 1                */

    adens_multiplier = 1.0;

    /* If the stream is a rem type, skip it                                   */

    if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
    {

        return;

    }

    /* We need to determine if the stream is leaving or entering the material */
    /* This is most easily done by comparing src and dest names               */

    if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
              GetText(ader_mat_cluster_ent_mem + MATERIAL_PTR_NAME)) == 0)
    {

        /* Stream is leaving the material                                     */

        sign = -1;

    }
    else
    {

        /* Stream is entering the material                                    */

        sign = 1;

        /* If the stream is entering the material it may be the destination   */
        /* end of a shadow stream pair. If so, it will need special           */
        /* processing to account for the source stream's material density and */
        /* volume                                                             */

        shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

        if(shadow_stream > VALID_PTR)
        {

        	dest_mat_adens = RDB[ader_mat_cluster_ent_mem + MATERIAL_ADENS];

        	src_mat = (long)RDB[shadow_stream + ADER_MAT_STREAM_MAT_PTR];

        	src_mat_adens = RDB[src_mat + MATERIAL_ADENS];

        	adens_multiplier = (src_mat_adens / dest_mat_adens) *
        			           (RDB[src_mat + MATERIAL_VOLUME] /
							    RDB[ader_mat_cluster_ent_mem + MATERIAL_VOLUME]);

        }

    }

    /* We didn't pass in the mat_ader_data, so go ahead and grab it           */

    mat_ader_data = (long)RDB[ader_mat_cluster_ent_mem + MATERIAL_ADER_DATA];

    /* Call the element and isotope processing functions to deal with the     */
    /* stream's elements and isotopes                                         */

    ADERFillMaterialCompMatrixEleData((long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR],
                                      (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                      ader_mat_matrix_data, mat_ader_data,
									  adens_multiplier, sign, 0);

    ADERFillMaterialCompMatrixIsoData((long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR],
                                      (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                      ader_mat_matrix_data, mat_ader_data,
									  adens_multiplier, sign, 0);

    /* Only include the data relating summation streams to their parent if    */
    /* this is NOT the shadow stream                                          */

    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] >= 0)
    {


        /* Now, if there are any sum streams, deal with those, but if so, first   */
        /* set the parent groups value for the sum row to 1                       */

        if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID] >= 0)
        {

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID],
                                             ader_mat_matrix_data,
                                             1.0);

        }

        /* Loop through these sum streams and fill in their matrix data           */

        ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

        while(ader_mat_stream_sum_stream_ent > VALID_PTR)
        {

            ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

            ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_COL_ID],
                                             (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID],
                                             ader_mat_matrix_data,
                                             -RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_WEIGHT]);

            ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

        }

    }

    /* Now that we've dealt with the relations between a sum stream and its   */
    /* parent we also need to include the sum stream's elemental and isotopic */
    /* information                                                            */

    ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    {

        ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        ADERFillMaterialStreamCompMatrixSection(ader_mat_cluster_ent_mem,
                                                ader_mat_matrix_data,
                                                ader_mat_stream_sum_stream);

        ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfindshadowstream.c                         */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through materials and their streams looking for a      */
/*              a stream matching the one passed in. Once found the passed   */
/*              in stream's pointer is given to the found stream and it's    */
/*              pointer is returned.                                         */
/*              Additionally ADERFindShadowStreamSumStreams is called to link*/
/*              any sum streams that may be present.                         */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialShadowStreams    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFindShadowStream:"

long ADERFindShadowStream(long ader_mat_stream, long mat)
{

    long ader_search_mat_stream = 0, ader_stream = 0, search_mat = 0, search_mat_ader_data = 0;

    ader_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_PTR];

    search_mat = (long)RDB[DATA_PTR_M0];

    while(search_mat > VALID_PTR)
    {
        /* Don't find the same stream from the same material */

        if(search_mat != mat)
        {

            search_mat_ader_data = (long)RDB[search_mat + MATERIAL_ADER_DATA];

            /* make sure the material is one included in the ader scheme */

            if(search_mat_ader_data > VALID_PTR)
            {

                /* Go through the four types of steams */

                ader_search_mat_stream = (long)RDB[search_mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

                while(ader_search_mat_stream > VALID_PTR)
                {

                    /* If the two streams have the same ader stream parent, we have found our stream */

                    if(ader_stream == (long)RDB[ader_search_mat_stream + ADER_MAT_STREAM_PTR])
                    {

                        WDB[ader_search_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)(-1 * ader_mat_stream);

                        /* These streams may have sum streams, process these */
                        ADERFindShadowStreamSumStreams(ader_search_mat_stream,
                                                       ader_mat_stream, mat);

                        /* We have found our stream, return to the calling function */

                        return(ader_search_mat_stream);

                    }

                    ader_search_mat_stream = NextItem(ader_search_mat_stream);

                }

                ader_search_mat_stream = (long)RDB[search_mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

                while(ader_search_mat_stream > VALID_PTR)
                {

                    /* If the two streams have the same ader stream parent, we have found our stream */

                    if(ader_stream == (long)RDB[ader_search_mat_stream + ADER_MAT_STREAM_PTR])
                    {

                        WDB[ader_search_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)(-1 * ader_mat_stream);

                        /* These streams may have sum streams, process these */
                        ADERFindShadowStreamSumStreams(ader_search_mat_stream,
                                                       ader_mat_stream, mat);

                        /* We have found our stream, return to the calling function */

                        return(ader_search_mat_stream);

                    }

                    ader_search_mat_stream = NextItem(ader_search_mat_stream);

                }

                ader_search_mat_stream = (long)RDB[search_mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

                while(ader_search_mat_stream > VALID_PTR)
                {

                    /* If the two streams have the same ader stream parent, we have found our stream */

                    if(ader_stream == (long)RDB[ader_search_mat_stream + ADER_MAT_STREAM_PTR])
                    {

                        WDB[ader_search_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)(-1 * ader_mat_stream);

                        /* These streams may have sum streams, process these */
                        ADERFindShadowStreamSumStreams(ader_search_mat_stream,
                                                       ader_mat_stream, mat);

                        /* We have found our stream, return to the calling function */

                        return(ader_search_mat_stream);

                    }

                    ader_search_mat_stream = NextItem(ader_search_mat_stream);

                }

                ader_search_mat_stream = (long)RDB[search_mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

                while(ader_search_mat_stream > VALID_PTR)
                {

                    /* If the two streams have the same ader stream parent, we have found our stream */

                    if(ader_stream == (long)RDB[ader_search_mat_stream + ADER_MAT_STREAM_PTR])
                    {

                        WDB[ader_search_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)(-1 * ader_mat_stream);

                        /* These streams may have sum streams, process these */
                        ADERFindShadowStreamSumStreams(ader_search_mat_stream,
                                                       ader_mat_stream, mat);

                        /* We have found our stream, return to the calling function */

                        return(ader_search_mat_stream);

                    }

                    ader_search_mat_stream = NextItem(ader_search_mat_stream);

                }

            }

        }

        search_mat = NextItem(search_mat);

    }

    Error(0, "No matching source stream found for stream %s \n \
in material %s.\n", GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
          GetText(mat + MATERIAL_PTR_NAME));

    return(0);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderfindshadowstreamsumstreams.c               */
/*                                                                           */
/* Created:       2016/03/07 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Recursively searches sum streams to link primary and shadow  */
/*              streams together at every level of summation.                */
/*                                                                           */
/* Comments:This function is called from ADERFindShadowStream and            */
/*          itself, ADERFindShadowStreamSumStreams                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERFindShadowStreamSumStreams:"

void ADERFindShadowStreamSumStreams(long ader_mat_search_stream,
                                    long ader_mat_stream,
                                    long mat)
{

    char *ader_mat_search_stream_sum_stream_id = NULL;
    char *ader_mat_stream_sum_stream_id = NULL;
    long ader_mat_search_stream_sum_stream = 0, ader_mat_search_stream_sum_stream_ent = 0;
    long ader_mat_stream_sum_stream = 0, ader_mat_stream_sum_stream_ent = 0;
    long found = 0;

    ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    /* Search through the primary stream's summation streams */

    while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    {

        /* We will match sum streams by IDs */

        ader_mat_stream_sum_stream_id = GetText(ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID);

        ader_mat_search_stream_sum_stream_ent = (long)RDB[ader_mat_search_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

        /* Search through the shadow stream's sum streams for the match */

        while(ader_mat_search_stream_sum_stream_ent > VALID_PTR)
        {

            ader_mat_search_stream_sum_stream_id = GetText(ader_mat_search_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID);

            /* If the IDs match, the primary stream sum stream gets a positive */
            /* pointer to its shadow while the shadow get's a negative pointer */
            /* to its primary stream                                           */

            if(strcmp(ader_mat_stream_sum_stream_id,
                      ader_mat_search_stream_sum_stream_id) == 0)
            {

                found = 1;

                ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                ader_mat_search_stream_sum_stream = (long)RDB[ader_mat_search_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)ader_mat_search_stream_sum_stream;

                WDB[ader_mat_search_stream_sum_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)(-1 * ader_mat_stream_sum_stream);

                /* Now, these sum streams may, themselves, have sum streams */
                /* So we pass them to this same function to process those   */

                ADERFindShadowStreamSumStreams(ader_mat_search_stream_sum_stream,
                                               ader_mat_stream_sum_stream, mat);

                break;

            }

            ader_mat_search_stream_sum_stream_ent = NextItem(ader_mat_search_stream_sum_stream_ent);

        }

        /* The shadow stream is an exact duplicate of the primary stream. If they */
        /* both do not have the same sum streams ( which means every stream       */
        /* has a match ) there is a serious problem                               */

        if(found != 1)
        {

            Die(FUNCTION_NAME, "No matching shadow stream found for sum stream stream %s \n \
        in stream %s in mat %s.\n",
                  GetText(ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID),
                  GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
                  GetText(mat + MATERIAL_PTR_NAME));

        }

        ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetburnmatrixsizedata.c                    */
/*                                                                           */
/* Created:       2016/20/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Returns an array of doubles arrays. The first double array   */
/*              holds the number of rows in the third array which is the     */
/*              burn matrix solution array. The second array holds the number*/
/*              of non zero entries in the burnup matrix to be built. The    */
/*              third array holds the starting index in the burnup vector at */
/*              which each cluster members data begins. The fourth array is  */
/*              a storage array to be used in the make burn matrix routine   */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                       TESTADERGetBurnMatrixSizeData       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERBurnMaterials:"

double** ADERGetBurnMatrixSizeData(long mat)
{

	double **ader_burn_matrix_size_data = NULL, *ader_burn_matrix_num_non_zero_ents = NULL;
	double *ader_burn_matrix_num_rows = NULL, *ader_burn_matrix_starts = NULL;
	long ader_mat_cluster_mem_iso = 0;
	long ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
	long ader_mat_cluster_mem_ader_data = 0;
	long ader_mat_cluster_mem_stream = 0, ader_mat_cluster_mem_stream_count = 0;
	long mat_ader_data = 0;
	long ader_mat_cluster_mem_count = 0;
	long num_cluster_mem_rows = 0, num_non_zero_ents = 0, num_rows = 0;

	/* Allocate space for the return array                                    */

	ader_burn_matrix_size_data = calloc(5, sizeof(double*));

	/* Allocate an array for the num rows                                     */

	ader_burn_matrix_size_data[0] = calloc(1, sizeof(double));

	/* Allocate an array for the number of non zero entries                   */

	ader_burn_matrix_size_data[1] = calloc(1, sizeof(double));

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* First, loop through all cluster member ents to know how many there are */
	/* so the breaks array can be allocated                                   */

	ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_ent > VALID_PTR)
	{

		ader_mat_cluster_mem_count++;

		ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

	}

	/* Increment the counter again to account for it starting at 0            */

	ader_mat_cluster_mem_count++;

	/* Allocate an array for the breaks                                       */

	ader_burn_matrix_size_data[2] = calloc(ader_mat_cluster_mem_count,
			                               sizeof(double));

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	/* Reset the cluster mem count                                            */

	ader_mat_cluster_mem_count = 0;

	/* Loop through the cluster members                                       */

	ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_ent > VALID_PTR)
	{

		/* Store each cluster member start point. Because num_rows is always  */
		/* incremented after the assignment of a value, assigning it here will*/
		/* always give the index where the next cluster member data starts    */

		ader_burn_matrix_starts[ader_mat_cluster_mem_count] = (double)num_rows;

		num_cluster_mem_rows = 0;

		ader_mat_cluster_mem_stream_count = 0;

		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

		ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

		/* Count the number of non-zero matrix entries provided by this       */
		/* cluster member                                                     */

		num_non_zero_ents += BurnMatrixSize(ader_mat_cluster_mem);

		/* Loop  through the cluster mem's isotopes. We loop through the ader */
		/* isotopes so that they may have their index in the burn matrix.     */
		/* The ader isotopes have a pointer to the material isotopes and all  */
		/* material isotopes are represented in the ader isotope list thanks  */
		/* to earlier linking functions, except the -1 "fictitious" isotope   */
		/* To preserve SERPENT compatibility this isotope is given a row      */
		/* and it's index is stored in the material's ader data               */

		WDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FAKE_ISO_BURN_INDEX] = (double)num_rows;

		num_rows++;

		ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

		while(ader_mat_cluster_mem_iso > VALID_PTR)
		{

		    /* Give the iso its burn idx                                      */

		    WDB[ader_mat_cluster_mem_iso + ADER_MAT_ISO_BURN_INDEX] = (double)num_rows;

			num_cluster_mem_rows++;

			num_rows++;

			ader_mat_cluster_mem_iso = NextItem(ader_mat_cluster_mem_iso);

		}

		/* Loop through the cluster mem's streams, skip disc form streams     */
		/* Cont form streams get a row because they have a constant they need */
		/* to contribute to an isotopes depletion equation while prop streams */
		/* get a row to actually record how they contributed to an isotope's  */
		/* balance. Skip the destination side of shadow streams unless the    */
		/* number of non zero entries is being counted in which case count all*/
		/* isotopes from all continuous streams, shadow or not because each   */
		/* will contribute an entry                                           */

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* This part counts the number of streams needing matrix rows and */
	    	/* also provides these streams with the index of their row.       */
	    	/* Additionally, the second function counts the number of non-zero*/
	    	/* entries the stream contributes to the burnup matrix.           */

	    	if(strncmp("disc",
	    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
						4) != 0)
	    	{

	    		if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR)
	    		{

	    	    	/* Do not count shadow streams, they will share a row with*/
	    	    	/* with the source side of the stream pair.               */

			    	ader_mat_cluster_mem_stream_count = ADERCountStream(ader_mat_cluster_mem_stream,
			    			                                            ader_mat_cluster_mem_stream_count,
																		num_rows);

	    		}

		    	/* Count the entries if the stream is a cont stream ( shadows */
		    	/* of cont streams get counted as well because both the shadow*/
		    	/* and the actual contribute a matrix entry) or a prop stream */
		    	/* with no shadow or one which is the source side of a shadow */

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) ||
		    	   (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
		    		(strncmp("prop",
		    			   	 GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    			     4) == 0)))

	    		num_non_zero_ents = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
	    				                                num_non_zero_ents);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* This part counts the number of streams needing matrix rows and */
	    	/* also provides these streams with the index of their row.       */
	    	/* Additionally, the second function counts the number of non-zero*/
	    	/* entries the stream contributes to the burnup matrix.           */

	    	if(strncmp("disc",
	    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
						4) != 0)
	    	{

	    		if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR)
	    		{

	    	    	/* Do not count shadow streams, they will share a row with*/
	    	    	/* with the source side of the stream pair.               */

			    	ader_mat_cluster_mem_stream_count = ADERCountStream(ader_mat_cluster_mem_stream,
			    			                                            ader_mat_cluster_mem_stream_count,
																		num_rows);

	    		}

		    	/* Count the entries if the stream is a cont stream ( shadows */
		    	/* of cont streams get counted as well because both the shadow*/
		    	/* and the actual contribute a matrix entry) or a prop stream */
		    	/* with no shadow or one which is the source side of a shadow */

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) ||
		    	   (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
		    		(strncmp("prop",
		    			   	 GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    			     4) == 0)))

	    		num_non_zero_ents = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
	    				                                num_non_zero_ents);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* This part counts the number of streams needing matrix rows and */
	    	/* also provides these streams with the index of their row.       */
	    	/* Additionally, the second function counts the number of non-zero*/
	    	/* entries the stream contributes to the burnup matrix.           */

	    	if(strncmp("disc",
	    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
						4) != 0)
	    	{

	    		if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR)
	    		{

	    	    	/* Do not count shadow streams, they will share a row with*/
	    	    	/* with the source side of the stream pair.               */

			    	ader_mat_cluster_mem_stream_count = ADERCountStream(ader_mat_cluster_mem_stream,
			    			                                            ader_mat_cluster_mem_stream_count,
																		num_rows);

	    		}

		    	/* Count the entries if the stream is a cont stream ( shadows */
		    	/* of cont streams get counted as well because both the shadow*/
		    	/* and the actual contribute a matrix entry) or a prop stream */
		    	/* with no shadow or one which is the source side of a shadow */

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) ||
		    	   (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
		    		(strncmp("prop",
		    			   	 GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    			     4) == 0)))

	    		num_non_zero_ents = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
	    				                                num_non_zero_ents);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* This part counts the number of streams needing matrix rows and */
	    	/* also provides these streams with the index of their row.       */
	    	/* Additionally, the second function counts the number of non-zero*/
	    	/* entries the stream contributes to the burnup matrix.           */

	    	if(strncmp("disc",
	    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
						4) != 0)
	    	{

	    		if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR)
	    		{

	    	    	/* Do not count shadow streams, they will share a row with*/
	    	    	/* with the source side of the stream pair.               */

			    	ader_mat_cluster_mem_stream_count = ADERCountStream(ader_mat_cluster_mem_stream,
			    			                                            ader_mat_cluster_mem_stream_count,
																		num_rows);

	    		}

		    	/* Count the entries if the stream is a cont stream ( shadows */
		    	/* of cont streams get counted as well because both the shadow*/
		    	/* and the actual contribute a matrix entry) or a prop stream */
		    	/* with no shadow or one which is the source side of a shadow */

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) ||
		    	   (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
		    		(strncmp("prop",
		    			   	 GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    			     4) == 0)))

	    		num_non_zero_ents = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
	    				                                num_non_zero_ents);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    /* Add the total stream count to both the num rows and the num cluster*/
	    /* rows                                                               */

		num_cluster_mem_rows = num_cluster_mem_rows + ader_mat_cluster_mem_stream_count;

		num_rows = num_rows + ader_mat_cluster_mem_stream_count;

		/* Increment the cluster mem count                                    */

		ader_mat_cluster_mem_count++;

		ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

	}

	/* Allocate an array for the N vector                                     */

	ader_burn_matrix_size_data[3] = calloc(num_rows, sizeof(double));

	/* Allocate an array for the column storage vector                        */

	ader_burn_matrix_size_data[4] = calloc(num_rows, sizeof(double));

	/* Store the number of rows                                               */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_rows[0] = (double)num_rows;

	/* Store the number of non zero entries                                   */

	ader_burn_matrix_num_non_zero_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_num_non_zero_ents[0] = (double)num_non_zero_ents;

	/* And return                                                             */

	return(ader_burn_matrix_size_data);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetburnmatrixvalue.c                       */
/*                                                                           */
/* Created:       2016/22/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Returns the real component of a value found at the passed in */
/*              indices of a burn matrix                                     */
/*                                                                           */
/* Comments:This function is called from TESTADERGetBurnMatrixValue          */
/*                                       TESTADERMakeBurnMatrix              */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetBurnMatrixValue:"

double ADERGetBurnMatrixValue(long col_index, struct ccsMatrix* burn_matrix,
		                      long row_index)
{

	double value = 0.0;
	long i = 0;
	long *col = NULL, *row = NULL;
    complex *val = NULL;

    /* Get pointers to matrix components                                      */

    val = burn_matrix->values;
    row = burn_matrix->rowind;
    col = burn_matrix->colptr;

    /* Col[column_index] stores the row index at which the values in the      */
    /* column represented by column_index start in the row and val vectors.   */
    /* From that index forward, until the index given by Col[column_index + 1]*/
    /* , search row for the passed in row index. The vector index at which the*/
    /* target index is found is the vector index in val which holds the value */
    /* which belongs at the passed in indices                                 */

    for(i = col[col_index]; i < (col[col_index + 1]); i++)
    {

    	if(row[i] == row_index)
    	{

    		value = val[i].re;

    		break;

    	}

    }

	return(value);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergeteigenbias.c                             */
/*                                                                           */
/* Created:       2016/04/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Determines the bias between ADER k-infinity and SERPENT k-eff*/
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRhoRowEntries                 */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetEigenBias:"

double ADERGetEigenBias(long dep, long mat,
		              double t1, double t2)
{

	double ader_k_inf = 0, bias = 0, neutron_loss = 0, neutron_production = 0;
	double non_leakage = 0;
	long ader_mat_iso = 0, mat_ader_data = 0, mat_iso = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the infinite multiplication factor for this material              */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	neutron_loss += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
 		                                 RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
			                             RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
									     t1, t2, dep) *
					    RDB[mat_iso + COMPOSITION_ADENS];

    	neutron_production += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
 		                                       RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
			                                   RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
											   t1, t2, dep) *
							  RDB[mat_iso + COMPOSITION_ADENS];

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    ader_k_inf = neutron_production / neutron_loss;

    non_leakage =  (1.0 - ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
                                           RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
                                           RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
			                               t1, t2, dep));

    bias = Mean((long)RDB[RES_IMP_KEFF], 0) / (ader_k_inf * non_leakage);

    return(bias);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetisoburnmatrixindex.c                    */
/*                                                                           */
/* Created:       2016/22/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Retrieves the index of the isotope which belongs to nuc      */
/*                                                                           */
/* Comments:This function is called from ADERMakeBurnMatrix                  */
/*                                       MaterialBurnup                      */
/*                                       PrintDepMatrix                      */
/*                                       UpdateCIStop                        */
/*                                       TESTADERGetIsoBurnMatrixIndex       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetIsoBurnMatrixIndex:"

long ADERGetIsoBurnMatrixIndex(char* func, long mat, long nuc)
{

	long ader_mat_data = 0, ader_mat_iso = 0, mat_iso = 0, mat_iso_nuc = 0;
	long found = 0, iso_index = -1;

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	if(ader_mat_data < VALID_PTR)
	{

		Die(FUNCTION_NAME, "Material %s passed to ADERGetIsoBurnMatrixIndex by \n\
function %s is not an ADER material.\n", GetText(mat + MATERIAL_PTR_NAME),
            func);

	}

	/* If this function is attempting to retreive the index for the -1 "fake" */
	/* isotope, this index is stored in the material's ader data              */

	if((long)RDB[nuc + NUCLIDE_ZAI] == -1)
	{

		iso_index = (long)RDB[ader_mat_data + ADER_MAT_FAKE_ISO_BURN_INDEX];

	}
	else
	{

		/* Loop through the ader material isotopes, find the one who's ZAI    */
		/* matches the ZAI of nuc. Return the index                           */

		ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

		while(ader_mat_iso > VALID_PTR)
		{

			mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

			mat_iso_nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

			if((long)RDB[mat_iso_nuc + NUCLIDE_ZAI] == (long)RDB[nuc + NUCLIDE_ZAI])
			{

				iso_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

				break;

			}

			ader_mat_iso = NextItem(ader_mat_iso);

		}

	}



	if(iso_index < 0)
	{

		if(found > 0)
		{

			Die(FUNCTION_NAME, "Isotope, with ZAI of %ld, passed to ADERGetIsoBurnMatrixIndex \n\
	by function %s for material %s does not have a valid burn matrix index.\n",
	            (long)RDB[nuc + NUCLIDE_ZAI], func,
				GetText(mat + MATERIAL_PTR_NAME));

		}
		else
		{

			Die(FUNCTION_NAME, "Isotope, with ZAI of %ld, passed to ADERGetIsoBurnMatrixIndex \n\
	by function %s for material %s was not found in said material.\n",
	            (long)RDB[nuc + NUCLIDE_ZAI], func,
				GetText(mat + MATERIAL_PTR_NAME));

		}

	}

	return(iso_index);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetleakagecorrectionfactor.c               */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calculates, averages, and stores the leakage correction      */
/*              factor                                                       */
/*                                                                           */
/* Comments:This function is called from ADERGetTransportInformation         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetLeakageCorrectionFactor:"

void ADERGetLeakageCorrectionFactor(long dep, long i, long step)
{
    double k_eff = 0.0, k_inf = 0.0, leakage = 0;
    long mat = 0, mat_ader_data = 0;

    /* Get the system leakage                                                 */

    k_eff = Mean((long)RDB[RES_IMP_KEFF], 0);

    k_inf = Mean((long)RDB[RES_IMP_KINF], 0);

    if(fabs(((k_eff - k_inf) / k_inf)) < 0.00000001)
    {

    	leakage = 0.0;

    }
    else
    {

        leakage = (1.0 - (Mean((long)RDB[RES_IMP_KEFF], 0) / Mean((long)RDB[RES_IMP_KINF], 0)));

    }

    /* Cycle through the materials, give them this information if they need it*/
    /* If this material isn't under ADER control OR if it isn't involved in   */
    /* reactivity calculations, don't bother with this function               */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

        if(mat_ader_data < VALID_PTR)
        {

            mat = NextItem(mat);

            continue;

        }

        if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
        {

            mat = NextItem(mat);

            continue;

        }

        /* Store the calculated leakage                                       */

        WDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_CUR] = leakage;

        /* Move values to their appropriate holders                           */

        ADERMoveBosEosPs1Values(mat_ader_data + ADER_MAT_SYS_LEAKAGE_AVG,
                                mat_ader_data + ADER_MAT_SYS_LEAKAGE_CUR,
                                mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS,
                                mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS,
                                mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1,
                                mat, step, i);

        mat = NextItem(mat);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetmateleisofrac.c                         */
/*                                                                           */
/* Created:       2016/03/14 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calculates fraction of each isotope belonging to an elemental*/
/*              group as well as the element's fraction of the material      */
/*                                                                           */
/* Comments: This function is called from ADEROperateMaterial                */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetMatEleIsoFrac:"

void ADERGetMatEleIsoFrac(long mat)
{

    double sum = 0;
    long ader_mat_ele = 0, ader_mat_ele_iso = 0, ader_mat_iso = 0, mat_ader_data = 0, iso = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* loop through all of a materials elements */

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

        /* reset the sum for this element                                     */

        sum = 0.0;

        ader_mat_ele_iso = (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISOS_PTR];

        /* get the total adens for all isotopes of this elemental type */

        while(ader_mat_ele_iso > VALID_PTR)
        {

            ader_mat_iso = (long)RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

            iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

            sum += RDB[iso + COMPOSITION_ADENS];

            ader_mat_ele_iso = NextItem(ader_mat_ele_iso);

        }

        /* store the total sum as the fraction of the material for this element*/

        WDB[ader_mat_ele + ADER_MAT_ELE_FRAC] = sum / RDB[mat + MATERIAL_ADENS];

        ader_mat_ele_iso = (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISOS_PTR];

        /* get the relative fraction of each isotope in this element. This    */
        /* if protects against NaNs appearing in the code                     */

        if(sum != 0.0)
        {

            while(ader_mat_ele_iso > VALID_PTR)
            {

                ader_mat_iso = (long)RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

                iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

                WDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_FRAC] = RDB[iso + COMPOSITION_ADENS] / sum;

                ader_mat_ele_iso = NextItem(ader_mat_ele_iso);

            }

        }

        ader_mat_ele = NextItem(ader_mat_ele);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetmaterialcompmatrixelement.c             */
/*                                                                           */
/* Created:       2016/03/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: For the passed in material comp matrix, and the column and   */
/*              row index, returns the value at that position                */
/*                                                                           */
/* Comments:This function is called from                                     */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetMaterialCompMatrixElement:"

double ADERGetMaterialCompMatrixElement(long ader_mat_matrix_data,
                                        long col_index, long row_index)
{

    long ader_mat_matrix_col = 0, ader_mat_matrix_col_row = 0, i = 0;

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    /* Cycle through to the desired column                                    */

    for(i = 0; i < col_index; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    /* Cycle through to the desired row                                       */

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < row_index; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    /* Return the value                                                          */

    return(WDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetmaterialremovalamounts.c                */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function loops through a material's streams, finds rem  */
/*              type streams and calls a function to calculate and store the */
/*              estimated amount to be removed. Ignores dest end of shadow   */
/*              streams, the source end will pass this information to them   */
/*                                                                           */
/* Comments:This function is called from ADEROpeateMaterial                  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetMaterialRemovalAmounts:"

void ADERGetMaterialRemovalAmounts(long mat, long i, double t1, double t2)
{

    long ader_mat_stream = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Loop through all the material's streams                                */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

        	/* Ignore the destination end of linked streams, they don't have  */
        	/* the material composition data to calculate the numbers right   */
        	/* source ends have negative pointers to the destination stream   */

        	if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] <= 0)
        	{

                ADERGetStreamRemovalAmounts(ader_mat_stream, mat, mat_ader_data, t1,
                                            t2);

        	}

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

        	/* Ignore the destination end of linked streams, they don't have  */
        	/* the material composition data to calculate the numbers right   */
        	/* source ends have negative pointers to the destination stream   */

        	if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] <= 0)
        	{

                ADERGetStreamRemovalAmounts(ader_mat_stream, mat, mat_ader_data, t1,
                                            t2);

        	}

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

        	/* Ignore the destination end of linked streams, they don't have  */
        	/* the material composition data to calculate the numbers right   */
        	/* source ends have negative pointers to the destination stream   */

        	if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] <= 0)
        	{

                ADERGetStreamRemovalAmounts(ader_mat_stream, mat, mat_ader_data, t1,
                                            t2);

        	}

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

        	/* Ignore the destination end of linked streams, they don't have  */
        	/* the material composition data to calculate the numbers right   */
        	/* source ends have negative pointers to the destination stream   */

        	if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] <= 0)
        	{

                ADERGetStreamRemovalAmounts(ader_mat_stream, mat, mat_ader_data, t1,
                                            t2);

        	}

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetmaterialshadowstreamisofracs.c          */
/*                                                                           */
/* Created:       2016/04/05 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the isotopes in a source stream copying their  */
/*              fractions to the isotopes of the destination stream          */
/*              Does the same for all sum streams                            */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERProcessMaterialShadowStreamEleAndIsoFracs                    */
/*          ADERGetMaterialShadowStreamIsoFracs                              */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetMaterialShadowStreamIsoFracs:"

void ADERGetMaterialShadowStreamIsoFracs(long ader_mat_stream)
{

	long ader_dest_mat = 0;
	long ader_mat_stream_iso = 0, ader_mat_stream_source_stream = 0;
	long ader_mat_stream_source_stream_iso = 0;
	long ader_mat_sum_stream = 0, ader_mat_sum_stream_ent = 0;
	long ader_src_mat = 0;
	long found = 0;

	/* Get the source stream                                                  */

	ader_mat_stream_source_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

	/* Loop through the destination stream's isotopes                         */

	ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

	while(ader_mat_stream_iso > VALID_PTR)
	{

		found = 0;

		/* Now loop through the source stream's isotopes                      */

		ader_mat_stream_source_stream_iso = (long)RDB[ader_mat_stream_source_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_source_stream_iso > VALID_PTR)
		{

			/* If there is a match, copy the isotope's fraction of the stream */
			/* from the source end to the destination end isotope             */

			if((long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] == (long)RDB[ader_mat_stream_source_stream_iso + ADER_MAT_GRP_ISO_ZAI])
			{

				WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] = RDB[ader_mat_stream_source_stream_iso + ADER_MAT_GRP_ISO_FRAC];

				WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = RDB[ader_mat_stream_source_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

				found = 1;

				break;

			}

			ader_mat_stream_source_stream_iso = NextItem(ader_mat_stream_source_stream_iso);

		}

		/* Error out if no match was found                                    */

		if(found < 1)
		{

			ader_dest_mat = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_MAT_PTR];

			ader_src_mat = (long)RDB[ader_mat_stream_source_stream + ADER_MAT_STREAM_MAT_PTR];

			Error(0, "Isotope %ld in stream %s in material %s does not have a companion isotope\n \
in stream %s in material %s.\n", (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI],
                  GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
				  GetText(ader_dest_mat + MATERIAL_PTR_NAME),
				  GetText(ader_mat_stream_source_stream + ADER_MAT_STREAM_ID),
				  GetText(ader_src_mat + MATERIAL_PTR_NAME));

		}

		ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

	}

	/* Loop through all sum streams and do the same for them                  */

	ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	while(ader_mat_sum_stream_ent > VALID_PTR)
	{

		ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

		ADERGetMaterialShadowStreamIsoFracs(ader_mat_sum_stream);

		ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetmaterialstreamunfixedeleisofracs.c      */
/*                                                                           */
/* Created:       2016/04/05 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link read in ader data with the           */
/*              appropriate materials                                        */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERProcessMaterialStreamUnFixedEleIsoFracs                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetMaterialStreamUnFixedEleIsoFracs:"

void ADERGetMaterialStreamUnFixedEleIsoFracs(long ader_mat_matrix_data,
		                                     long ader_mat_stream, long mat)
{

    double adens_multiplier = 0, dest_mat_adens = 0, src_mat_adens = 0, total_element = 0;
    long ader_mat_iso = 0, ader_mat_stream_ele = 0, ader_mat_stream_ele_iso = 0;
    long ader_mat_stream_iso = 0, ader_mat_stream_sum_stream_data = 0;
    long ader_mat_stream_sum_stream = 0, mat_ader_data = 0, mat_iso = 0, sign = 0;
    long shadow_stream, src_mat;

    /* first, see if there are sum streams, if so, process those              */

    ader_mat_stream_sum_stream_data = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(ader_mat_stream_sum_stream_data > VALID_PTR)
    {

        ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_data + ADER_MAT_GRP_SUM_GRP_PTR];

        ADERGetMaterialStreamUnFixedEleIsoFracs(ader_mat_matrix_data,
        		                                ader_mat_stream_sum_stream, mat);

        ader_mat_stream_sum_stream_data = NextItem(ader_mat_stream_sum_stream_data);

    }

    /* Go ahead and set the adens_muliplier to 1                              */

    adens_multiplier = 1.0;

    /* If the stream is entering the material it may be the destination   */
    /* end of a shadow stream pair. If so, it will need special           */
    /* processing to account for the source stream's material density     */

    shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    if(shadow_stream > VALID_PTR)
    {

    	dest_mat_adens = RDB[mat + MATERIAL_ADENS];

    	src_mat = (long)RDB[shadow_stream + ADER_MAT_STREAM_MAT_PTR];

    	src_mat_adens = RDB[src_mat + MATERIAL_ADENS];

    	adens_multiplier = src_mat_adens / dest_mat_adens;

    }

    /* Loop through the elements of the stream                                */

    ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

    while(ader_mat_stream_ele > VALID_PTR)
    {

        /* Reset the total_element variable                                   */

        total_element = 0.0;

        /* If the element is fixed, no need to run this function on it        */

        if((long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISO_FIXED] > 0)
        {

            ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

            continue;

        }

        /* This element is not fixed. Loop through it's isotopes to calculate */
        /* the relevant fractions                                             */

        ader_mat_stream_ele_iso = (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR];

        while(ader_mat_stream_ele_iso > VALID_PTR)
        {

            /* Now we navigate to the actual material isotope which knows its */
            /* adens                                                          */

            ader_mat_stream_iso = (long)RDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR];

            ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

            mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

            /* Get the total value for the element                            */

            total_element += RDB[mat_iso + COMPOSITION_ADENS];

            /* Store this number in the ele_frac tag for later processing     */

            WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = RDB[mat_iso + COMPOSITION_ADENS];

            ader_mat_stream_ele_iso = NextItem(ader_mat_stream_ele_iso);

        }

        /* Now, loop through the isotopes again to actually calculate the     */
        /* fractions but only if total element is greater than 0              */

        if(total_element > 0.0)
        {

            ader_mat_stream_ele_iso = (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR];

            while(ader_mat_stream_ele_iso > VALID_PTR)
            {

                ader_mat_stream_iso = (long)RDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR];

                /* Give the isotope its current fraction of the element           */

                WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] / total_element;

                /* Give the isotope its current fraction of the stream            */

                WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] = RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] * RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC];

                ader_mat_stream_ele_iso = NextItem(ader_mat_stream_ele_iso);

            }

        }


        ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

    }

    /* Now that we've updated the elemental and isotopic information, we need */
    /* to update the matrix                                                   */

    /* Get the mat_ader_data                                                  */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Determine the "sign" of the stream. Is it entering or leaving this */
    /* material?                                                          */

    if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
              GetText(mat + MATERIAL_PTR_NAME)) == 0)
    {

        /* Stream is leaving the material                                 */

        sign = -1;

    }
    else
    {

        /* Stream is entering the material                                */

        sign = 1;

    }

    /* Fill in the isotopic fractions ( just do all of them )             */

    ADERFillMaterialCompMatrixIsoData((long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR],
                                      (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID],
									  ader_mat_matrix_data,
                                      mat_ader_data, adens_multiplier, sign, 0);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetstreamremovalamounts.c                  */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function calculates and stores the estimated amount of  */
/*              elements and isotopes to be removed                          */
/*                                                                           */
/* Comments:This function is called from ADERGetMaterialRemovalAmounts       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetStreamRemovalAmounts:"

void ADERGetStreamRemovalAmounts(long ader_mat_stream, long mat,
                                 long mat_ader_data, double t1, double t2)
{

    double adens_corr_factor = 0, dest_mat_adens = 0, mat_remv_frac = 0, sign = 0;
    double ader_mat_stream_total_moved = 0.0;
    long ader_mat_iso = 0, ader_mat_shadow_stream = 0;
    long ader_mat_stream_ele = 0, ader_mat_stream_ele_iso = 0;
    long ader_mat_stream_iso = 0, ader_stream = 0, dest_mat = 0, mat_iso = 0;

    /* If this stream has a shadow stream ( which by the way this function    */
    /* is called any shadow stream will be a destination stream and its       */
    /* index will be stored as a negative value in the source stream which    */
    /* the ader_mat_stream would be if this stream has a shadow ) get the     */
    /* shadow stream                                                          */

    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < 0)
    {

    	ader_mat_shadow_stream = -(long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    	/* Get the shadow stream's material                                   */

    	dest_mat = (long)RDB[ader_mat_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

    	dest_mat_adens = RDB[dest_mat + MATERIAL_ADENS];

    	/* Calculate the adens correction factor                              */

    	adens_corr_factor = (RDB[mat + MATERIAL_ADENS] / dest_mat_adens) *
    			            (RDB[mat + MATERIAL_VOLUME] /
    			             RDB[dest_mat + MATERIAL_VOLUME]);

    }
    else
    {

    	ader_mat_shadow_stream = 0;

    }

	/* Determine if this material is the stream's source or sink, set sign    */

	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
			  GetText(mat + MATERIAL_PTR_NAME)) == 0)
	{

		sign = -1.0;

	}
	else
	{

		sign = 1.0;

	}

    /* Get the original ader stream the material stream was based of off      */

    ader_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_PTR];

    /* Store the fraction of the total material that is to processed every    */
    /* second                                                                 */

    mat_remv_frac = RDB[ader_stream + ADER_STREAM_OPT1];

    /* Loop through the stream's elements                                     */

    ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

    while(ader_mat_stream_ele > VALID_PTR)
    {

        /* Clear the element's previous amount that was removed. For removal  */
        /* streams this is stored in the ELE_FRAC slot as it is not used here */

        WDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] = 0.0;

        /* If there is a shadow stream, set its elemental amount              */

        if(ader_mat_shadow_stream > VALID_PTR)
        {

            ADERSetShadowStreamRemovalAmount(ader_mat_shadow_stream,
            		                         (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z],
    										 0, 0.0);

        }

        /* Loop through the element's isotopes                                */

        ader_mat_stream_ele_iso = (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR];

        while(ader_mat_stream_ele_iso > VALID_PTR)
        {

            /* Get the actual stream isotope                                  */
            ader_mat_stream_iso = (long)RDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR];

            /* Get the ader_mat_iso ( needed to get mat_iso )                 */

            ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

            /* Get the mat_iso ( needed for composition ADENS )               */

            mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

            /* Calculate the expected amount of the isotope to be removed     */
            /* this is stored in the ISO_ELE_FRAC slot as it is not used here */

            /* The removal amount must be calculated based on the stream form */

            if(strcmp("prop", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) == 0)
            {

                WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = fabs((RDB[mat_iso + COMPOSITION_ADENS] /
                                                                        RDB[mat + MATERIAL_ADENS]) *
                                                                       (1.0 -
                                                                        exp((t2 - t1) *
                                                                            mat_remv_frac *
																			sign *
                                                                            RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC])));

            }
            else
            {

            	/* Disc and cont form removal tables will remove the same     */
            	/* amount of material, it just happens differently in time    */
            	/* NOTE!!: Disc and Cont removal tables have units in terms   */
            	/* of fraction per second.                                    */

                WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = mat_remv_frac *
                                                                        (t2 - t1) *
                                                                        RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC]*
																		(RDB[mat_iso + COMPOSITION_ADENS] / RDB[mat + MATERIAL_ADENS]);

            }

            /* If there is a shadow stream, set the iso amount                */

            if(ader_mat_shadow_stream > VALID_PTR)
            {

                ADERSetShadowStreamRemovalAmount(ader_mat_shadow_stream,
                		                         0,
        										 (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI],
												 RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] * adens_corr_factor);

            }

            /* Increment the element's expected removal amount                */

            WDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] = RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] +
                                                               RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

            ader_mat_stream_ele_iso = NextItem(ader_mat_stream_ele_iso);

        }

        /* If there is a shadow stream, set the new elemental amount          */

        if(ader_mat_shadow_stream > VALID_PTR)
        {

            ADERSetShadowStreamRemovalAmount(ader_mat_shadow_stream,
            		                         (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z],
    										 0,
											 RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] * adens_corr_factor);

        }

        /* Increment the total amount of material moved                       */

        ader_mat_stream_total_moved += RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC];

        ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

    }

    /* Store the total amount of material moved in both the host and shadow   */
    /* streams                                                                */

    WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = ader_mat_stream_total_moved;

    if(ader_mat_shadow_stream > VALID_PTR)
    {

    	WDB[ader_mat_shadow_stream + ADER_MAT_STREAM_CUR_AMT] = ader_mat_stream_total_moved * adens_corr_factor;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergetstreamtargetremovalamount.c             */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function returns the removal amount of the target       */
/*              element or isotope.                                          */
/*                                                                           */
/* Comments:This function is called from ADERGetTargetRemovalAmount          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetStreamTargetRemovalAmount:"

double ADERGetStreamTargetRemovalAmount(long ader_mat_stream, long ele, long iso)
{

	double amount = 0.0;
    long ader_mat_stream_ele = 0, ader_mat_stream_iso = 0;

    /* Get the element if thats asked for                                     */

    if(ele > 0)
    {

    	/* Loop through the stream's elements                                 */

    	ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

    	while(ader_mat_stream_ele > VALID_PTR)
    	{

    		/* Find the matching element                                      */

    		if((long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z] == ele)
    		{

    			amount = RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC];

    		}


    		ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

    	}

    }
    else
    {

    	/* Get the isotope otherwise                                          */

    	/* Loop through the stream's isotopes                                 */

    	ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

    	while(ader_mat_stream_iso > VALID_PTR)
    	{

    		/* Find the matching isotope                                      */

    		if((long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] == iso)
    		{

    			amount = RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

    		}


    		ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

    	}

    }

    return(amount);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergettargetremovalamount.c                   */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function loops through a material's streams, finds rem  */
/*              type streams and calls a function to accumulate the amount   */
/*              of a target, element or isotope, that is removed by rem      */
/*              streams. It accumulates the net amount.                      */
/*                                                                           */
/* Comments:This function is called from ADEROutputMaterialCompMatrixData    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetTargetRemovalAmount:"

double ADERGetTargetRemovalAmount(long mat, long ele, long iso)
{

	double removal_amount = 0.0;
    long ader_mat_stream = 0, mat_ader_data = 0, sign = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Loop through all the material's streams                                */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

        	/* Determine if this stream is removing or adding material        */

        	if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
        			  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		sign = -1;

        	}
        	else
        	{

        		sign = 1;
        	}

        	/* Get the info from this stream                                  */

        	removal_amount = ADERGetStreamTargetRemovalAmount(ader_mat_stream,
        			                                          ele, iso) * sign + removal_amount;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

        	/* Determine if this stream is removing or adding material        */

        	if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
        			  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		sign = -1;

        	}
        	else
        	{

        		sign = 1;
        	}

        	/* Get the info from this stream                                  */

        	removal_amount = ADERGetStreamTargetRemovalAmount(ader_mat_stream,
        			                                          ele, iso) * sign + removal_amount;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

        	/* Determine if this stream is removing or adding material        */

        	if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
        			  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		sign = -1;

        	}
        	else
        	{

        		sign = 1;
        	}

        	/* Get the info from this stream                                  */

        	removal_amount = ADERGetStreamTargetRemovalAmount(ader_mat_stream,
        			                                          ele, iso) * sign + removal_amount;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

        	/* Determine if this stream is removing or adding material        */

        	if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
        			  GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		sign = -1;

        	}
        	else
        	{

        		sign = 1;
        	}

        	/* Get the info from this stream                                  */

        	removal_amount = ADERGetStreamTargetRemovalAmount(ader_mat_stream,
        			                                          ele, iso) * sign + removal_amount;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    return(removal_amount);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adergettransportinformation.c                  */
/*                                                                           */
/* Created:       2016/04/08 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls various functions to get transmutation cross sections  */
/*              for isotopes as well as the system wide leakage              */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERGetTransportInformation:"

void ADERGetTransportInformation(long dep, long i, long step)
{

    long mat = 0, omp_id = 0, step_type = 0;

    omp_id = OMP_THREAD_NUM;

    step_type = (long)RDB[dep + DEP_HIS_STEP_TYPE];

    /* Gather the transmutation cross sections ( as well as nu-bar ) for  */
    /* each material that is involved in an ader calculation              */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR) &&
           RDB[(long)RDB[mat + MATERIAL_ADER_DATA] + ADER_MAT_RHO_WEIGHT] > 0.0)
        {

            /* Calculate transmutation cross sections */

            CalculateTransmuXS(mat, omp_id);

            /* Store the xs from above */

            StoreTransmuXS(mat, step, step_type, omp_id, i);

        }

        mat = NextItem(mat);

    }

    /* Get the leakage correction factor                                  */

    ADERGetLeakageCorrectionFactor(dep, i, step);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderlinkmaterialgroupisotopes.c                */
/*                                                                           */
/* Created:       2016/1/4 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Links material ader isotope indices to group isotope data    */
/*                                                                           */
/* Comments:This function is called from ADERLinkMaterialIsotopeIndices      */
/*          and by ADERLinkMaterialStreamIsotopes                            */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERLinkMaterialGroupIsotopes:"

void ADERLinkMaterialGroupIsotopes(long ader_mat_ent_iso, long mat)
{

    long ader_mat_ent_iso_zai = 0, mat_ader_data = 0, mat_ader_iso = 0, mat_iso = 0, nuc = 0;
    long nuc_zai = 0;

    /* get the ader data                                                      */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    while(ader_mat_ent_iso > VALID_PTR)
    {

        /* go through the isotope list */

        ader_mat_ent_iso_zai = (long)RDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_ZAI];

        mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

        while(mat_ader_iso > VALID_PTR)
        {

            /* Go through the material's ADER isotopes. If you find a match,  */
            /* store that info                                                */

            mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

            nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

            nuc_zai = (long)RDB[nuc + NUCLIDE_ZAI];

            if(ader_mat_ent_iso_zai == nuc_zai)
            {

                WDB[ader_mat_ent_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR] = mat_ader_iso;

                break;

            }

            mat_ader_iso = NextItem(mat_ader_iso);

        }

        if(WDB[ader_mat_ent_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR] < VALID_PTR)
        {

            Error(0, "No matching material isotope found for group or\n \
stream isotope %ld in material %s. To remedy this error please insert the \n \
isotope in question into the named material's composition definition. This \n \
isotope may be inserted with 0 material fraction. This will preserve simulation\n \
integrity and remedy this error.\n", ader_mat_ent_iso_zai,
                GetText(mat + MATERIAL_PTR_NAME));

        }

        ader_mat_ent_iso = NextItem(ader_mat_ent_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderlinkmaterialisotopeindices.c               */
/*                                                                           */
/* Created:       2016/1/4 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link material isotope indices to group    */
/*              isotope data                                                 */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERLinkMaterialIsotopeIndices:"

void ADERLinkMaterialIsotopeIndices(long mat)
{

    long ader_mat_ent = 0, ader_mat_ent_iso = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* First, call the Process function to create the material isos list */

    ADERProcessMaterialAderIsosData(mat);

    /* Go through the comp groups */

    ader_mat_ent = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(ader_mat_ent > VALID_PTR)
    {

        ader_mat_ent_iso = (long)RDB[ader_mat_ent + ADER_MAT_CMP_ISOS_PTR];

        ADERLinkMaterialGroupIsotopes(ader_mat_ent_iso, mat);

        ader_mat_ent = NextItem(ader_mat_ent);

    }

    /*Go through the streams */

    ader_mat_ent = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_ent > VALID_PTR)
    {

        ADERLinkMaterialStreamIsotopes(ader_mat_ent, mat);

        ader_mat_ent = NextItem(ader_mat_ent);

    }

    ader_mat_ent = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_ent > VALID_PTR)
    {

        ADERLinkMaterialStreamIsotopes(ader_mat_ent, mat);

        ader_mat_ent = NextItem(ader_mat_ent);

    }

    ader_mat_ent = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_ent > VALID_PTR)
    {

        ADERLinkMaterialStreamIsotopes(ader_mat_ent, mat);

        ader_mat_ent = NextItem(ader_mat_ent);

    }

    ader_mat_ent = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_ent > VALID_PTR)
    {

        ADERLinkMaterialStreamIsotopes(ader_mat_ent, mat);

        ader_mat_ent = NextItem(ader_mat_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderlinkmaterialstreamisotopes.c               */
/*                                                                           */
/* Created:       2016/1/4 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Links material isotope indices to group isotope data         */
/*                                                                           */
/* Comments:This function is called from ADERLinkMaterialIsotopeIndices      */
/*          and by itself                                                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERLinkMaterialStreamIsotopes:"

void ADERLinkMaterialStreamIsotopes(long ader_mat_strm, long mat)
{

    long ader_mat_strm_iso = 0, ader_mat_strm_sum_grp = 0, ader_mat_strm_sum_grp_data = 0;

    ader_mat_strm_iso = (long)RDB[ader_mat_strm + ADER_MAT_STREAM_ISOS_PTR];

    /* Pass the first member of the iso list to the following function */
    /* It will go through the rest matching them up to isotopes in the  */
    /* material */

    ADERLinkMaterialGroupIsotopes(ader_mat_strm_iso, mat);

    ader_mat_strm_sum_grp_data = (long)RDB[ader_mat_strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(ader_mat_strm_sum_grp_data > VALID_PTR)
    {

        /* If the stream has summation streams, go through these as well */

        ader_mat_strm_sum_grp = (long)RDB[ader_mat_strm_sum_grp_data + ADER_MAT_GRP_SUM_GRP_PTR];

        ADERLinkMaterialStreamIsotopes(ader_mat_strm_sum_grp, mat);

        ader_mat_strm_sum_grp_data = NextItem(ader_mat_strm_sum_grp_data);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermakeburnmatrix.c                           */
/*                                                                           */
/* Created:       2016/28/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Builds the burnup matrix that can be used to approximate the */
/*              solution to the Bateman equations. This routine will only    */
/*              work with ADER materials                                     */
/*                                                                           */
/* Comments: This function is called from ADERBurnMaterials                  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMakeBurnMatrix:"

void ADERMakeBurnMatrix(struct ccsMatrix* burn_matrix, double* col_vector,
		                long mat, long num_ents, long num_rows, long step,
						long step_type, double t1, double t2)
{

	long *return_array = NULL;
	double mat_flux = 0, micro_cross_section = 0, reaction_rate = 0;
	long ader_mat_cluster_mem = 0, ader_mat_cluster_mem_ader_data = 0;
	long ader_mat_cluster_mem_ader_iso = 0;
	long ader_mat_cluster_mem_ent = 0, ader_mat_cluster_mem_iso = 0;
	long ader_mat_cluster_mem_stream = 0, ader_mat_data = 0, check_column = 0;
	long fission_yield_data = 0, nuc = 0, omp_id = 0, rea = 0, reaction_product_nuc = 0, rea_type = 0;
	long expected_col_index = 0, entry_number = 0;
	long *column_starts = NULL;

	/* Allocate the return array for checking column index matching           */

	return_array = calloc(1, sizeof(long));

	/* Get the thread id                                                      */

	omp_id = OMP_THREAD_NUM;

	/* Grab the pointer to the burn matrix column starts array, the streams   */
	/* section will need this                                                 */

	column_starts = burn_matrix -> colptr;

	/* Go ahead and put the 0 in the 0th index for column starts, its just how*/
	/* this sparse matrix format stores information. See TESTADERSolveClpModel*/
	/* for an example. Both matrices are stored the same way                  */

	column_starts[0] = 0;

	/* Loop through the members of the cluster                                */

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_mem_ent > VALID_PTR)
	{

		/* Get the pointer to the actual material                             */

		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

		/* Generate the XS data for this cluster member                       */

		if((step_type != DEP_STEP_DEC_STEP) && (step_type != DEP_STEP_DEC_TOT) &&
		   (step_type != DEP_STEP_ACT_STEP) && (step_type != DEP_STEP_ACT_TOT))
		{

	        /* Calculate transmutation cross sections */

	        CalculateTransmuXS(ader_mat_cluster_mem, omp_id);

	        /* Store the xs from above */

	        StoreTransmuXS(ader_mat_cluster_mem, step, step_type, omp_id, 0);

		}

        /* Get step weighted XS                                               */

        if((step_type != DEP_STEP_DEC_STEP) && (step_type != DEP_STEP_DEC_TOT))
        {

        	/* Need to loop over cluster mems                                 */

          	AverageTransmuXS(ader_mat_cluster_mem, t1, t2, omp_id);

        }

		/* Get the ader data for this material                                */

		ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        /* Go ahead and give column start information to column_starts from   */
		/* the lost nuclide which has no column information                   */

		column_starts[(long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FAKE_ISO_BURN_INDEX] + 1] = entry_number;

		/* Also, increment the expected col for hte lost nuclide              */

		expected_col_index++;

		/* Get the flux for this material                                     */

		mat_flux = Truncate(RDB[ader_mat_cluster_mem + MATERIAL_BURN_FLUX_SSA], 6);

		/* Loop through the isotopes in this material. We loop over the ader  */
		/* isotopes list as these have pointers to the material isotopes and  */
		/* have their burn matrix index. We do not worry about including the  */
		/* -1 isotope ( which is not in the ader isotope lists ) as, while    */
		/* the -1 isotope is looped over in the SERPENT burnup matrix routine,*/
		/* no information is processed for it unless a nuclide has an         */
		/* undefined fission yeild in which case, as seen below, it's         */
		/* undefined fission products gets "dumped" into this fake nuclide    */

		ader_mat_cluster_mem_ader_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

		while(ader_mat_cluster_mem_ader_iso > VALID_PTR)
		{

			/* Wipe the column vector where iso/stream data is temporarily    */
			/* stored                                                         */

			memset(col_vector, 0.0, sizeof(double) * num_rows);

			/* Get the nuclide associated with this isotope                   */

			ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_PTR];

			nuc = (long)RDB[ader_mat_cluster_mem_iso + COMPOSITION_PTR_NUCLIDE];

			/* Loop over the possible reactions for this isotope              */

			rea = (long)RDB[nuc + NUCLIDE_PTR_REA];

			while(rea > VALID_PTR)
			{

				/* Reset the reaction rate                                    */

				reaction_rate = 0.0;

				/* Get reaction type                                          */

				rea_type = (long)RDB[rea + REACTION_TYPE];

				/* Get pointer to fission yield data                          */

				fission_yield_data = (long)RDB[rea + REACTION_PTR_FISSY];

				/* Get pointer to reaction product "nuc" data                 */

				reaction_product_nuc = (long)RDB[rea + REACTION_PTR_TGT];

				/* If this reaction has fission yield data process that       */

				if(fission_yield_data > VALID_PTR)
				{

					ADERProcessBurnMatrixFissionYield(ader_mat_cluster_mem_ader_iso,
							                          col_vector,
							                          fission_yield_data,
													  ader_mat_cluster_mem,
													  mat_flux, nuc, omp_id,
													  rea, rea_type);

				}
				else if(reaction_product_nuc > VALID_PTR)
				{

					/* If this reaction is a transmutation or decay reaction  */
					/* process the data                                       */

					ADERProcessBurnMatrixTransmutationAndDecay(ader_mat_cluster_mem_ader_iso,
							                                   col_vector,
															   ader_mat_cluster_mem,
															   mat_flux, nuc,
															   omp_id, rea,
															   reaction_product_nuc,
															   rea_type);

				}

				rea = NextItem(rea);

			}

			/* If the fission yield data for this isotope is undefined it will*/
			/* need unique processing                                         */

		    if((long)RDB[nuc + NUCLIDE_PTR_NFY_DATA] < VALID_PTR)
		    {

		    	/* Reset rea to point to total fission data                   */

		    	rea = (long)RDB[nuc + NUCLIDE_PTR_TOTFISS_REA];

		    	/* Now get the cross section                                  */

				micro_cross_section = GetPrivateData(((long)RDB[rea + REACTION_PTR_TRANSMUXS]) + 1,
						                             omp_id);

				/* Make sure a physical answer is provided                    */

				if(micro_cross_section > 0.0)
				{

					/* The branching ratio is purposefully left out           */
					/* here thanks to how the reactions are tabulated         */

					reaction_rate = micro_cross_section * mat_flux * BARN;

					/* Go ahead and add this removal rate to the isotope's    */
					/* own production/destruction rate                        */

					col_vector[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]] -= reaction_rate;

					/* The reaction rate also needs to be added to the -1     */
					/* nuclide in the proper material so we must get it index.*/
					/* which the material has                                 */

					col_vector[(long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FAKE_ISO_BURN_INDEX]] += reaction_rate;

				}
				else
				{

					/* The cross section is not real                          */

					reaction_rate = 0.0;

				}

		    }

		    /* Now the isotope's possible contributions to proportional stream*/
		    /* amounts must be processed, along with prop stream contributions*/
		    /* to isotopes. Loop through the streams, only                    */
		    /* process prop type streams, find the matching isotope if any,   */
		    /* get the transfer rate and include it in the matrix. Only       */
		    /* process the source sides of shadow streams for getting prop    */
		    /* amounts, but the contributions to isotopic amounts will need to*/
		    /* include source and destination ends of streams                 */

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	/* If it's not a prop stream, do not process                  */

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    				4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERProcessBurnMatrixPropStream(ader_mat_cluster_mem_ader_iso,
			    			                        ader_mat_cluster_mem_stream,
													col_vector,
													ader_mat_cluster_mem);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	/* If it's not a prop stream, do not process                  */

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    				4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERProcessBurnMatrixPropStream(ader_mat_cluster_mem_ader_iso,
			    			                        ader_mat_cluster_mem_stream,
													col_vector,
													ader_mat_cluster_mem);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	/* If it's not a prop stream, do not process                  */

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    				4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERProcessBurnMatrixPropStream(ader_mat_cluster_mem_ader_iso,
			    			                        ader_mat_cluster_mem_stream,
													col_vector,
													ader_mat_cluster_mem);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	/* If it's not a prop stream, do not process                  */

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
		    				4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERProcessBurnMatrixPropStream(ader_mat_cluster_mem_ader_iso,
			    			                        ader_mat_cluster_mem_stream,
													col_vector,
													ader_mat_cluster_mem);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

#ifdef ADER_DIAG

		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

		    /* Now, store these values in the matrix                          */

		    entry_number = ADERStoreBurnMatrixColumn(burn_matrix,
		    		                                 (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX],
													 col_vector,
		    		                                 entry_number, num_rows);

		    /* Increment the column counter                                   */

		    expected_col_index++;

		    /* And that ends the isotope section                              */

			ader_mat_cluster_mem_ader_iso = NextItem(ader_mat_cluster_mem_ader_iso);

		}

		/* Now that the cluster member's isotopes have been dealt with the    */
		/* streams must be processed                                          */

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* Prop streams are handled at the iso level. As such, if one is  */
	    	/* found, simply store its column_starts info with no additional  */
	    	/* entries and move on, as long as it is not a destination shadow */
	    	/* stream as they do not get a column                             */

	    	if((strncmp("prop",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

#ifdef ADER_DIAG

		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

	    		column_starts[(long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX] + 1] = entry_number;

			    /* Increment the column counter                               */

			    expected_col_index++;

	    	}

	    	/* Cont type streams need to input their isotopic fractions into  */
	    	/* the burnup matrix. Process them here, but skip the destination */
	    	/* side of shadow streams, they are handled inside the process    */
	    	/* function                                                       */

	    	if((strncmp("cont",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

	    		/* Give the value to return array                             */

	    		return_array[0] = expected_col_index;

	    		entry_number = ADERProcessBurnMatrixContStream(burn_matrix,
                                                               ader_mat_cluster_mem_stream,
															   col_vector,
                                                               entry_number,
															   ader_mat_cluster_mem,
															   num_rows,
															   return_array);

	    		/* Retrieve the value from return_array                       */

	    		expected_col_index = return_array[0];

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* Prop streams are handled at the iso level. As such, if one is  */
	    	/* found, simply store its column_starts info with no additional  */
	    	/* entries and move on, as long as it is not a destination shadow */
	    	/* stream as they do not get a column                             */

	    	if((strncmp("prop",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

#ifdef ADER_DIAG

		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

	    		column_starts[(long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX] + 1] = entry_number;

			    /* Increment the column counter                               */

			    expected_col_index++;

	    	}

	    	/* Cont type streams need to input their isotopic fractions into  */
	    	/* the burnup matrix. Process them here, but skip the destination */
	    	/* side of shadow streams, they are handled inside the process    */
	    	/* function                                                       */

	    	if((strncmp("cont",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

	    		/* Give the value to return array                             */

	    		return_array[0] = expected_col_index;

	    		entry_number = ADERProcessBurnMatrixContStream(burn_matrix,
                                                               ader_mat_cluster_mem_stream,
															   col_vector,
                                                               entry_number,
															   ader_mat_cluster_mem,
															   num_rows,
															   return_array);

	    		/* Retrieve the value from return_array                       */

	    		expected_col_index = return_array[0];

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* Prop streams are handled at the iso level. As such, if one is  */
	    	/* found, simply store its column_starts info with no additional  */
	    	/* entries and move on, as long as it is not a destination shadow */
	    	/* stream as they do not get a column                             */

	    	if((strncmp("prop",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

#ifdef ADER_DIAG

		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

	    		column_starts[(long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX] + 1] = entry_number;

			    /* Increment the column counter                               */

			    expected_col_index++;

	    	}

	    	/* Cont type streams need to input their isotopic fractions into  */
	    	/* the burnup matrix. Process them here, but skip the destination */
	    	/* side of shadow streams, they are handled inside the process    */
	    	/* function                                                       */

	    	if((strncmp("cont",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

	    		/* Give the value to return array                             */

	    		return_array[0] = expected_col_index;

	    		entry_number = ADERProcessBurnMatrixContStream(burn_matrix,
                                                               ader_mat_cluster_mem_stream,
															   col_vector,
                                                               entry_number,
															   ader_mat_cluster_mem,
															   num_rows,
															   return_array);

	    		/* Retrieve the value from return_array                       */

	    		expected_col_index = return_array[0];

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	/* Prop streams are handled at the iso level. As such, if one is  */
	    	/* found, simply store its column_starts info with no additional  */
	    	/* entries and move on, as long as it is not a destination shadow */
	    	/* stream as they do not get a column                             */

	    	if((strncmp("prop",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

#ifdef ADER_DIAG

		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

	    		column_starts[(long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_BURN_INDEX] + 1] = entry_number;

			    /* Increment the column counter                               */

			    expected_col_index++;

	    	}

	    	/* Cont type streams need to input their isotopic fractions into  */
	    	/* the burnup matrix. Process them here, but skip the destination */
	    	/* side of shadow streams, they are handled inside the process    */
	    	/* function                                                       */

	    	if((strncmp("cont",
	    			   GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					   4) == 0) &&
	    	    ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
	    	{

	    		/* Give the value to return array                             */

	    		return_array[0] = expected_col_index;

	    		entry_number = ADERProcessBurnMatrixContStream(burn_matrix,
                                                               ader_mat_cluster_mem_stream,
															   col_vector,
                                                               entry_number,
															   ader_mat_cluster_mem,
															   num_rows,
															   return_array);

	    		/* Retrieve the value from return_array                       */

	    		expected_col_index = return_array[0];

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    /* The stream processing component for cluster members is finished   */

		ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

	}

	/* Give the burnup matrix it's number of non-zero entries                 */

	burn_matrix -> nnz = entry_number;

	/* Free any allocated memory                                              */

	free(return_array);

	/* Done                                                                   */

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermapdensityvector.c                         */
/*                                                                           */
/* Created:       2016/11/06 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Maps material cluster members isotopic densities and         */
/*              continuous stream feed amounts into the density vector       */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMapDensityVector:"

void ADERMapDensityVector(double* ader_burn_matrix_N,
		                  double* ader_burn_matrix_starts, long adj,
						  long direction, long mat, long predictor,
						  double total_time)
{

	double material_adens = 0;
	long ader_mat_cluster_mem = 0, ader_mat_cluster_mem_ader_data = 0;
	long ader_mat_cluster_mem_ader_iso = 0, ader_mat_cluster_mem_ent = 0;
	long ader_mat_cluster_mem_iso = 0, ader_mat_cluster_mem_stream = 0;
	long ader_mat_data = 0, nuc = 0;

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* This is the function operating in "receive" mode                       */

	if(direction > 0)
	{
		ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

		while(ader_mat_cluster_mem_ent > VALID_PTR)
		{

			/* Reset the material adens variable                              */

			material_adens = 0.0;

			/* Get the actual cluster member                                  */

			ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

			/* Get the cluster member ader data                               */

			ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

			/* Go ahead and find the fake iso to give it its data             */

			ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem + MATERIAL_PTR_COMP];

			while(ader_mat_cluster_mem_iso > VALID_PTR)
			{

				nuc = (long)RDB[ader_mat_cluster_mem_iso + COMPOSITION_PTR_NUCLIDE];

				if((long)RDB[nuc + NUCLIDE_ZAI] == -1)
				{

					WDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS] = ader_burn_matrix_N[(long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FAKE_ISO_BURN_INDEX]];

					break;

				}

				ader_mat_cluster_mem_iso = NextItem(ader_mat_cluster_mem_iso);

			}

			/* Pass the cluster members their isotopics, do this by looping   */
			/* through the ader mat isos                                      */

			ader_mat_cluster_mem_ader_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

			while(ader_mat_cluster_mem_ader_iso > VALID_PTR)
			{

				ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_PTR];

				WDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS] = ader_burn_matrix_N[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]];

				material_adens += RDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS];

				ader_mat_cluster_mem_ader_iso = NextItem(ader_mat_cluster_mem_ader_iso);

			}

			/* Give the material its new adens                                */

			WDB[ader_mat_cluster_mem + MATERIAL_ADENS] = material_adens;

			/* Give prop streams their results                                */

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("prop",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

			ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

		}

	}
	else
	{

		/* This is the function operating in "send" mode. First, loop through */
		/* all cluster members                                                */

		ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

		while(ader_mat_cluster_mem_ent > VALID_PTR)
		{

			/* Get the actual cluster member                                  */

			ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

			/* Get the cluster member ader data                               */

			ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

			/* Fill in the cluster member's isotopics                         */

			ader_mat_cluster_mem_ader_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

			while(ader_mat_cluster_mem_ader_iso > VALID_PTR)
			{

				/* Get the material isotope                                   */

				ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_PTR];

				/* On predictor steps it is needed that every isotope's adens */
				/* is copied to the adens_bos position. On corrector steps    */
				/* it is this bos which gets copied to the density vector     */

				if(predictor > 0)
				{

					ader_burn_matrix_N[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]] = RDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS];

					/* On corrector steps this function will be called twice. */
					/* Once it will be called as if it were in a predictor    */
					/* step. This is done so that the ADENS composition can be*/
					/* copied to the N vector for the MaterialBurnUp routine  */
					/* The following if statement ensures the BOS densities   */
					/* are not clobbered                                      */

					if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
					{

						WDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS_BOS] = RDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS];

					}

				}
				else
				{

					ader_burn_matrix_N[(long)RDB[ader_mat_cluster_mem_ader_iso + ADER_MAT_ISO_BURN_INDEX]] = RDB[ader_mat_cluster_mem_iso + COMPOSITION_ADENS_BOS];

				}

				ader_mat_cluster_mem_ader_iso = NextItem(ader_mat_cluster_mem_ader_iso);

			}

			/* Fill in the cluster members's streams                          */

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

		    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

		    while(ader_mat_cluster_mem_stream > VALID_PTR)
		    {

		    	if((strncmp("cont",
		    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
							4) == 0) &&
		    	   ((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR))
		    	{

			    	ADERMapDensityVectorStream(ader_burn_matrix_N,
			    			                   ader_mat_cluster_mem_stream,
										       adj, direction, total_time);

		    	}

		    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

		    }

			ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermapdensityvectorstream.c                   */
/*                                                                           */
/* Created:       2016/21/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sends cont type stream info to the density vector in "send"  */
/*              mode and gives                                               */
/*              prop type streams their amount transfered in "receive" mode  */
/*                                                                           */
/* Comments:This function is called from ADERMapDensityVector                */
/*                                       ADERMapDensityVectorStream          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMapDensityVectorStream:"

void ADERMapDensityVectorStream(double* ader_burn_matrix_N,
		                        long ader_mat_stream, long adj,
								long direction, double total_time)
{

	double adens_corr_factor = 0.0;
	long ader_mat_data = 0, ader_mat_stream_burn_step = 0;
	long ader_mat_stream_shadow_stream = 0, ader_mat_stream_sum_ent = 0;
	long ader_mat_stream_sum_stream = 0, ader_shadow_mat = 0, ader_stream = 0;
	long host_mat = 0, i = 0, mat = 0;

	/* Tunnel into the sum streams of the parent stream if they exist         */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	if(ader_mat_stream_sum_ent > VALID_PTR)
	{

		/* If there are sum streams, pass them to this function               */

		while(ader_mat_stream_sum_ent > VALID_PTR)
		{

			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

			ADERMapDensityVectorStream(ader_burn_matrix_N,
					                   ader_mat_stream_sum_stream,
									   adj, direction, total_time);

			ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

		}

	}
	else
	{

		/* Now that the function has tunneled down to a non-sum-stream, handle*/
		/* information passing                                                */

		if(direction > 0)
		{

			/* Function is in the receive mode, only prop type streams should */
			/* be processed                                                   */

			if(strncmp("prop", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) != 0)
			{

				Error(0, "Stream %s, of form %s, was passed to ADERMapDensityVectorStream \n \
in 'receive' mode. Without form of 'prop' this is an error. Please report as \n\
many simulation details as possible ( input decks and SERPENT version number \n\
mainly ) to the SPERENT users group forums as a bug.\n",
                      GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
					  GetText(ader_mat_stream + ADER_MAT_STREAM_FORM));

			}

			ader_mat_stream_burn_step = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_STEPS_PTR];

			for(i = 0; i < (long)RDB[DATA_BURN_STEP]; i++)
			{

				ader_mat_stream_burn_step = NextItem(ader_mat_stream_burn_step);

			}

			if(adj == 0)
			{

				WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = ader_burn_matrix_N[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]];

			}
			else
			{

				WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = ader_burn_matrix_N[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]] +
																				RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];

			}

			/* If the stream has a shadow, pass the information there as well */
			/* By nature of how this is called, only source streams are       */
			/* present which means they have negative pointers to destination */
			/* streams                                                        */

			ader_mat_stream_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] * -1;

			if(ader_mat_stream_shadow_stream > VALID_PTR)
			{

				ader_shadow_mat = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

				host_mat = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_MAT_PTR];

				adens_corr_factor = RDB[host_mat + MATERIAL_VOLUME] /
						            RDB[ader_shadow_mat + MATERIAL_VOLUME];

				ader_mat_stream_burn_step = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_BURN_STEPS_PTR];

				for(i = 0; i < (long)RDB[DATA_BURN_STEP]; i++)
				{

					ader_mat_stream_burn_step = NextItem(ader_mat_stream_burn_step);

				}

				if(adj == 0)
				{

					WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = ader_burn_matrix_N[(long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_BURN_INDEX]] *
							                                                        adens_corr_factor;

				}
				else
				{

					WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = ader_burn_matrix_N[(long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_BURN_INDEX]]*
							                                                        adens_corr_factor + RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];

				}

			}

		}
		else
		{

			/* The function is in "send" mode, only 'cont' type streams should*/
			/* be sending information                                         */

			if(strncmp("cont", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) != 0)
			{

				Error(0, "Stream %s, of form %s, was passed to ADERMapDensityVectorStream \n \
in 'send' mode. Without form of 'cont' this is an error. Please report as \n\
many simulation details as possible ( input decks and SERPENT version number \n\
mainly ) to the SPERENT users group forums as a bug.\n",
                      GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
					  GetText(ader_mat_stream + ADER_MAT_STREAM_FORM));

			}

			/* This stream is from a source material ( or the destination if  */
			/* the stream does not have a shadow ) and so the material density*/
			/* needed is the host material density. We divide by total_time,  */
			/* or the time in the step, to set the continuous amount from the */
			/* bulk amount calculated by the COIN-OR optimization routine to  */
			/* an amount with units of amount/sec                             */

			mat = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_MAT_PTR];

			ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

			/* If the stream is a removal table it gets different information */

			if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
			{

				if(adj > 0)
				{

					ader_burn_matrix_N[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]] = RDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] * RDB[ader_mat_data + ADER_MAT_PRE_STEP_ADENS] /
							                                                                      total_time;

				}
				else
				{

					ader_burn_matrix_N[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]] = RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] * RDB[ader_mat_data + ADER_MAT_PRE_STEP_ADENS] /
							                                                                      total_time;

				}

			}
			else
			{

				/* The original ader stream will be needed to get the other part  */
				/* of the removal rate                                            */

				ader_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_PTR];

				ader_burn_matrix_N[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]] = RDB[ader_stream + ADER_STREAM_OPT1];

			}

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermatchmaterialclusterisotopes.c             */
/*                                                                           */
/* Created:       2016/2/16 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the isotopes of a given material to ensure that*/
/*              its cluster members have the same isotopes                   */
/*                                                                           */
/* Comments:This function is called from ADERCheckMaterialClusterIsotopes    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMatchMaterialClusterIsotopes:"

void ADERMatchMaterialClusterIsotopes(long mat)
{

    long iso = 0, found = 0, mat_ader_data = 0, mat_cluster_mem = 0, mat_cluster_mem_ent = 0;
    long mat_cluster_mem_iso = 0, mat_cluster_mem_nuc = 0, mat_cluster_mem_zai = 0;
    long nuc = 0, zai = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cluster_mem_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(mat_cluster_mem_ent > VALID_PTR)
    {

        /* Loop through all cluster members. Loop through all members isotopes */
        /* If an isotope is found to be missing from a cluster member, kill the program */

        mat_cluster_mem = (long)RDB[mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

        iso = (long)RDB[mat + MATERIAL_PTR_COMP];

        while(iso > VALID_PTR)
        {

            found = 0;

            nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

            zai = (long)RDB[nuc + NUCLIDE_ZAI];

            /* We must protect against a fictitious nuclide used in burnup routines */

            if(zai == -1)
            {

                iso = NextItem(iso);

                continue;

            }

            mat_cluster_mem_iso = (long)RDB[mat_cluster_mem + MATERIAL_PTR_COMP];

            while(mat_cluster_mem_iso > VALID_PTR)
            {

                mat_cluster_mem_nuc = (long)RDB[mat_cluster_mem_iso + COMPOSITION_PTR_NUCLIDE];

                mat_cluster_mem_zai = (long)RDB[mat_cluster_mem_nuc + NUCLIDE_ZAI];

                if(mat_cluster_mem_zai == zai)
                {

                    found = 1;

                    break;

                }

                mat_cluster_mem_iso = NextItem(mat_cluster_mem_iso);

            }

            if(found != 1)
            {

                Error(0, "An isotope in material, %s, \n\
with ZAI of %ld was not found, also, in material %s. \n\
ADER does not allow materials in the same cluster* to not have the same \n\
isotopes in their definitions. To add the isotope in question to \n\
material %s without affecting the original composition, simply add \n\
the missing isotope into the material's definition with zero fractional\n\
composition. \n \
*[A cluster is a group of materials which are linked together with ADER\n\
streams as defined by the 'stream' entries in the input files.\n\
The two materials listed above are members of the same cluster.]\n",
                      GetText(mat + MATERIAL_PTR_NAME),
                      zai, GetText(mat_cluster_mem + MATERIAL_PTR_NAME),
                      GetText(mat_cluster_mem + MATERIAL_PTR_NAME));

            }

            iso = NextItem(iso);

        }

        mat_cluster_mem_ent = NextItem(mat_cluster_mem_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermergeclusters.c                            */
/*                                                                           */
/* Created:       2016/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: MErges two ader clusters into one cluster list. The          */
/*              deprecated list is left alone but it's parent is changed to  */
/*              "VOID" and is thus skipped for future cluster assignments    */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderClusterMems          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMergeClusters:"

void ADERMergeClusters(long ader_strm_dest_cluster, long ader_strm_src_cluster)
{

    long ader_strm_dest_cluster_ent = 0, ader_strm_src_cluster_ent = 0;
    long found = 0;

    ader_strm_src_cluster_ent = (long)RDB[ader_strm_src_cluster + ADER_CLUSTER_ENT_PTR];

    while(ader_strm_src_cluster_ent > VALID_PTR)
    {

        found = 0;

        ader_strm_dest_cluster_ent = (long)RDB[ader_strm_dest_cluster + ADER_CLUSTER_ENT_PTR];

        while(ader_strm_dest_cluster_ent > VALID_PTR)
        {

            if(strcmp(GetText(ader_strm_src_cluster_ent + ADER_CLUSTER_ENT_ID),
               GetText(ader_strm_dest_cluster_ent + ADER_CLUSTER_ENT_ID)) == 0)
            {

                /* The cluster member from the src cluster is already in the */
                /* dest cluster, we're done on this pass */

                found = 1;

                break;

            }

            ader_strm_dest_cluster_ent = NextItem(ader_strm_dest_cluster_ent);

        }

        if(found == 0)
        {

            /* The src cluster member wasn't found in the dest cluster */
            /* Add it to the dest cluster */

            ADERAddClusterMember(ader_strm_dest_cluster,
                                 GetText(ader_strm_src_cluster_ent + ADER_CLUSTER_ENT_ID),
                                 RDB[ader_strm_src_cluster_ent + ADER_CLUSTER_ENT_ID]);

        }

        ader_strm_src_cluster_ent = NextItem(ader_strm_src_cluster_ent);

    }

    /* 'kill' the src cluster, it has been eaten by the dest cluster! */

    WDB[ader_strm_src_cluster + ADER_CLUSTER_PARENT_ID] = (double)PutText("VOID");

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermoveboseosps1values.c                      */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Moves the values at the passed in indices according to the   */
/*              current step and step type                                   */
/*                                                                           */
/* Comments:This function is called from ADERMoveCrossSection                */
/*                                       ADERGetLeakageCorrectionFactor      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMoveBosEosPs1Values:"

void ADERMoveBosEosPs1Values(long avg_index, long cur_index, long bos_index,
                             long eos_index, long ps1_index, long mat,
                             long step, long iter)
{

    double flux = 0, flux_new_avg = 0, flux_old_avg = 0, new_avg = 0;
    long mat_ader_data = 0, num_corrector_iter = 0;

    /* This top section modifies the avg value during a corrector iteration   */
    /* when using the SIE method for burnup stepping                          */

    if(((long)RDB[DATA_BURN_SIE] == YES) &&
       ((long)RDB[DATA_BURN_STEP_PC] == CORRECTOR_STEP))
    {

        /* If using BurnMaterialsCI do not average                            */

        if((long)RDB[DATA_BURN_CI_FLAG] == YES)
        {

            num_corrector_iter = 1;

        }
        else
        {

            num_corrector_iter = RDB[DATA_BURN_CI_I] + 1;

        }

        /* Get data                                                           */

        mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

        flux = RDB[mat_ader_data + ADER_MAT_FLUX];

        flux_new_avg = RDB[mat_ader_data + ADER_MAT_FLUX_NEW_AVG];

        flux_old_avg = RDB[mat_ader_data + ADER_MAT_FLUX_OLD_AVG];

        /* If there was flux, get a new average, otherwise, set to 0          */

        if(flux_new_avg > 0.0)
        {

            new_avg = ((num_corrector_iter - 1) * flux_old_avg * RDB[avg_index] +
                        flux * RDB[cur_index]) /
                      (flux_new_avg * num_corrector_iter);

        }
        else
        {

            new_avg = 0.0;

        }

        /* If there was a flux this past iteration, store the value. Otherwise*/
        /* do not update                                                      */

        if(flux > 0.0)
        {

            WDB[eos_index] = new_avg;

        }
        else
        {

            WDB[eos_index] = RDB[avg_index];

        }

        /* If this is not a CI iteration, and if there was a contribution,    */
        /* update the aveage                                                  */

        if(((long)RDB[DATA_BURN_CI_FLAG] == NO) && (flux > 0.0))
        {

           WDB[avg_index] = new_avg;

        }

        /* Clear the accumulation slot                                        */

        WDB[cur_index] = 0.0;

        /* No more action needed                                              */

        return;

    }

    if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
    {

        if(step == 0)
        {

            /* Values are accumulated in cur, move them to where they belong  */

            WDB[bos_index] = RDB[cur_index];

            /* Clean cur for future use                                       */

            WDB[cur_index] = 0.0;

            /* First step of predictor, both PS1 and EOS are set to -INFTY    */

            WDB[eos_index] = -INFTY;

            WDB[ps1_index] = -INFTY;

        }
        else
        {

            if(iter == 0)
            {

                /* This is needed to prevent the ps1 value from being         */
                /* overwritten by multiple calculations of the bos value      */

                WDB[ps1_index] = RDB[bos_index];

            }

            WDB[bos_index] = RDB[cur_index];

            WDB[cur_index] = 0.0;

            WDB[eos_index] = -INFTY;

        }

    }
    else
    {

        /* This is a corrector step, a few changes                            */

        WDB[eos_index] = RDB[cur_index];

        WDB[cur_index] = 0.0;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adermovecrosssection.c                         */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Moves ADER cross section data from where it is stored to     */
/*              where it belongs                                             */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERMoveCrossSection:"

void ADERMoveCrossSection(long mat, long step, long iter)
{

    long ader_mat_iso = 0, mat_ader_data = 0;

    /* If this material isn't under ADER control OR if it isn't involved in   */
    /* reactivity calculations, don't bother with this function               */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(mat_ader_data < VALID_PTR)
    {

        return;

    }

    if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
    {

        return;

    }

    /* Loop through a mat's ader isos and move their calculated xs            */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

        ADERMoveBosEosPs1Values(ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_AVG,
                                ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR,
                                ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS,
                                ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS,
                                ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1,
                                mat, step, iter);

        ADERMoveBosEosPs1Values(ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_AVG,
                                ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR,
                                ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS,
                                ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS,
                                ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1,
                                mat, step, iter);

        ADERMoveBosEosPs1Values(ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_AVG,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1,
                                mat, step, iter);

        ADERMoveBosEosPs1Values(ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_AVG,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS,
                                ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1,
                                mat, step, iter);

        ader_mat_iso = NextItem(ader_mat_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adernormalizecrosssection.c                    */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: If a material is under ADER control, and if it has reactivity*/
/*              control, this function will normalize the calculated         */
/*              absorption and fission*nu cross sections                     */
/*                                                                           */
/* Comments:This function is called from CalculateTransmuXS                  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERNormalizeCrossSection:"

void ADERNormalizeCrossSection(double flx, long mat)
{

    long ader_mat_iso = 0, mat_ader_data = 0;

    /* If this material isn't under ADER control OR if it isn't involved in   */
    /* reactivity calculations, don't bother with this function               */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(mat_ader_data < VALID_PTR)
    {

        return;

    }

    if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
    {

        return;

    }

    /* Loop through a mat's ader isos and normalize their calculated xs       */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

        WDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] / flx;

        WDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR] / flx;

        WDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR] / flx;

        ader_mat_iso = NextItem(ader_mat_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoperatematerial.c                          */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This function, which will only operate on ADER controlled    */
/*              materials ( returns with no action otherwise ), calls the    */
/*              various functions needed to update the material composition  */
/*              matrix, solves this matrix, updates the material ader data   */
/*              ( these updates will be used in another routine ), adjusts   */
/*              the material composition as needed as well as the density    */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROperateMaterial:"

void ADEROperateMaterial(long adj, long dep, long i, long mat, long step,
		                 double t1, double t2)
{

    long ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0;
    long ader_mat_cluster_mem_ader_data = 0, ader_mat_matrix_data = 0, ader_mat_pres = 0;
    long ader_mat_stream = 0, mat_ader_data = 0;
    long omp_id = 0;
    long stream_counter = 0;

    omp_id = OMP_THREAD_NUM;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(mat_ader_data < VALID_PTR)
    {

        /* If this material is not under ADER control, do not operate on it   */

        return;

    }

    if((long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR] != mat)
    {

        /* IF this material is not the parent material for an ADER cluster, do*/
        /* not operate on it                                                  */

        return;

    }

    /* Grab the ader_mat_matrix data, its needed later                        */

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    if((long)RDB[mat_ader_data + ADER_MAT_OPT_PTR] > VALID_PTR)
    {

        /* Re-fill the objective row in case material density adjustments     */
        /* are needed, this function only takes parent mats                   */

        ADERFillMaterialCompMatrixObjRow(mat);

    }

    /* Loop through all the members of the cluster                            */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        /* Get the index of the cluster member ( this is like a 'mat' entry   */
        /* elsewhere                                                          */

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        /* Give every ader material a copy of its pre stream adjustment       */
        /* density                                                            */

        ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        WDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRE_STEP_ADENS] = RDB[ader_mat_cluster_mem + MATERIAL_ADENS];

        /* Update the cluster member's elemental isotopics                    */

        ADERGetMatEleIsoFrac(ader_mat_cluster_mem);

        if(adj < 1)
        {

            /* If this is not an adjustment cycle ( adj = 1 )...              */

            /* Update the cluster member's stream's un-fixed elemental        */
            /* isotopics                                                      */

            ADERProcessMaterialStreamUnFixedEleIsoFracs(ader_mat_cluster_mem);

            /* Fill in any preserve row entries, many require density         */
            /* adjustment                                                     */

            ader_mat_pres = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRESERVES_PTR];

            while(ader_mat_pres > VALID_PTR)
            {

                ADERFillMaterialPresCompMatrixSection(ader_mat_cluster_mem,
                                                      ader_mat_matrix_data,
                                                      ader_mat_pres);

                ader_mat_pres = NextItem(ader_mat_pres);

            }

            /* Calculate the amounts of elements and isotopes that will be    */
            /* removed                                                        */

            ADERGetMaterialRemovalAmounts(ader_mat_cluster_mem, i, t1, t2);

        }

        ader_mat_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) > 0)
        	{

        		stream_counter++;

        	}

        	ader_mat_stream = NextItem(ader_mat_stream);

        }

        ader_mat_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) > 0)
        	{

        		stream_counter++;

        	}

        	ader_mat_stream = NextItem(ader_mat_stream);

        }

        ader_mat_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) > 0)
        	{

        		stream_counter++;

        	}

        	ader_mat_stream = NextItem(ader_mat_stream);

        }

        ader_mat_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

        while(ader_mat_stream > VALID_PTR)
        {

        	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) > 0)
        	{

        		stream_counter++;

        	}

        	ader_mat_stream = NextItem(ader_mat_stream);

        }

        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

    /* Loop through all the members of the cluster again to handle destination*/
    /* shadow stream isotopic fraction processing as well as row and column   */
    /* bound adjustment accounting for removal tables                         */

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        /* Get the index of the cluster member ( this is like a 'mat' entry   */
        /* elsewhere                                                          */

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        if(adj < 1)
        {

            /* If this is not an adjustment cycle ( adj = 1 )...              */

            /* Update the cluster member's destination shadow stream's        */
            /* un-fixed elemental isotopics                                   */

            ADERProcessMaterialShadowStreamEleAndIsoFracs(ader_mat_cluster_mem);

            /* Generate and store the necessary cross sections                */

	        CalculateTransmuXS(ader_mat_cluster_mem, omp_id);

	        ADERMoveCrossSection(ader_mat_cluster_mem, step, i);

        }

        /* Adjust the row bounds of the composition matrix based on amounts of*/
        /* material to be removed and amounts of material present             */

        ADERSetMaterialCompMatrixClusterMemRowBounds(dep, i, ader_mat_cluster_mem,
        		                                     0.0,
													 RDB[DATA_BURN_TIME_INTERVAL]);

        /* Set the reactivity control row entries in the comp matrix          */

        ADERSetMaterialCompMatrixClusterMemRhoRowEntries(dep, ader_mat_cluster_mem,
                                                         0.0,
														 RDB[DATA_BURN_TIME_INTERVAL]);

#ifdef ADER_DIAG

        ADERPrintCrossSections(dep, i, mat, step, t1, t2);

#endif

        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

#ifdef ADER_TEST

    /* Tests for matrix solution routines                                     */

    if((i == 0) &&
       (step == 0) &&
	   ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP) &&
       (strncmp("FLiBeFuel", GetText(mat + MATERIAL_PTR_NAME), 9) == 0))
    {

    	TESTADERAllocateClpMemory(step);

    	TESTADERBuildClpModel(step);

    	TESTADERSolveClpModel(step);

    	TESTADERGetTargetRemovalAmount();

    	TESTADERMatEleIsoBounds();

    	TESTADERGetEigenBias(dep, mat, t1, t2);

    }

#endif

    /* If it's only table class streams you don't need an opt matrix          */

    if(stream_counter > 0)
    {

        /* Build, solve, and store the solution from the comp matrix. Adjust the  */
        /* material density for all affected material if desired                  */

        ADEROperateMaterialCompMatrix(adj, i, mat, step);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoperatematerialcompmatrix.c                */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to build the clp model of the material comp  */
/*              matrix and then solves this matrix. Assigns the solution     */
/*              components through ADERParseClpSolution                      */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROperateMaterialCompMatrix:"

void ADEROperateMaterialCompMatrix(long adj, long i, long mat, long step)
{

    double **clp_arrays = NULL;
    double *column_lower_bounds = NULL, *column_upper_bounds = NULL, *index_column_starts = NULL;
    double *objective_row = NULL, *row_lower_bounds = NULL, *row_indices = NULL, *row_upper_bounds = NULL;
    double *solution = NULL, *values = NULL;
    long ader_mat_matrix_data = 0, ader_mat_opt = 0, mat_ader_data = 0, num_ent = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the material optimization data, this will be needed in solve        */

    ader_mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    /* No opt entries were found. At least one is required                    */

    if(ader_mat_opt < VALID_PTR)
    {

        Error(0, "Parent material, %s, has no opt entry and is under ADER control.\n\
At least one member of an ADER cluster* must have opt data in a conditions block\n \
attached to said material. Any material in a cluster, but ONLY ONE material,\n \
may have an opt entry; ADER will copy this entry over to the parent material.\n\n\
* An ADER 'cluster' is a group of materials which are connected \n \
with ADER 'stream' entries.\n\
I.e., materials which are sources and sinks for one another.\n",
                      GetText(mat + MATERIAL_PTR_NAME));

    }

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Call ADERAllocateClpMemory to allocate memory for the clp components   */

    clp_arrays = ADERAllocateClpMemory(ader_mat_matrix_data);

    /* Get the array pointers given by ADERAllocateClpMemory                  */

    column_lower_bounds = clp_arrays[0];

    column_upper_bounds = clp_arrays[1];

    index_column_starts = clp_arrays[2];

    objective_row = clp_arrays[3];

    row_lower_bounds = clp_arrays[4];

    row_indices = clp_arrays[5];

    row_upper_bounds = clp_arrays[6];

    solution = clp_arrays[7];

    values = clp_arrays[8];

#ifdef ADER_DIAG

    ADEROutputMaterialCompMatrixData();

#endif


    /* Pass these array pointers and the requisite information to Build       */

    num_ent = ADERBuildClpModel(ader_mat_matrix_data, column_lower_bounds,
    		                    column_upper_bounds, index_column_starts,
					            objective_row, row_lower_bounds,
					            row_indices, row_upper_bounds, values);

    /* Now that the matrix is built, pass this to solve                       */

    ADERSolveClpModel(column_lower_bounds, column_upper_bounds,
    		          index_column_starts,
					  (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS],
					  num_ent,
					  (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS],
					  objective_row, (long)RDB[ader_mat_opt + ADER_MAT_OPT_DIR],
	                  row_lower_bounds, row_indices,
					  row_upper_bounds, solution, values, mat);

    /* If tests are being used, 0 out the solution vector to ease testing     */

#ifdef ADER_TEST

    TESTAderModifyClpSolution(solution, (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]);

#endif

    /* And now that the solution is known, pass this to Parse                 */

    ADERParseClpSolution(adj, i, mat, step, solution);

#ifdef ADER_TEST

	if((i == 0) && (step == 0) &&
	   ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP) &&
	   (strcmp("FLiBeFuel", GetText(mat + MATERIAL_PTR_NAME)) == 0))
	{

		TESTADERParseClpSolution(solution, step);

	}

#endif

	/* Call ADERDeallocateTarget to free all memory allocated by              */
    /* ADERAllocateClpMemory                                                  */

    ADERDeallocateTarget(clp_arrays, 9);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoutputburnmatrixascsv.c                    */
/*                                                                           */
/* Created:       2017/02/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Writes a burnup matrix out in a csv file format              */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROutputBurnMatrixAsCsv:"

void ADEROutputBurnMatrixAsCsv(struct ccsMatrix* burn_matrix,
							   long ader_mat_burn_matrix_num_rows,
							   long mat, long step, long sub_step)
{

    char file_out[256];
	long i = 0, j = 0, k = 0;
	long *col = NULL, *row = NULL;
    complex *val = NULL;
    FILE *fp = NULL;

    /* Go ahead and create the file name                                      */

    sprintf(file_out, "Cluster_Parent_%s_Burn_Matrix_Step_%ld_Sub_Step_%ld.csv",
    		GetText(mat + MATERIAL_PTR_NAME), step, sub_step);

	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open cluster csv file for writing");

	}

	/* Print the warning into the file                                        */

	fprintf(fp, "WARNING!!!: Matrix is TRANSPOSED. Every ROW is ACTUALLY a COLUMN!!!.\n");

	/* Get the matrix storage units                                           */

    val = burn_matrix->values;
    row = burn_matrix->rowind;
    col = burn_matrix->colptr;

	/* Now, loop through the columns and output the matrix                    */

    for(i = 0; i < ader_mat_burn_matrix_num_rows; i++)
    {

    	k = 0;

    	for(j = 0; j < ader_mat_burn_matrix_num_rows; j++)
    	{

    		if(k >= col[i + 1])
    		{

    			if((j + 1) < ader_mat_burn_matrix_num_rows)
    			{

        			fprintf(fp, "0.0,");

    			}
    			else
    			{

        			fprintf(fp, "0.0");

    			}

    		}
    		else if(row[col[i] + k] == j)
    		{

    			if((j + 1) < ader_mat_burn_matrix_num_rows)
    			{

        			fprintf(fp, "%.22f,", val[col[i] + k].re);

    			}
    			else
    			{

        			fprintf(fp, "%.22f", val[col[i] + k].re);

    			}

				k++;

    		}
    		else
    		{

    			if((j + 1) < ader_mat_burn_matrix_num_rows)
    			{

        			fprintf(fp, "0.0,");

    			}
    			else
    			{

        			fprintf(fp, "0.0");

    			}

    		}

    	}

    	fprintf(fp, "\n");

    }

	/* Close the file                                                         */

	fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoutputmaterialcompmatrixascsv.c            */
/*                                                                           */
/* Created:       2017/02/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Writes a cluster composition matrix out in a csv file format */
/*                                                                           */
/* Comments:This function is called from ADEROutputMaterialCompMatrixData    */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROutputMaterialCompMatrixAsCsv:"

void ADEROutputMaterialCompMatrixAsCsv(long ader_mat_matrix_data,
		                               long cluster_num)
{

    char file_out[256];
    long ader_mat_matrix_col = 0, ader_mat_matrix_col_row = 0;
    FILE *fp = NULL;

    /* Go ahead and create the file name                                      */

    sprintf(file_out, "Cluster_%ld_Material_Composition_Matrix.csv", cluster_num);

	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open cluster csv file for writing");

	}

	/* Print the warning into the file                                        */

	fprintf(fp, "WARNING!!!: Matrix is TRANSPOSED. Every ROW is ACTUALLY a COLUMN!!!.\n");

	/* Now, loop through the rows and columns of the matrix, but first, do    */
	/* the first column so that the \n trick at the begining of the loop ( to */
	/* avoid trailing new lines and commas ) works                            */

	ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

	ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

	/* Also do the first row so no trailing comma                             */

	fprintf(fp, "%.8f", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

	ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

	while(ader_mat_matrix_col_row > VALID_PTR)
	{

		fprintf(fp, ",%.8f", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

		ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

	}

	/* Now loop the rest of the columns                                       */

	ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

	while(ader_mat_matrix_col > VALID_PTR)
	{

		fprintf(fp, "\n");

		/* Again, do the first row, and then loop the rest                    */

		ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

		fprintf(fp, "%.8f", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

		ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

		while(ader_mat_matrix_col_row > VALID_PTR)
		{

			fprintf(fp, ",%.8f", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

			ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

		}

		ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

	}

	/* Close the file                                                         */

	fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoutputmaterialcompmatrixdata.c             */
/*                                                                           */
/* Created:       2017/02/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Writes out all cluster material composition matrix meta data */
/*              to a json formatted text file. Additionally calls supporting */
/*              functions to write out the actual material comp matrix as a  */
/*              csv formatted text file                                      */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROutputMaterialCompMatrixData:"

void ADEROutputMaterialCompMatrixData()
{

    static char *file_out = "ADER_Cluster_Composition_Matrices.json";
    char print_buffer[256], print_data[256];
    double bias = 0.0;
    double iso_max_dec = 0, iso_max_reac = 0, iso_min_dec = 0, iso_min_reac = 0, k_max_inf = 0, k_min_inf = 0, loss_max = 0, loss_min = 0;
    double production_max = 0, production_min = 0, t1 = 0, t2 = 0;
    FILE *fp = NULL;
    long ader_cnt = 0, ader_cnt_ent = 0, ader_data = 0, ader_mat_cluster_mem = 0;
    long ader_mat_cluster_mem_ader_data = 0;
    long ader_mat_cluster_mem_ent = 0, ader_mat_cluster_mem_oxi = 0, ader_mat_cluster_mem_pres = 0;
    long ader_mat_cluster_mem_stream = 0, ader_mat_cmp = 0, ader_mat_cmp_ele = 0;
    long ader_mat_cmp_iso = 0, ader_mat_cmp_rng = 0, ader_mat_cmp_rto = 0, ader_mat_cmp_rto_grp2 = 0, ader_mat_cmp_sum_grp = 0;
    long ader_mat_cnt = 0;
	long ader_mat_data = 0, ader_mat_ele = 0, ader_mat_ele_iso = 0, ader_mat_iso = 0, ader_mat_matrix_data = 0, ader_mat_matrix_col = 0;
	long ader_mat_matrix_row_bound = 0, ader_mat_search_cmp = 0, ader_oxi = 0, ader_oxi_ele = 0;
	long another_cluster = 0, controlled = 0, dep = 0, i = 0, mat = 0, mat_iso = 0;
	long name_counter = 0, nuc = 0, num_cluster_members = 0, num_col = 0;
	long num_row = 0, search_mat = 0, search_ader_mat_data = 0, tab_length = 0, tab_level = 0;
	long num_clusters = 0;

	/* Here we have tab_level place holders                                   */

	long tab_level_init_dict, tab_level_unique_cluster, tab_level_cluster_data;
	long tab_level_cluster_member_info;

	/* Go ahead and set the tab_lenght and tab_level                          */

	tab_length = 4;

	tab_level = 0;

	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open cluster JSON file for writing");

	}

	fprintf(outp, "Beginning cluster data json dump.\n\n");

	/* Print the beginning of the json material clusters list                 */
	/* Don't worry about new-lines for ADERPrintIndentedOutput, it does that  */

	sprintf(print_data, "[");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

	tab_level++;

	/* Create the first dictionary which will hold all the cluster information*/

	sprintf(print_data, "{");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

	tab_level++;

	tab_level_init_dict = tab_level;

	/* Create the clusters dict                                               */

	sprintf(print_data, "\"clusters\" : {");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

	tab_level++;

	tab_level_unique_cluster = tab_level;

	/* Loop through materials to find cluster parents                         */

	mat = (long)RDB[DATA_PTR_M0];

	while(mat > VALID_PTR)
	{

		ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

		if(ader_mat_data > VALID_PTR)
		{

			/* Only be concerned with parent materials                        */

			if((long)RDB[ader_mat_data + ADER_MAT_CLUSTER_PARENT_PTR] == mat)
			{

				tab_level = tab_level_unique_cluster;

				fprintf(outp, "Processing cluster with parent %s.\n\n",
						     GetText(mat + MATERIAL_PTR_NAME));

				/* Create the cluster info dictionary                         */

				sprintf(print_data, "\"cluster_%ld\" : {", num_clusters);

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				tab_level_cluster_data = tab_level;

				/* Increment the number of clusters                           */

				num_clusters++;

				/* Create the parent key and its attribute                    */

				sprintf(print_data, "\"parent\" : \"%s\",",
						            GetText(mat + MATERIAL_PTR_NAME));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				/* Now, create the matrix key                                 */

				sprintf(print_data, "\"composition_matrix_data\" : {");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				/* Get the material composition matrix                        */

				ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

				fprintf(outp, "Processing matrix data for parent %s.\n\n",
						     GetText(mat + MATERIAL_PTR_NAME));

				/* The matrix data is too large to write to the json format   */
				/* As such we call the below function to write out the matrix */
				/* as a separate csv file                                     */

				ADEROutputMaterialCompMatrixAsCsv(ader_mat_matrix_data,
						                          (num_clusters - 1));

				/* Fill in the data for the number of columns and rows        */

				sprintf(print_data, "\"num_cols\" : %ld,",
						            (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]);

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"num_rows\" : %ld,",
						            (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS]);

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				/* Now, create the columns dictionary                         */

				sprintf(print_data, "\"cols\" : {");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				num_col = 0;

				ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

				while(ader_mat_matrix_col > VALID_PTR)
				{

					/* Open the column dictionary                             */

					sprintf(print_data, "\"%ld\" : {", num_col);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Create the column bounds list                          */

					sprintf(print_data, "\"col_bounds\" : [");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Fill the column bounds list                            */

					sprintf(print_data, "%.16f,",
							            RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					sprintf(print_data, "%.16f",
							            RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					/* Close the column bounds list                           */

					sprintf(print_data, "]");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level--;

					/* Close the column dictionary                            */

					if(NextItem(ader_mat_matrix_col) > VALID_PTR)
					{

						sprintf(print_data, "},");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

					}
					else
					{

						/* Final list elements can not have a trailing comma  */

						sprintf(print_data, "}");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

					}

					num_col++;

					ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

				}

				/* Close the columns dictionary                               */

				sprintf(print_data, "},");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

				/* Create the row_bounds dictionary                           */

				sprintf(print_data, "\"row_bounds\" : {");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				num_row = 0;

				/* Now, loop through all the row bounds for this matrix       */

				ader_mat_matrix_row_bound = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

				while(ader_mat_matrix_row_bound > VALID_PTR)
				{

					/* Create the row bound list                              */

					sprintf(print_data, "\"%ld\" : [", num_row);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Fill in the row bound entries                          */

					sprintf(print_data, "%.16f,",
							            RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					sprintf(print_data, "%.16f",
							            RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					/* Close the row bound list                               */

					if(NextItem(ader_mat_matrix_row_bound) > VALID_PTR)
					{

						sprintf(print_data, "],");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}
					else
					{

						/* The last item in a list can not have a trailing ","*/

						sprintf(print_data, "]");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}

					tab_level--;

					num_row++;

					ader_mat_matrix_row_bound = NextItem(ader_mat_matrix_row_bound);

				}

				/* Close the row_bounds dictionary                            */

				sprintf(print_data, "}");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

				/* Close the composition matrix data dict                     */

				sprintf(print_data, "},");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

				fprintf(outp, "Finished matrix processing for parent %s.\n\n",
						     GetText(mat + MATERIAL_PTR_NAME));

				/* Create the members key and start its list                  */

				sprintf(print_data, "\"members\" : [");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				num_cluster_members = 0;

				/* Fill the members list                                      */

				ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

				while(ader_mat_cluster_mem_ent > VALID_PTR)
				{

					num_cluster_members++;

					ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

					/* Print the cluster member name                          */

					/* The last list entry can not have a trailing comma      */

					if(NextItem(ader_mat_cluster_mem_ent) > VALID_PTR)
					{

						sprintf(print_data, "\"%s\",",
								            GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}
					else
					{

						sprintf(print_data, "\"%s\"",
								            GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}

					ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

				}

				/* Close the cluster members list                             */

				sprintf(print_data, "],");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

				/* Open the cluster members info dict                         */

				sprintf(print_data, "\"members_info\" : {");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				tab_level_cluster_member_info = tab_level;

				/* Now, loop through the cluster members                      */

				ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

				while(ader_mat_cluster_mem_ent > VALID_PTR)
				{

					ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

					ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

					fprintf(outp, "Processing cluster member %s.\n\n",
							     GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

					/* Open the cluster member info dict                      */

					sprintf(print_data, "\"%s\" : {",
							            GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Provide the material density                           */

					sprintf(print_data, "\"density\" : %0.16f,	",
							            RDB[ader_mat_cluster_mem + MATERIAL_ADENS]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					/* Provide the material volume                            */

					sprintf(print_data, "\"volume\" : %0.16f,	",
							            RDB[ader_mat_cluster_mem + MATERIAL_VOLUME]);

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					/* Give the reactivity min and max rows if they exist     */
					/* as well as the criticality targest and leakage         */

					if(RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
					{

						sprintf(print_data, "\"rho_max_row\" : %ld,",
								            (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_RHO_MAX_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						sprintf(print_data, "\"rho_min_row\" : %ld,",
								            (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_RHO_MIN_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						sprintf(print_data, "\"leakage\" : %0.16f,",
								            RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_CUR]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Get the ader data to get the kmax and kmin targets */

						ader_data = (long)RDB[DATA_PTR_ADER];

						sprintf(print_data, "\"k_max\" : %0.8f,",
								            RDB[ader_data + ADER_K_MAX]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						sprintf(print_data, "\"k_min\" : %0.8f,",
								            RDB[ader_data + ADER_K_MIN]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}

					/* Open the cluster member elements dict                  */

					sprintf(print_data, "\"eles\" : {");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Loop through the cluster member's elements             */

					ader_mat_ele = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ELES_PTR];

					while(ader_mat_ele > VALID_PTR)
					{

						/* Open the element dictionary                        */

						sprintf(print_data, "\"%ld\" : {", (long)RDB[ader_mat_ele + ADER_MAT_ELE_Z]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Give the amount of the element in the material     */

						sprintf(print_data, "\"amount\" : %.16f,",
								            RDB[ader_mat_ele + ADER_MAT_ELE_FRAC]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the del col id entry                        */

						sprintf(print_data, "\"del_col_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_COL_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the fut col id entry                        */

						sprintf(print_data, "\"fut_col_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the bal row id entry                        */

						sprintf(print_data, "\"bal_row_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the del row id entry                        */

						sprintf(print_data, "\"del_row_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the fut row id entry                        */

						sprintf(print_data, "\"fut_row_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the iso row id entry                        */

						sprintf(print_data, "\"iso_row_id\" : %ld,",
								            (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISO_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Provide the amount removed by rem tables           */

						sprintf(print_data, "\"amount_removed\" : %0.16f,",
								            ADERGetTargetRemovalAmount(ader_mat_cluster_mem,
								            		                   (long)RDB[ader_mat_ele + ADER_MAT_ELE_Z],
																	   0));

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Open the element's isos dictionary                 */

						sprintf(print_data, "\"isos\" : {");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Now loop through the element's isos                */

						ader_mat_ele_iso = (long)RDB[ader_mat_ele + ADER_MAT_ELE_ISOS_PTR];

						while(ader_mat_ele_iso > VALID_PTR)
						{

							/* Get the ZAI of the isotope                     */

							ader_mat_iso = (long)RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

							mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

							nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

							/* Create the element iso's dict entry            */

							if(NextItem(ader_mat_ele_iso) > VALID_PTR)
							{

								sprintf(print_data, "\"%ld\" : %.16f,",
										            (long)RDB[nuc + NUCLIDE_ZAI],
													RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_FRAC]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							}
							else
							{

								sprintf(print_data, "\"%ld\" : %.16f",
										            (long)RDB[nuc + NUCLIDE_ZAI],
													RDB[ader_mat_ele_iso + ADER_MAT_ELE_ISO_FRAC]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							}

							ader_mat_ele_iso = NextItem(ader_mat_ele_iso);

						}

						/* Close the element's isos dictionary                */

						sprintf(print_data, "},");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

				        /* Now we search the materials cnt tables to see if   */
						/* this element is controlled                         */

						controlled = 0;

				        ader_mat_cnt = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_CNT_TBLS_PTR];

				        while(ader_mat_cnt > VALID_PTR)
				        {

				            /* The mat cnt simply points to the ader cnt      */

				            ader_cnt = (long)RDB[ader_mat_cnt + ADER_MAT_CNT_TBL_PTR];

				            ader_cnt_ent = (long)RDB[ader_cnt + ADER_CONTROL_ENT_PTR];

				            while(ader_cnt_ent > VALID_PTR)
				            {

				                /* go though the ader cnt's entries, if a Z   */
				            	/* matches this element you have a match,     */
				            	/* break this loop and exit the next          */

				                if((long)RDB[ader_mat_ele + ADER_MAT_ELE_Z] == (long)RDB[ader_cnt_ent + ADER_CONTROL_ENT_Z])
				                {

				                    controlled = 1;

				                    break;

				                }

				                ader_cnt_ent = NextItem(ader_cnt_ent);

				            }

				            /* Control was found, break the overall cnt loop */

				            if(controlled > 0)
				            {

				                break;

				            }

				            ader_mat_cnt = NextItem(ader_mat_cnt);

				        }

				        /* Create the elemental control entry                 */

				        if(controlled > 0)
				        {

							sprintf(print_data, "\"control\" : \"yes\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				        }
				        else
				        {

							sprintf(print_data, "\"control\" : \"no\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				        }

						/* Close the element dictionary                       */

						if(NextItem(ader_mat_ele) > VALID_PTR)
						{

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}
						else
						{

							sprintf(print_data, "}");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}

						tab_level--;

						ader_mat_ele = NextItem(ader_mat_ele);

					}

					/* Close the cluster member elements dict                 */

					sprintf(print_data, "},");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level--;

					/* Open the cluster member isos dict                      */

					sprintf(print_data, "\"isos\" : {");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Loop through the cluster member's isotopes             */

					ader_mat_iso = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ISOS_PTR];

					while(ader_mat_iso > VALID_PTR)
					{

						/* Get the ZAI of the isotope in question             */

						mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

						nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

						/* Open the iso dictionary                            */

						sprintf(print_data, "\"%ld\" : {",
								            (long)RDB[nuc + NUCLIDE_ZAI]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Give the amount of the isotope in the material     */

						sprintf(print_data, "\"amount\" : %.16f,",
								            RDB[mat_iso + COMPOSITION_ADENS] /
											RDB[ader_mat_cluster_mem + MATERIAL_ADENS]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the del col id entry                        */

						sprintf(print_data, "\"del_col_id\" : %ld,",
								            (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_COL_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the fut col id entry                        */

						sprintf(print_data, "\"fut_col_id\" : %ld,",
								            (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the bal row id entry                        */

						sprintf(print_data, "\"bal_row_id\" : %ld,",
								            (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the del row id entry                        */

						sprintf(print_data, "\"del_row_id\" : %ld,",
								            (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Create the fut row id entry                        */

						sprintf(print_data, "\"fut_row_id\" : %ld,",
								            (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						if(RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
						{

							/* Provide the isotope reactivity entries as well     */
							/* First, they will have to be calculated. This relies*/
							/* on some support functions and the assumption that  */
							/* the first burnup step is being used                */

							t1 = 0.0;

							t2 = RDB[DATA_BURN_TIME_INTERVAL];

							bias = ADERGetEigenBias(dep, ader_mat_cluster_mem, t1, t2);

							dep = (long)RDB[DATA_BURN_PTR_DEP];

							ader_data = (long)RDB[DATA_PTR_ADER];

							/* The below equation should resemble...              */
							/* ( ( ( K_max / (( 1 - rho_l ) * bias ) ) * Sigma_a ) - ( nu * Sigma_f ) ) */

							k_max_inf = (RDB[ader_data + ADER_K_MAX] /
									     ((1.0 - ADERAverageValue(RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
									        		              RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
															      RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
																  t1, t2, dep)) *
									       bias));

							loss_max = k_max_inf * ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
									                                RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
																	RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
																	t1, t2, dep);

							production_max = ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
									                          RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
															  RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
															  t1, t2, dep);

							iso_max_reac = loss_max - production_max;

							iso_max_dec = production_max - loss_max;

							k_min_inf = (RDB[ader_data + ADER_K_MIN] /
									     ((1.0 - ADERAverageValue(RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
									        		              RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
															      RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
																  t1, t2, dep)) *
									       bias));

							loss_min = k_min_inf * ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
									                                RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
																	RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
																	t1, t2, dep);

							production_min = ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
									                          RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
															  RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
															  t1, t2, dep);

							iso_min_reac = loss_min - production_min;

							iso_min_dec = production_min - loss_min;

							sprintf(print_data, "\"max_reac\" : %0.16f,",
									            iso_max_reac);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"min_reac\" : %0.16f,",
									            iso_min_reac);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"max_dec\" : %0.16f,",
									            iso_max_dec);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"min_dec\" : %0.16f,",
									            iso_min_dec);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}

						/* Provide the amount removed by rem tables           */

						sprintf(print_data, "\"amount_removed\" : %0.16f,",
								            ADERGetTargetRemovalAmount(ader_mat_cluster_mem,
								            		                   0,
																	   (long)RDB[nuc + NUCLIDE_ZAI]));

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				        /* Now we search the materials cnt tables to see if   */
						/* this isotope is controlled                         */

						controlled = 0;

				        ader_mat_cnt = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_CNT_TBLS_PTR];

				        while(ader_mat_cnt > VALID_PTR)
				        {

				            /* The mat cnt simply points to the ader cnt      */

				            ader_cnt = (long)RDB[ader_mat_cnt + ADER_MAT_CNT_TBL_PTR];

				            ader_cnt_ent = (long)RDB[ader_cnt + ADER_CONTROL_ENT_PTR];

				            while(ader_cnt_ent > VALID_PTR)
				            {

				                /* go though the ader cnt's entries, if a ZAI */
				            	/* matches this isotope you have a match,     */
				            	/* break this loop and exit the next          */

				                if((long)RDB[nuc + NUCLIDE_ZAI] == (long)RDB[ader_cnt_ent + ADER_CONTROL_ENT_ZAI])
				                {

				                    controlled = 1;

				                    break;

				                }

				                ader_cnt_ent = NextItem(ader_cnt_ent);

				            }

				            /* Control was found, break the overall cnt loop */

				            if(controlled > 0)
				            {

				                break;

				            }

				            ader_mat_cnt = NextItem(ader_mat_cnt);

				        }

				        /* Create the isotope control entry                   */

				        if(controlled > 0)
				        {

							sprintf(print_data, "\"control\" : \"yes\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				        }
				        else
				        {

							sprintf(print_data, "\"control\" : \"no\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				        }

						/* Close the isotope dictionary                       */

						if(NextItem(ader_mat_iso) > VALID_PTR)
						{

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}
						else
						{

							sprintf(print_data, "}");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}

						tab_level--;

						ader_mat_iso = NextItem(ader_mat_iso);

					}

					/* Close the cluster member isotope dict                  */

					sprintf(print_data, "},");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level--;

					/* Open the CMP groups dict                                */

					sprintf(print_data, "\"cmp_groups\" : {");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Loop through the material's cmp groups                 */

					ader_mat_cmp = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_CMPS_PTR];

					while(ader_mat_cmp > VALID_PTR)
					{

						/* Save the name to print buffer                      */

						strcpy(print_buffer,
							   GetText(ader_mat_cmp + ADER_MAT_CMP_ID));

						/* Now determine if this cmp group has a unique name  */
						/* If not, modify the name for testing                */

						name_counter = 0;

						ader_mat_search_cmp = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_CMPS_PTR];

						while(ader_mat_search_cmp > VALID_PTR)
						{

							if(ader_mat_cmp == ader_mat_search_cmp)
							{

								/* There is no need to count past the cmp     */
								/* group in question                          */

								break;

							}

							if(strcmp(GetText(ader_mat_cmp + ADER_MAT_CMP_ID),
									  GetText(ader_mat_search_cmp + ADER_MAT_CMP_ID)) == 0)
							{

								name_counter++;

							}

							ader_mat_search_cmp = NextItem(ader_mat_search_cmp);

						}

						if(name_counter > 0)
						{

							sprintf(print_data, "_%ld", name_counter);

							strcat(print_buffer, print_data);

						}

						/* Now check to see if the print name needs           */
						/* modification                                       */

						/* Open the cmp group's dict                          */

						sprintf(print_data, "\"%s\" : {", print_buffer);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Provide the WDB address, helps with id             */

						sprintf(print_data, "\"WDB_address\" : %ld,", ader_mat_cmp);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Provide the cmp group's col id                     */

						sprintf(print_data, "\"col_id\" : %ld,",
								            (long)RDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Open the cmp group's bounds list                   */

						sprintf(print_data, "\"col_bounds\" : [");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						ader_mat_cmp_rng = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RNG_PTR];

						if(ader_mat_cmp_rng > VALID_PTR)
						{

							sprintf(print_data, "%.16f,",
									            RDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MIN]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "%.16f",
									            RDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MAX]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}
						else
						{

							sprintf(print_data, "\"NULL\",");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"NULL\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						}

						/* Close the column's bounds list                     */

						sprintf(print_data, "],");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

						/* Provide the cmp group's sum row id if it exists    */

						if((long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR] > VALID_PTR)
						{

							sprintf(print_data, "\"sum_row_id\" : %ld,",
									            (long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							/* Open the sum grps dict                         */

							sprintf(print_data, "\"sum_grps\" : {");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							/* Loop through the sum grps                      */

							ader_mat_cmp_sum_grp = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR];

							while(ader_mat_cmp_sum_grp > VALID_PTR)
							{

								/* Print out the key value pair, i.e., the    */
								/* the sum grp name and weight                */

								if(NextItem(ader_mat_cmp_sum_grp) > VALID_PTR)
								{

									sprintf(print_data, "\"%ld\" : %.16f,",
											            (long)RDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_PTR],
											            RDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_WEIGHT]);

									ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								}
								else
								{

									sprintf(print_data, "\"%ld\" : %.16f",
											            (long)RDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_PTR],
											            RDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_WEIGHT]);

									ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								}

								ader_mat_cmp_sum_grp = NextItem(ader_mat_cmp_sum_grp);

							}

							/* Close the sum grps dict                        */

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}
						else
						{

							sprintf(print_data, "\"sum_row_id\" : \"NULL\",");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							/* Set the sum_grps dict to NULL                  */

							sprintf(print_data, "\"sum_grps\" : {");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							sprintf(print_data, "\"NULL\" : \"NULL\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}

						/* Open the rto list                                  */

						ader_mat_cmp_rto = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RTOS_PTR];

						if(ader_mat_cmp_rto > VALID_PTR)
						{

							sprintf(print_data, "\"cmp_rtos\" : [");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							while(ader_mat_cmp_rto > VALID_PTR)
							{

								/* Open the cmp rto dict                      */

								sprintf(print_data, "{");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level++;

								/* Provide the name and rto group name        */

								ader_mat_cmp_rto_grp2 = (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

								sprintf(print_data, "\"grp2\" : \"%s\",",
										            GetText(ader_mat_cmp_rto_grp2 + ADER_MAT_CMP_ID));

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Provide the id of the rto group            */

								sprintf(print_data, "\"grp2_WDB_address\" : %ld,",
										            ader_mat_cmp_rto_grp2);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Provide the rto max value                  */

								sprintf(print_data, "\"max\" : %.16f,",
										            RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Provide the rto min value                  */

								sprintf(print_data, "\"min\" : %.16f,",
										            RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Provide the rto max row value              */

								sprintf(print_data, "\"max_row\" : %ld,",
										            (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX_ROW_ID]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Provide the rto min row value              */

								sprintf(print_data, "\"min_row\" : %ld",
										            (long)RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN_ROW_ID]);

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								/* Close the cmp rto dict                     */

								if(NextItem(ader_mat_cmp_rto) > VALID_PTR)
								{

									sprintf(print_data, "},");

									ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

									tab_level--;

								}
								else
								{

									sprintf(print_data, "}");

									ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

									tab_level--;

								}

								ader_mat_cmp_rto = NextItem(ader_mat_cmp_rto);

							}

						}
						else
						{

							sprintf(print_data, "\"cmp_rtos\" : [");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							sprintf(print_data, "\"NULL\"");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);


						}

						/* Close the cmp rtos list                            */

						sprintf(print_data, "],");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

						/* Open the cmp eles list                             */

						sprintf(print_data, "\"eles\" : [");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Loop through the cmp eles                          */

						ader_mat_cmp_ele = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_ELES_PTR];

						while(ader_mat_cmp_ele > VALID_PTR)
						{

							/* Open the cmp ele dict                          */

							sprintf(print_data, "{");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							/* Enter the ele information                      */

							sprintf(print_data, "\"%ld\" : %.16f",
									            (long)RDB[ader_mat_cmp_ele + ADER_MAT_GRP_ELE_Z],
												RDB[ader_mat_cmp_ele + ADER_MAT_GRP_ELE_FRAC]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							/* Close the cmp ele dict                         */

							if(NextItem(ader_mat_cmp_ele) > VALID_PTR)
							{

								sprintf(print_data, "},");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}
							else
							{

								sprintf(print_data, "}");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}

							ader_mat_cmp_ele = NextItem(ader_mat_cmp_ele);

						}

						/* Close the cmp's eles list                          */

						sprintf(print_data, "],");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

						/* Open the cmp isos list                             */

						sprintf(print_data, "\"isos\" : [");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Loop through the cmp isos                          */

						ader_mat_cmp_iso = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_ISOS_PTR];

						while(ader_mat_cmp_iso > VALID_PTR)
						{

							/* Open the cmp iso dict                          */

							sprintf(print_data, "{");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							/* Get the ZAI                                    */

							ader_mat_iso = (long)RDB[ader_mat_cmp_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

							mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

							nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

							/* Enter the iso information                      */

							sprintf(print_data, "\"ZAI\" : %ld,",
									            (long)RDB[nuc + NUCLIDE_ZAI]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"ele_frac\" : %0.8f,",
									            RDB[ader_mat_cmp_iso + ADER_MAT_GRP_ISO_ELE_FRAC]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "\"grp_frac\" : %0.8f",
									            RDB[ader_mat_cmp_iso + ADER_MAT_GRP_ISO_FRAC]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							/* Close the cmp iso dict                         */

							if(NextItem(ader_mat_cmp_iso) > VALID_PTR)
							{

								sprintf(print_data, "},");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}
							else
							{

								sprintf(print_data, "}");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}

							ader_mat_cmp_iso = NextItem(ader_mat_cmp_iso);

						}

						/* Close the cmp's isos list                          */

						sprintf(print_data, "]");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

						/* Close the cmp group's dict                         */

						if(NextItem(ader_mat_cmp) > VALID_PTR)
						{

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}
						else
						{

							sprintf(print_data, "}");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}


						ader_mat_cmp = NextItem(ader_mat_cmp);

					}

					/* Close the cmp groups dict                              */

					sprintf(print_data, "},");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level--;

					/* Open the streams dict                                  */

					sprintf(print_data, "\"streams\" : {");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					tab_level++;

					/* Now loop through the material streams but use the      */
					/* ADEROutputMaterialCompMatrixStreamData function to do  */
					/* it so that it can tunnel into summation streams        */

					ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

					ADEROutputMaterialCompMatrixStreamData(ader_mat_cluster_mem,
							                               ader_mat_cluster_mem_stream,
														   0, fp, 0, tab_level,
													       tab_length);

					ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

					ADEROutputMaterialCompMatrixStreamData(ader_mat_cluster_mem,
							                               ader_mat_cluster_mem_stream,
														   0, fp, 1, tab_level,
													       tab_length);

					ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

					ADEROutputMaterialCompMatrixStreamData(ader_mat_cluster_mem,
							                               ader_mat_cluster_mem_stream,
														   0, fp, 2, tab_level,
													       tab_length);

					ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

					ADEROutputMaterialCompMatrixStreamData(ader_mat_cluster_mem,
							                               ader_mat_cluster_mem_stream,
														   0, fp, 3, tab_level,
													       tab_length);

					/* Close the streams dict                                 */

					if((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_OXI_PTR] < VALID_PTR &&
					   (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRESERVES_PTR] < VALID_PTR)
					{

						sprintf(print_data, "}");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

					}
					else
					{

						sprintf(print_data, "},");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

					}

					/* Get the oxidation data                                 */

					ader_mat_cluster_mem_oxi = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_OXI_PTR];

					/* If the oxidation data exists...     					  */

					if(ader_mat_cluster_mem_oxi > VALID_PTR)
					{

						/* Open the oxidation info dict                       */

						sprintf(print_data, "\"oxi\" : {");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Get the oxidation data                             */

						ader_mat_cluster_mem_oxi = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_OXI_PTR];

						/* Provide the oxidation row data                     */

						sprintf(print_data, "\"row_id\" : %ld,", (long)RDB[ader_mat_cluster_mem_oxi + ADER_MAT_OXI_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Give min and max oxi values                        */

						sprintf(print_data, "\"oxi_max\": %0.8f,", RDB[ader_mat_cluster_mem_oxi + ADER_MAT_OXI_MAX]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						sprintf(print_data, "\"oxi_min\": %0.8f,", RDB[ader_mat_cluster_mem_oxi + ADER_MAT_OXI_MIN]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Open the elements oxidation values dictionary      */

						sprintf(print_data, "\"oxi_states\" : {");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Get the ader oxidation table, it has the element   */
						/* values                                             */

						ader_oxi = (long)RDB[ader_mat_cluster_mem_oxi + ADER_MAT_OXI_TBL_PTR];

						ader_oxi_ele = (long)RDB[ader_oxi + ADER_OXI_ELES_PTR];

						while(ader_oxi_ele > VALID_PTR)
						{

							/* Open the elements oxi data list                */

							sprintf(print_data, "\"%ld\" : [", (long)RDB[ader_oxi_ele + ADER_OXI_ELE_Z]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level++;

							/* Populate the list                              */

							sprintf(print_data, "%0.8f,", RDB[ader_oxi_ele + ADER_OXI_ELE_VAL]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							sprintf(print_data, "%0.8f", RDB[ader_oxi_ele + ADER_OXI_ELE_WEIGHT]);

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							/* Close the element oxi data list                */

							if(NextItem(ader_oxi_ele) > VALID_PTR)
							{

								sprintf(print_data, "],");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}
							else
							{

								sprintf(print_data, "]");

								ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

								tab_level--;

							}

							ader_oxi_ele = NextItem(ader_oxi_ele);

						}

						/* Close the elements oxidation values dictionary     */

						sprintf(print_data, "}");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

						/* Close the oxidation info dict                      */

						if((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRESERVES_PTR] < VALID_PTR)
						{

							sprintf(print_data, "}");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}
						else
						{

							sprintf(print_data, "},");

							ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

							tab_level--;

						}

					}

					/* Get the preservation data                              */

					ader_mat_cluster_mem_pres = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRESERVES_PTR];

					/* If there is preservation data                          */

					if(ader_mat_cluster_mem_pres > VALID_PTR)
					{

						/* Open the preservation info dict                    */

						sprintf(print_data, "\"pres\" : {");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level++;

						/* Provide preservation data                          */

						sprintf(print_data, "\"row_id\" : %ld," , (long)RDB[ader_mat_cluster_mem_pres + ADER_MAT_PRESERVE_ROW_ID]);

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						sprintf(print_data, "\"type\" : \"%s\"" , GetText(ader_mat_cluster_mem_pres + ADER_MAT_PRESERVE_ENT));

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						/* Close the preservation info dict                   */

						sprintf(print_data, "}");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

						tab_level--;

					}

					/* Close the member info dict                             */

					if(NextItem(ader_mat_cluster_mem_ent) > VALID_PTR)
					{

						sprintf(print_data, "},");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}
					else
					{

						/* Final list items can not have a trailing ","       */

						sprintf(print_data, "}");

						ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

					}

					tab_level--;

					ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

				}

				/* Close the members info dict                                */

				sprintf(print_data, "}");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

				/* This search is needed to know if a comma is needed or not  */

				another_cluster = 0;

				search_mat = NextItem(mat);

				while(search_mat > VALID_PTR)
				{

					search_ader_mat_data = (long)RDB[search_mat + MATERIAL_ADER_DATA];

					if(search_ader_mat_data > VALID_PTR)
					{

						if((long)RDB[search_ader_mat_data + ADER_MAT_CLUSTER_PARENT_PTR] == search_mat)
						{

							another_cluster = 1;

							break;

						}

					}

					search_mat = NextItem(search_mat);

				}

				if(another_cluster > 0)
				{

					sprintf(print_data, "},");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				}
				else
				{

					sprintf(print_data, "}");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				}

				tab_level--;

			}

		}

		mat = NextItem(mat);

	}

	/* Close the clusters dict                                                */

	sprintf(print_data, "},");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);\

	tab_level--;

	/* Set the number of clusters                                             */

	sprintf(print_data, "\"num_clusters\" : %ld", num_clusters);

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);


	/* Print the dictionary close for the original cluster dictionary         */

	sprintf(print_data, "}");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

	tab_level--;

	/* Print the list close for the json file                                 */

	sprintf(print_data, "]");

	ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

	tab_level--;

	/* Close the file                                                         */

	fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoutputmaterialcompmatrixstreamdata.c       */
/*                                                                           */
/* Created:       2017/02/07 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Outputs stream data to the material comp matrix json file    */
/*              Recursively calls itself on sum streams                      */
/*                                                                           */
/* Comments:This function is called from ADEROutputMaterialCompMatrixData    */
/*                                       ADEROutputMaterialCompMatrixStreamData */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADEROutputMaterialCompMatrixStreamData:"

long ADEROutputMaterialCompMatrixStreamData(long ader_mat_cluster_mem,
											long ader_mat_stream,
											long ader_mat_stream_sum_stream_check,
											FILE* fp, long level, long tab_level,
											long tab_length)
{

	char print_buffer[256], print_data[256];
	long ader_mat_cluster_mem_ader_data = 0, ader_mat_iso = 0, ader_mat_search_stream = 0;
	long ader_mat_stream_ele = 0, ader_mat_stream_iso = 0, ader_mat_stream_shadow_stream = 0;
	long ader_mat_stream_shadow_stream_mat = 0, ader_mat_stream_sum_stream = 0;
	long ader_mat_stream_sum_stream_ent = 0, another_stream = 0, found = 0, mat_iso = 0, name_counter = 0;
	long nuc = 0;

	ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

	while(ader_mat_stream > VALID_PTR)
	{

		/* We only check for name duplicates on primary streams               */

		if(ader_mat_stream_sum_stream_check < 1)
		{

			/* Save the name to print buffer                                  */

			strcpy(print_buffer,
				   GetText(ader_mat_stream + ADER_MAT_STREAM_ID));

			/* Now determine if this stream has a unique name If not, modify  */
			/* the name for testing                                           */

			name_counter = 0;

			found = 0;

			ader_mat_search_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

			while(ader_mat_search_stream > VALID_PTR)
			{

				if(ader_mat_stream == ader_mat_search_stream)
				{

					/* There is no need to count past the stream in question  */

					found = 1;

					break;

				}

				if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(ader_mat_search_stream + ADER_MAT_STREAM_ID)) == 0)
				{

					name_counter++;

				}

				ader_mat_search_stream = NextItem(ader_mat_search_stream);

			}

			ader_mat_search_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

			while((ader_mat_search_stream > VALID_PTR) && (found < 1))
			{

				if(ader_mat_stream == ader_mat_search_stream)
				{

					/* There is no need to count past the stream in question  */

					found = 1;

					break;

				}

				if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(ader_mat_search_stream + ADER_MAT_STREAM_ID)) == 0)
				{

					name_counter++;

				}

				ader_mat_search_stream = NextItem(ader_mat_search_stream);

			}

			ader_mat_search_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

			while((ader_mat_search_stream > VALID_PTR) && (found < 1))
			{

				if(ader_mat_stream == ader_mat_search_stream)
				{

					/* There is no need to count past the stream in question  */

					found = 1;

					break;

				}

				if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(ader_mat_search_stream + ADER_MAT_STREAM_ID)) == 0)
				{

					name_counter++;

				}

				ader_mat_search_stream = NextItem(ader_mat_search_stream);

			}

			ader_mat_search_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

			while((ader_mat_search_stream > VALID_PTR) && (found < 1))
			{

				if(ader_mat_stream == ader_mat_search_stream)
				{

					/* There is no need to count past the stream in question  */

					found = 1;

					break;

				}

				if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
						  GetText(ader_mat_search_stream + ADER_MAT_STREAM_ID)) == 0)
				{

					name_counter++;

				}

				ader_mat_search_stream = NextItem(ader_mat_search_stream);

			}

			if(name_counter > 0)
			{

				sprintf(print_data, "_%ld", name_counter);

				strcat(print_buffer, print_data);

			}

		}
		else
		{

			strcpy(print_buffer, GetText(ader_mat_stream + ADER_MAT_STREAM_ID));

		}

		/* Open the stream's dict                                             */

		sprintf(print_data, "\"%s\" : {", print_buffer);

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level++;

		/* Provide basic stream information                                   */

		sprintf(print_data, "\"burn_idx\" : %ld,",
				            (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]);

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"col_id\" : %ld,",
				            (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]);

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"dest\" : \"%s\",",
				            GetText(ader_mat_stream + ADER_MAT_STREAM_DEST));

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"form\" : \"%s\",",
				            GetText(ader_mat_stream + ADER_MAT_STREAM_FORM));

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"src\" : \"%s\",",
				            GetText(ader_mat_stream + ADER_MAT_STREAM_SRC));

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"type\" : \"%s\",",
				            GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE));

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		sprintf(print_data, "\"sum_row_id\" : %ld,",
				            (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID]);

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		/* Open the shadow stream dict                                        */

		sprintf(print_data, "\"shadow\" : {");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level++;

		/* Get the shadow stream                                              */

		ader_mat_stream_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

		if(ader_mat_stream_shadow_stream != 0)
		{

			/* Source side streams, those leaving a material                  */
			/* have negative pointers to the destination                      */
			/* stream                                                         */

			if(ader_mat_stream_shadow_stream < 0)
			{

				ader_mat_stream_shadow_stream = ader_mat_stream_shadow_stream * -1;

				/* Provide the shadow information                             */

				sprintf(print_data, "\"dest_stream\" : \"%s\",",
						            GetText(ader_mat_stream_shadow_stream + ADER_MAT_STREAM_ID));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				ader_mat_stream_shadow_stream_mat = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

				sprintf(print_data, "\"dest_mat\" : \"%s\",",
						            GetText(ader_mat_stream_shadow_stream_mat + MATERIAL_PTR_NAME));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"src_stream\" : \"%s\",",
						            GetText(ader_mat_stream + ADER_MAT_STREAM_ID));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"src_mat\" : \"%s\"",
						            GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			}
			else
			{

				/* Provide the shadow information                             */

				sprintf(print_data, "\"src_stream\" : \"%s\",",
						            GetText(ader_mat_stream_shadow_stream + ADER_MAT_STREAM_ID));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				ader_mat_stream_shadow_stream_mat = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

				sprintf(print_data, "\"src_mat\" : \"%s\",",
						            GetText(ader_mat_stream_shadow_stream_mat + MATERIAL_PTR_NAME));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"dest_stream\" : \"%s\",",
						            GetText(ader_mat_stream + ADER_MAT_STREAM_ID));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"dest_mat\" : \"%s\"",
						            GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			}

		}
		else
		{

			/* There is no shadow stream, set a null dict                     */

			sprintf(print_data, "\"NULL\" : \"NULL\"");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		}

		/* Close the shadow stream dict                                       */

		sprintf(print_data, "},");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level--;

		/* Deal with summation streams                                        */

		/* Open the sum streams list                                          */

		sprintf(print_data, "\"sum_streams\" : [");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level++;

		ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

		if(ader_mat_stream_sum_stream_ent > VALID_PTR)
		{

			while(ader_mat_stream_sum_stream_ent > VALID_PTR)
			{

				/* Open the sum stream dict                                   */

				sprintf(print_data, "{");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level++;

				/* Provide basic sum stream information                       */

				sprintf(print_data, "\"name\": \"%s\",",
						            GetText(ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID));

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				sprintf(print_data, "\"weight\": %.16f,",
						            RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_WEIGHT]);

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				/* Now, pass the actual sum stream to this function so that   */
				/* all of its info may be input                               */

				ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

				ADEROutputMaterialCompMatrixStreamData(ader_mat_cluster_mem,
						                               ader_mat_stream_sum_stream,
													   1, fp, level, tab_level,
												       tab_length);

				/* Close the sum stream dict                                  */

				if(NextItem(ader_mat_stream_sum_stream_ent) > VALID_PTR)
				{

					sprintf(print_data, "},");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				}
				else
				{

					sprintf(print_data, "}");

					ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				}

				tab_level--;

				ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

			}

		}
		else
		{

			/* Provide a null list entry for no sum streams                   */

			sprintf(print_data, "\"NULL\"");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		}

		/* Close the sum streams list                                         */

		sprintf(print_data, "],");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level--;

		/* Open the stream eles list                                          */

		sprintf(print_data, "\"eles\" : [");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level++;

		/* Loop through the stream eles                                       */

		ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

		while(ader_mat_stream_ele > VALID_PTR)
		{

			/* Open the stream ele dict                                      */

			sprintf(print_data, "{");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			tab_level++;

			/* Enter the ele information                                      */

			sprintf(print_data, "\"%ld\" : %.16f",
					            (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z],
								RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC]);

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			/* Close the stream ele dict                                      */

			if(NextItem(ader_mat_stream_ele) > VALID_PTR)
			{

				sprintf(print_data, "},");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

			}
			else
			{

				sprintf(print_data, "}");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

			}

			ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

		}

		/* Close the streams's eles list                                      */

		sprintf(print_data, "],");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level--;

		/* Open the stream's isos list                                        */

		sprintf(print_data, "\"isos\" : [");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level++;

		/* Loop through the stream isos                                       */

		ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_iso > VALID_PTR)
		{

			/* Open the cmp iso dict                                          */

			sprintf(print_data, "{");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			tab_level++;

			/* Get the ZAI                                                    */

			ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

			mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

			nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

			/* Enter the iso information                                      */

			sprintf(print_data, "\"ZAI\" : %ld,",
					            (long)RDB[nuc + NUCLIDE_ZAI]);

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			sprintf(print_data, "\"ele_frac\" : %0.8f,",
					            RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC]);

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			sprintf(print_data, "\"grp_frac\" : %0.8f",
					            RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC]);

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			/* Close the stream iso dict                                      */

			if(NextItem(ader_mat_stream_iso) > VALID_PTR)
			{

				sprintf(print_data, "},");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

			}
			else
			{

				sprintf(print_data, "}");

				ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

				tab_level--;

			}

			ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

		}

		/* Close the stream's isos list                                       */

		sprintf(print_data, "]");

		ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

		tab_level--;

		/* To close the stream dict we need to know if there are any more of  */
		/* this type of stream or of the streams to be processed. Because feed*/
		/* streams are the first to be processed they do not hae a stream     */
		/* check they only need the "current stream type" check               */
		/* Additionally we need to know if there are any more sum streams if  */
		/* this function was called for sum streams, as such, it is the first */
		/* check                                                              */

		another_stream = 0;

		if(ader_mat_stream_sum_stream_check > 0)
		{

			another_stream = 0;

		}
		else if(NextItem(ader_mat_stream) > VALID_PTR)
		{

			another_stream = 1;

		}
		else if(((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR] > VALID_PTR) &&
				level < 1)
		{

			another_stream = 1;

		}
		else if(((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR] > VALID_PTR) &&
				level < 2)
		{

			another_stream = 1;

		}
		else if(((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR] > VALID_PTR) &&
				level < 3)
		{

			another_stream = 1;

		}

		if(another_stream > 0)
		{

			sprintf(print_data, "},");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			tab_level--;

		}
		else
		{

			sprintf(print_data, "}");

			ADERPrintIndentedOutput(fp, print_data, tab_length, tab_level);

			tab_level--;

		}

		ader_mat_stream = NextItem(ader_mat_stream);

	}

    /* Return the value                                                       */

    return(tab_level);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderparseclpsolution.c                         */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to assign the Clp solution to the ADER       */
/*              entities that need them                                      */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                       TESTADERParseClpSolution            */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERParseClpSolution:"

void ADERParseClpSolution(long adj, long i, long mat, long step,
		                  double *solution)
{

	long ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0, cluster_ader_data = 0;
	long cluster_mem_cmp = 0, cluster_mem_cmp_burn_step = 0, cluster_mem_stream = 0;
	long j = 0, mat_ader_data = 0;

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Loop through ader mat cluster members                                 */

	ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_ent > VALID_PTR)
	{

		/* Get the actual material index                                      */

		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

		cluster_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

		/* Loop through the cluster members cmp groups                        */

		cluster_mem_cmp = (long)RDB[cluster_ader_data + ADER_MAT_CMPS_PTR];

		while(cluster_mem_cmp > VALID_PTR)
		{

			/* Set the cmp's calculated fraction                              */

			WDB[cluster_mem_cmp + ADER_MAT_CMP_CUR_AMT] = solution[(long)RDB[cluster_mem_cmp + ADER_MAT_CMP_COL_ID]];

			/* Loop into the proper burn step and store this value there too  */

			cluster_mem_cmp_burn_step = (long)RDB[cluster_mem_cmp + ADER_MAT_CMP_BURN_STEPS_PTR];

			for(j = 0; j < (long)RDB[DATA_BURN_STEP]; j++)
			{

				cluster_mem_cmp_burn_step = NextItem(cluster_mem_cmp_burn_step);

			}

			WDB[cluster_mem_cmp_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = solution[(long)RDB[cluster_mem_cmp + ADER_MAT_CMP_COL_ID]];

			cluster_mem_cmp = NextItem(cluster_mem_cmp);

		}

		/* Loop through the cluster's streams                                 */

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_FEED_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			ADERParseStreamClpSolution(cluster_mem_stream, adj, solution);

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REAC_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			ADERParseStreamClpSolution(cluster_mem_stream, adj, solution);

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			ADERParseStreamClpSolution(cluster_mem_stream, adj, solution);

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		cluster_mem_stream = (long)RDB[cluster_ader_data + ADER_MAT_REMV_STREAMS_PTR];

		while(cluster_mem_stream > VALID_PTR)
		{

			ADERParseStreamClpSolution(cluster_mem_stream, adj, solution);

			cluster_mem_stream = NextItem(cluster_mem_stream);

		}

		ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderparsestreamclpsolution.c                   */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to assign the Clp solution to ADER streams   */
/*                                                                           */
/* Comments:This function is called from ADERParseClpSolution                */
/*                                       ADERParseStreamClpSolution          */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERParseStreamClpSolution:"

void ADERParseStreamClpSolution(long ader_mat_stream, long adj,
		                        double *solution)
{

	double adens_corr_factor = 0.0, density = 0.0;
	long ader_mat_stream_burn_step = 0, ader_mat_shadow_stream = 0;
	long ader_mat_stream_sum = 0, ader_mat_stream_sum_ent = 0, host_mat = 0;
	long i = 0, src_mat = 0;

	host_mat = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_MAT_PTR];

	/* If this stream is a destination end of a shadow stream, it will need   */
	/* a correction factor                                                    */

	ader_mat_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

	if(ader_mat_shadow_stream > VALID_PTR)
	{

		src_mat = (long)RDB[ader_mat_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

		adens_corr_factor = (RDB[src_mat + MATERIAL_VOLUME] /
				             RDB[host_mat + MATERIAL_VOLUME]);

	}
	else
	{

		adens_corr_factor = 1.0;

	}

	/* Rem streams are not given their current amount, that happens earlier   */

	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
	{

		if(adj == 0)
		{

			WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = solution[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]] * adens_corr_factor;

		}
		else
		{

			WDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] = solution[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]] * adens_corr_factor;

		}

	}

	/* Store the amount in the burn step tracker, but not for prop streams    */

	if(strcmp("prop", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)
	{

		ader_mat_stream_burn_step = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_STEPS_PTR];

		for(i = 0; i < (long)RDB[DATA_BURN_STEP]; i++)
		{

			ader_mat_stream_burn_step = NextItem(ader_mat_stream_burn_step);

		}

		/* First, we need the material density for the stream        */
		/* If there is no shadow, or this is the source side of a shadow      */
		/* stream pair, then the stream's host mat has the density information*/

		if(ader_mat_shadow_stream < VALID_PTR)
		{

			density = RDB[host_mat + MATERIAL_ADENS];

		}
		else
		{

			density = RDB[src_mat + MATERIAL_ADENS] *
					  (RDB[src_mat + MATERIAL_VOLUME] /
		               RDB[host_mat + MATERIAL_VOLUME]);

		}

		if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) != 0)
		{

			if(adj == 0)
			{

				if(strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) == 0)
				{

					WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = solution[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]] * density +
							                                                        RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];
				}
				else
				{

					WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = solution[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]] * density;

				}

			}
			else
			{

				WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = solution[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID]] * density +
						                                                        RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];

			}

		}
		else
		{

			WDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] = RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] * density;

		}

	}

	/* If the stream has summation streams, loop through those                */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	while(ader_mat_stream_sum_ent > VALID_PTR)
	{

		ader_mat_stream_sum = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

		ADERParseStreamClpSolution(ader_mat_stream_sum, adj, solution);

		ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintcrosssections.c                       */
/*                                                                           */
/* Created:       2016/04/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Prints relevant cross section and isotopic data to file      */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintCrossSections:"

void ADERPrintCrossSections(long dep, long i, long mat, long step, double t1, double t2)
{

    char file_out[256];
    double ader_k_gain = 0.0, ader_k_loss = 0.0, ader_k_value = 0.0;
    double leakage = 0.0, non_leakage = 0.0;
	long ader_mat_iso = 0, mat_ader_data = 0;
    FILE *fp = NULL;

	/* If this material is not under reactivity control, exit                 */

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	if(mat_ader_data > VALID_PTR)
	{

		if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
		{

			return;

		}

	}

    /* Go ahead and create the file name                                      */

    sprintf(file_out, "%s_XS_step_%ld_iter_%ld.txt",
    		GetText(mat + MATERIAL_PTR_NAME), step, i);

	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open material cross section output file.\n");

	}

    fprintf(fp, "************************************ Begin *************************************\n");
    fprintf(fp, "\n");
    fprintf(fp, "Material: %s \n", GetText(mat + MATERIAL_PTR_NAME));
    fprintf(fp, "Density: %0.12E \n", RDB[mat + MATERIAL_ADENS]);
    fprintf(fp, "Burnup: %0.12E \n", RDB[mat + MATERIAL_BURNUP]);
    fprintf(fp, "BOS Leakage: %0.12E \n", RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS]);

    /* Get the calculated leakage                                             */

    leakage = ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
                               RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
			                   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
			                   t1, t2, dep);

    fprintf(fp, "Avg Leakage: %0.12E \n", leakage);

    /* Get the non-leakage                                                    */

    non_leakage = 1.0 - leakage;

    fprintf(fp, "Avg non-leakage: %0.12E \n", non_leakage);

    fprintf(fp, "\n");


	/* loop through the isotopes to get their reacitivty information      +	    */

	ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

	while(ader_mat_iso > VALID_PTR)
	{

		fprintf(fp, "ZAI: %ld \n", (long)RDB[(long)RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_PTR_NUCLIDE] + NUCLIDE_ZAI]);

		fprintf(fp, "    adens:     %0.12E \n", RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "    adens-bos: %0.12E \n", RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS_BOS]);

		fprintf(fp, "    abs-bos:   %0.12E \n", RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS]);

		fprintf(fp, "    abs-avg:   %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    fis-avg: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    nu-avg: %0.12E \n", (ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
                RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
                RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
                t1, t2, dep) / ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep)));

		fprintf(fp, "    nufis-bos: %0.12E \n", RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS]);

		fprintf(fp, "    nufis-avg: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    gain-cont: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep) *
				                                RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "    loss-cont: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
				                                                 t1, t2, dep) *
				                                RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "\n");

		/* Include the isotopes contribution to k                             */

		ader_k_gain += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
                                        t1, t2, dep) * RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS];

		ader_k_loss += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
                                        t1, t2, dep) * RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS];

		ader_mat_iso = NextItem(ader_mat_iso);

	}

	ader_k_value = (ader_k_gain / ader_k_loss) * non_leakage;

	fprintf(fp, "ader_k_value: %0.12E \n", ader_k_value);

	fprintf(fp, "serpent_k_value: %0.12E \n", Mean((long)RDB[RES_IMP_KEFF], 0));

	fprintf(fp, "percent_diff: %0.3f \n", 100.0 * ((ader_k_value - Mean((long)RDB[RES_IMP_KEFF], 0)) / Mean((long)RDB[RES_IMP_KEFF], 0)));

    fprintf(fp, "********************************************************************************\n");

    fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintcrosssections.c                       */
/*                                                                           */
/* Created:       2016/04/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Prints relevant cross section and isotopic data to file      */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintFinalStepCrossSections:"

void ADERPrintFinalStepCrossSections(long dep, long mat, long step, double t1, double t2)
{

    char file_out[256];
    double ader_k_gain = 0.0, ader_k_loss = 0.0, ader_k_value = 0.0;
    double leakage = 0.0, non_leakage = 0.0;
	long ader_mat_iso = 0, mat_ader_data = 0;
    FILE *fp = NULL;

	/* If this material is not under reactivity control, exit                 */

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	if(mat_ader_data > VALID_PTR)
	{

		if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
		{

			return;

		}

	}

    /* Go ahead and create the file name                                      */

    sprintf(file_out, "%s_XS_End_of_step_%ld.txt",
    		GetText(mat + MATERIAL_PTR_NAME), step);

	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open material cross section output file.\n");

	}

    fprintf(fp, "************************************ Begin *************************************\n");
    fprintf(fp, "\n");
    fprintf(fp, "Material: %s \n", GetText(mat + MATERIAL_PTR_NAME));
    fprintf(fp, "Density: %0.12E \n", RDB[mat + MATERIAL_ADENS]);
    fprintf(fp, "Burnup: %0.12E \n", RDB[mat + MATERIAL_BURNUP]);
    fprintf(fp, "BOS Leakage: %0.12E \n", RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS]);

    /* Get the calculated leakage                                             */

    leakage = ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
                               RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
			                   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
			                   t1, t2, dep);

    fprintf(fp, "Avg Leakage: %0.12E \n", leakage);

    /* Get the non-leakage                                                    */

    non_leakage = 1.0 - leakage;

    fprintf(fp, "Avg non-leakage: %0.12E \n", non_leakage);

    fprintf(fp, "\n");


	/* loop through the isotopes to get their reacitivty information      +	    */

	ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

	while(ader_mat_iso > VALID_PTR)
	{

		fprintf(fp, "ZAI: %ld \n", (long)RDB[(long)RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_PTR_NUCLIDE] + NUCLIDE_ZAI]);

		fprintf(fp, "    adens:     %0.12E \n", RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "    adens-bos: %0.12E \n", RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS_BOS]);

		fprintf(fp, "    abs-bos:   %0.12E \n", RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS]);

		fprintf(fp, "    abs-avg:   %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    fis-avg: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    nu-avg: %0.12E \n", (ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
                RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
                RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
                t1, t2, dep) / ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep)));

		fprintf(fp, "    nufis-bos: %0.12E \n", RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS]);

		fprintf(fp, "    nufis-avg: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep));

		fprintf(fp, "    gain-cont: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
				                                                 t1, t2, dep) *
				                                RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "    loss-cont: %0.12E \n", ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
		                                                         RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
				                                                 t1, t2, dep) *
				                                RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS]);

		fprintf(fp, "\n");

		/* Include the isotopes contribution to k                             */

		ader_k_gain += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
                                        t1, t2, dep) * RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS];

		ader_k_loss += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
                                        RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
                                        t1, t2, dep) * RDB[(long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR] + COMPOSITION_ADENS];

		ader_mat_iso = NextItem(ader_mat_iso);

	}

	ader_k_value = (ader_k_gain / ader_k_loss) * non_leakage;

	fprintf(fp, "ader_k_value: %0.12E \n", ader_k_value);

	fprintf(fp, "serpent_k_value: %0.12E \n", Mean((long)RDB[RES_IMP_KEFF], 0));

	fprintf(fp, "percent_diff: %0.3f \n", 100.0 * ((ader_k_value - Mean((long)RDB[RES_IMP_KEFF], 0)) / Mean((long)RDB[RES_IMP_KEFF], 0)));

    fprintf(fp, "********************************************************************************\n");

    fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintindentedoutput.c                      */
/*                                                                           */
/* Created:       2017/02/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Simple wrapper to reduce instruction set for indented output */
/*                                                                           */
/* Comments:This function is called from ADEROutputMaterialCompMatrixAsJson  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintIndentedOutput:"

void ADERPrintIndentedOutput(FILE* fp, char* print_data,long tab_length,
		                     long tab_level)
{

	fprintf(fp, "%*s%s\n", (int)(tab_level * tab_length), "", print_data);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintlistshierarchy.c                      */
/*                                                                           */
/* Created:       2016/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Provides information regarding ADER memory lists for debug   */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintListsHierarchy:"

void ADERPrintListsHierarchy()
{

    static char *test_file_out = "ADER_Memory_Lists.test";
    char print_data[256], file_out[256];
    char *mat_name = NULL;
    FILE *fp = NULL, *fp1 = NULL;
    double filled_entries = 0, percent_empty = 0, total_entries = 0;
    double **dump_vector = NULL;
    long ader_cluster = 0, ader_cluster_ent = 0, ader_data = 0, ader_mat_cluster_mem = 0;
    long ader_mat_cluster_mem_ader_data = 0, ader_mat_cluster_mem_cmp = 0;
    long ader_mat_cluster_mem_cmp_rto = 0, ader_mat_cluster_mem_ele = 0;
    long ader_mat_cluster_mem_ent = 0, ader_mat_cluster_mem_iso = 0;
    long ader_mat_cluster_mem_pres = 0;
    long ader_mat_cluster_mem_stream = 0, ader_mat_cmp = 0, ader_mat_cmp_rto = 0, ader_mat_cmp_rto_grp2 = 0;
	long ader_mat_data = 0, ader_mat_ele = 0, ader_mat_matrix_data = 0, ader_mat_matrix_col = 0;
	long ader_mat_matrix_col_row = 0, ader_mat_iso = 0, ader_mat_pres = 0, ader_mat_stream = 0;
	long ader_mat_stream_shadow = 0, ader_mat_stream_sum_ent = 0, found = 0, mat = 0, mat_iso = 0;
	long nuc, num_cmp_rows = 0, num_eles = 0, num_ents = 0, num_isos = 0, num_oxi = 0, num_pres = 0;
	long num_reac = 0, num_stream_cols = 0, num_stream_rows = 0;

    if(1 < 2)
    {

        if ((fp = fopen(test_file_out, "w")) == NULL)
        {
            Die(FUNCTION_NAME, "Unable to open ADER memory file for writing");
        }

        fprintf(fp, "************************************ Begin *************************************\n");
        fprintf(fp, "\n");
        fprintf(fp, "ADER Memory Lists\n");
        fprintf(fp, "\n");
        fprintf(fp, "********************************************************************************\n");
        fprintf(fp, "Begin Materials:\n\n");

        /* Loop through materials, print their name and RDB index             */

        mat = (long)RDB[DATA_PTR_M0];

        while(mat > VALID_PTR)
        {

        	sprintf(print_data, ", %ld\n\n", mat);

        	fprintf(fp, "%s", GetText(mat + MATERIAL_PTR_NAME));

        	fprintf(fp, "%s", print_data);

        	mat = NextItem(mat);

        }

        fprintf(fp, "End materials:\n\n");

        /* Loop through ADER clusters, print the parent & all cluster members */

        ader_data = (long)RDB[DATA_PTR_ADER];

        ader_cluster = (long)RDB[ader_data + ADER_CLUSTERS_PTR];

        fprintf(fp, "Begin ADER Clusters:\n\n");

        while(ader_cluster > VALID_PTR)
        {

        	sprintf(print_data, "Cluster parent: %s\n",
        			GetText(ader_cluster + ADER_CLUSTER_PARENT_ID));

        	fprintf(fp, "%s", print_data);

        	sprintf(print_data, "    Cluster members:\n");

        	fprintf(fp, "%s", print_data);

        	ader_cluster_ent = (long)RDB[ader_cluster + ADER_CLUSTER_ENT_PTR];

        	while(ader_cluster_ent > VALID_PTR)
        	{

            	sprintf(print_data, "    %s\n",
            			GetText(ader_cluster_ent + ADER_CLUSTER_ENT_ID));

            	fprintf(fp, "%s", print_data);

        		ader_cluster_ent = NextItem(ader_cluster_ent);

        	}

        	sprintf(print_data, "\n");

        	fprintf(fp, "%s", print_data);

        	ader_cluster = NextItem(ader_cluster);

        }

        fprintf(fp, "End ADER Clusters:\n\n");

        /* Print out the material ader clusters, parents and members          */

        fprintf(fp, "Begin Material Clusters:\n\n");

        mat = (long)RDB[DATA_PTR_M0];

        while(mat > VALID_PTR)
        {

        	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

        	if(ader_mat_data > VALID_PTR)
        	{

            	fprintf(fp, "%s\n", GetText(mat + MATERIAL_PTR_NAME));

            	sprintf(print_data, "Cluster parent: %ld\n",
            			(long)RDB[ader_mat_data + ADER_MAT_CLUSTER_PARENT_PTR]);

            	fprintf(fp, "%s", print_data);

            	fprintf(fp, "    Cluster Members:\n");

            	ader_mat_cluster_mem = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

            	while(ader_mat_cluster_mem > VALID_PTR)
            	{

                	sprintf(print_data, "    %s, %ld, cluster_mem: %ld\n",
                			GetText((long)RDB[ader_mat_cluster_mem + ADER_MAT_CLUSTER_MEM_PTR] + MATERIAL_PTR_NAME),
                			(long)RDB[ader_mat_cluster_mem + ADER_MAT_CLUSTER_MEM_PTR],
							ader_mat_cluster_mem);

                	fprintf(fp, "%s", print_data);

            		ader_mat_cluster_mem = NextItem(ader_mat_cluster_mem);

            	}

            	fprintf(fp, "\n");

        	}

        	mat = NextItem(mat);

        }

        fprintf(fp, "End Materials Clusters:\n\n");

        /* Print out material ader information                                */

        fprintf(fp, "Begin Materials:\n\n");

        mat = (long)RDB[DATA_PTR_M0];

        while(mat > VALID_PTR)
        {

        	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

        	if(ader_mat_data < VALID_PTR)
        	{

        		mat = NextItem(mat);

        		continue;

        	}

        	mat_name = GetText(mat + MATERIAL_PTR_NAME);

        	/* Go ahead and output the isotope data lists for this material   */

            sprintf(file_out, "%s_Isotopes_WDB_Address_List.test",
            		mat_name);

        	if ((fp1 = fopen(file_out, "w")) == NULL)
        	{

        		Die(FUNCTION_NAME, "Unable to open material isotope list file for writing");

        	}

        	fprintf(fp1, "Material %s Isotopes WDB Address List Key:\n\n", mat_name);

        	fprintf(fp1, "Material name, Isotope Zai\n");

        	fprintf(fp1, "    MATERIAL_COMPOSITION_PTR: WDB address for isotope\n");

        	fprintf(fp1, "    COMPOSITION_PTR_NUCLIDE: WDB address for nuclide\n");

        	fprintf(fp1, "    ADER_MAT_ISOS_PTR: WDB address for ader isotope\n");

        	fprintf(fp1, "    ADER_MAT_ISO_BURN_INDEX: Burnup matrix index\n");

        	fprintf(fp1, "    ADER_MAT_ISO_DEL_COL_ID: Optimization matrix del column index\n");

        	fprintf(fp1, "    ADER_MAT_ISO_FUT_COL_ID: Optimization matrix fut column index\n");

        	fprintf(fp1, "    ADER_MAT_ISO_BAL_ROW_ID: Optimization matrix bal row index\n");

        	fprintf(fp1, "    ADER_MAT_ISO_DEL_ROW_ID: Optimization matrix del row index\n");

        	fprintf(fp1, "    ADER_MAT_ISO_FUT_ROW_ID: Optimization matrix fut row index\n");

        	fprintf(fp1,"********************************************************************************\n");

        	/* Count the isos                                                 */

        	num_cmp_rows = 0;

        	num_stream_cols = 0;

        	num_stream_rows = 0;

        	num_isos = 0;

        	mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

        	while(mat_iso > VALID_PTR)
        	{

        		nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        		found = (long)RDB[nuc + NUCLIDE_ZAI];

        		ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

        		while(ader_mat_iso > VALID_PTR)
        		{

        			if(mat_iso == (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR])
        			{

        				found = -10000;

        				break;

        			}

        			ader_mat_iso = NextItem(ader_mat_iso);

        		}

            	fprintf(fp1, "%s, %ld\n", mat_name, (long)RDB[nuc + NUCLIDE_ZAI]);

            	fprintf(fp1, "    MATERIAL_COMPOSITION_PTR: %ld\n", mat_iso);

            	fprintf(fp1, "    COMPOSITION_PTR_NUCLIDE: %ld\n", nuc);

            	if(found == -10000)
            	{

                	fprintf(fp1, "    ADER_MAT_ISOS_PTR: %ld\n", ader_mat_iso);

                	fprintf(fp1, "    ADER_MAT_ISO_BURN_INDEX: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]);

                	fprintf(fp1, "    ADER_MAT_ISO_DEL_COL_ID: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_COL_ID]);

                	fprintf(fp1, "    ADER_MAT_ISO_FUT_COL_ID: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID]);

                	fprintf(fp1, "    ADER_MAT_ISO_BAL_ROW_ID: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID]);

                	fprintf(fp1, "    ADER_MAT_ISO_DEL_ROW_ID: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID]);

                	fprintf(fp1, "    ADER_MAT_ISO_FUT_ROW_ID: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_ROW_ID]);

            	}
            	else if( found == -1)
            	{

                	fprintf(fp1, "    ADER_MAT_ISOS_PTR: N/A\n");

                	fprintf(fp1, "    ADER_MAT_ISO_BURN_INDEX: %ld\n", (long)RDB[ader_mat_data + ADER_MAT_FAKE_ISO_BURN_INDEX]);

            	}
            	else
            	{

                	fprintf(fp1, "    ADER_MAT_ISOS_PTR: ERROR: NO ADER ISOTOPE\n");

            	}

            	fprintf(fp1, "\n");

        		num_isos++;

        		mat_iso = NextItem(mat_iso);

        	}

        	fclose(fp1);

        	if(ader_mat_data > VALID_PTR)
        	{

            	sprintf(print_data, ", %ld\n\n", mat);

            	fprintf(fp, "%s", GetText(mat + MATERIAL_PTR_NAME));

            	fprintf(fp, "%s", print_data);

            	fprintf(fp, "Isos: %ld\n\n", num_isos);

            	/* Loop through any cmp groups                                */

                fprintf(fp, "    Material cmp groups:\n\n");

            	ader_mat_cmp = (long)RDB[ader_mat_data + ADER_MAT_CMPS_PTR];

            	while(ader_mat_cmp > VALID_PTR)
            	{

            		num_cmp_rows++;

                	fprintf(fp, "    %s : %ld\n",
                			GetText(ader_mat_cmp + ADER_MAT_CMP_ID),
							ader_mat_cmp);

                    fprintf(fp, "        Cmp rtos:\n\n");

                    /* Loop through any rtos attached to this group           */

                    ader_mat_cmp_rto = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_RTOS_PTR];

                    while(ader_mat_cmp_rto > VALID_PTR)
                    {

                    	num_cmp_rows++;

                        fprintf(fp, "        Rto_WDB_Address: %ld\n",
                        		ader_mat_cmp_rto);

                    	ader_mat_cmp_rto_grp2 = (long)RDB[ ader_mat_cmp_rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

                        fprintf(fp, "        2nd_Cmp_Group: %s\n",
                        		GetText(ader_mat_cmp_rto_grp2 + ADER_MAT_CMP_ID));

                        fprintf(fp, "        2nd_WDB_Address: %ld\n",
                        		ader_mat_cmp_rto_grp2);

                        fprintf(fp, "        Max: %f\n",
                        		RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX]);

                        if(RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX] > 0.0)
                        {

                        	num_cmp_rows++;

                        }

                        fprintf(fp, "        Min: %f\n",
                        		RDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN]);

                        fprintf(fp, "\n");

                    	ader_mat_cmp_rto = NextItem(ader_mat_cmp_rto);

                    }

                    /* Report if group is a summation group                   */

                    if((long)RDB[ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR] > VALID_PTR)
                    {

                    	num_cmp_rows++;

                        fprintf(fp, "        Sum Grp\n");

                    }

            		ader_mat_cmp = NextItem(ader_mat_cmp);

            	}

            	/* Loop through material streams                              */

            	/* Open the stream isotopes file                              */

                sprintf(file_out, "%s_Stream_Isotopes_WDB_Address_List.test",
                		mat_name);

            	if ((fp1 = fopen(file_out, "w")) == NULL)
            	{

            		Die(FUNCTION_NAME, "Unable to open material isotope list file for writing");

            	}

            	fprintf(fp1, "Material %s Stream Isotopes WDB Address List Key:\n\n", mat_name);

            	fprintf(fp1, "Material name, Stream name, Stream source, stream destination, Isotope Zai\n");

            	fprintf(fp1, "    ADER_MAT_STREAM: WDB address for stream\n");

            	fprintf(fp1, "    ADER_MAT_STREAM_ISOS_PTR: WDB address for stream isotope\n");

            	fprintf(fp1, "    MATERIAL_COMPOSITION_PTR: WDB address for isotope\n");

            	fprintf(fp1, "    COMPOSITION_PTR_NUCLIDE: WDB address for nuclide\n");

            	fprintf(fp1, "    ADER_MAT_ISOS_PTR: WDB address for ader isotope\n");

            	fprintf(fp1, "    ADER_MAT_ISO_BURN_INDEX: Burnup matrix index\n");

            	fprintf(fp1,"********************************************************************************\n\n");

                fprintf(fp, "    Material streams:\n\n");

            	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_FEED_STREAMS_PTR];

            	while(ader_mat_stream > VALID_PTR)
            	{

            		ADERPrintMaterialStreamIsotopes(ader_mat_stream, fp1, mat);

            		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_stream, 0, 0);

					fprintf(fp, "    %s, %ld",
							GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
							ader_mat_stream);

            	    if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0))
            	    {

            	    	fprintf(fp, ", removal table");

            	    }

            	    if(((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] != 0))
            	    {

            	    	ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            	    	if(ader_mat_stream_shadow < 0)
            	    	{

            	    		ader_mat_stream_shadow = ader_mat_stream_shadow * -1;

            	    	}

            	    	fprintf(fp, ", shadow [ %s, %ld ]",
            	    			GetText(ader_mat_stream_shadow + ADER_MAT_STREAM_ID),
								ader_mat_stream_shadow);

            	    }

            	    fprintf(fp, "\n");

            	    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
            	    {

            	    	num_stream_rows++;

                	    fprintf(fp, "        Summation stream\n");

            	    }


            	    ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            	    ADERPrintSumStreams(ader_mat_stream_sum_ent, fp, 1);

            		ader_mat_stream = NextItem(ader_mat_stream);

            	}

            	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REAC_STREAMS_PTR];

            	while(ader_mat_stream > VALID_PTR)
            	{

            		ADERPrintMaterialStreamIsotopes(ader_mat_stream, fp1, mat);

            		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_stream, 0, 0);

					fprintf(fp, "    %s, %ld",
							GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
							ader_mat_stream);

            	    if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0))
            	    {

            	    	fprintf(fp, ", removal table");

            	    }

            	    if(((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] != 0))
            	    {

            	    	ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            	    	if(ader_mat_stream_shadow < 0)
            	    	{

            	    		ader_mat_stream_shadow = ader_mat_stream_shadow * -1;

            	    	}

            	    	fprintf(fp, ", shadow [ %s, %ld ]",
            	    			GetText(ader_mat_stream_shadow + ADER_MAT_STREAM_ID),
								ader_mat_stream_shadow);

            	    }

            	    fprintf(fp, "\n");

            	    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
            	    {

            	    	num_stream_rows++;

                	    fprintf(fp, "        Summation stream\n");

            	    }


            	    ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            	    ADERPrintSumStreams(ader_mat_stream_sum_ent, fp, 1);

            		ader_mat_stream = NextItem(ader_mat_stream);

            	}

            	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REDOX_STREAMS_PTR];

            	while(ader_mat_stream > VALID_PTR)
            	{

            		ADERPrintMaterialStreamIsotopes(ader_mat_stream, fp1, mat);

            		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_stream, 0, 0);

					fprintf(fp, "    %s, %ld",
							GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
							ader_mat_stream);

            	    if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0))
            	    {

            	    	fprintf(fp, ", removal table");

            	    }

            	    if(((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] != 0))
            	    {

            	    	ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            	    	if(ader_mat_stream_shadow < 0)
            	    	{

            	    		ader_mat_stream_shadow = ader_mat_stream_shadow * -1;

            	    	}

            	    	fprintf(fp, ", shadow [ %s, %ld ]",
            	    			GetText(ader_mat_stream_shadow + ADER_MAT_STREAM_ID),
								ader_mat_stream_shadow);

            	    }

            	    fprintf(fp, "\n");

            	    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
            	    {

            	    	num_stream_rows++;

                	    fprintf(fp, "        Summation stream\n");

            	    }


            	    ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            	    ADERPrintSumStreams(ader_mat_stream_sum_ent, fp, 1);

            		ader_mat_stream = NextItem(ader_mat_stream);

            	}

            	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

            	while(ader_mat_stream > VALID_PTR)
            	{

            		ADERPrintMaterialStreamIsotopes(ader_mat_stream, fp1, mat);

            		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_stream, 0, 0);

					fprintf(fp, "    %s, %ld",
							GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
							ader_mat_stream);

            	    if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0))
            	    {

            	    	fprintf(fp, ", removal table");

            	    }

            	    if(((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] != 0))
            	    {

            	    	ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            	    	if(ader_mat_stream_shadow < 0)
            	    	{

            	    		ader_mat_stream_shadow = ader_mat_stream_shadow * -1;

            	    	}

            	    	fprintf(fp, ", shadow [ %s, %ld ]",
            	    			GetText(ader_mat_stream_shadow + ADER_MAT_STREAM_ID),
								ader_mat_stream_shadow);

            	    }

            	    fprintf(fp, "\n");

            	    if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
            	    {

            	    	num_stream_rows++;

                	    fprintf(fp, "        Summation stream\n");

            	    }


            	    ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            	    ADERPrintSumStreams(ader_mat_stream_sum_ent, fp, 1);

            		ader_mat_stream = NextItem(ader_mat_stream);

            	}

            	fclose(fp1);

            	fprintf(fp, "    Number of total streams: %ld.\n\n", num_stream_cols);

            	if((long)RDB[ader_mat_data + ADER_MAT_CLUSTER_PARENT_PTR] == mat)
            	{

            		num_ents = 0;

            		num_eles = 0;

            		num_pres = 0;

            		num_oxi = 0;

            		num_reac = 0;

                	ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

            		fprintf(fp, "    \nMatrix Data Summary\n\n");

            		fprintf(fp, "      The row and column count will be a few off as\n \
      shadow streams are double counted in cluster materials.\n");

            		fprintf(fp, "        Rows: %ld\n", (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS]);

            		fprintf(fp, "        Cols: %ld\n", (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]);

            		/* Get num non-zero entries                               */

            		ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

            		while(ader_mat_matrix_col > VALID_PTR)
            		{

            			ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

            			while(ader_mat_matrix_col_row > VALID_PTR)
            			{

            				if(fabs(RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]) > 1E-12)
            				{

            					num_ents++;

            				}

            				ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

            			}

            			ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

            		}

            		fprintf(fp, "        Ents: %ld\n", num_ents);

            		filled_entries = (double)num_ents;

            		total_entries = RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] * RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS];

            		percent_empty = 1.0 - (filled_entries / total_entries);

            		fprintf(fp, "        %% Empty: %f\n", (100.0 * percent_empty));

            		/* Now, loop through cluster members, skipping the first  */
            		/* because it is the parent, and count their streams and  */
            		/* what not                                               */

            		ader_mat_cluster_mem_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

            		ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

            		while(ader_mat_cluster_mem_ent > VALID_PTR)
            		{

            			ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_mem_ent + ADER_MAT_CLUSTER_MEM_PTR];

            			ader_mat_cluster_mem_iso = (long)RDB[ader_mat_cluster_mem + MATERIAL_PTR_COMP];

            			while(ader_mat_cluster_mem_iso > VALID_PTR)
            			{

            				num_isos++;

            				ader_mat_cluster_mem_iso = NextItem(ader_mat_cluster_mem_iso);

            			}

            			ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

            			ader_mat_cluster_mem_ele = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_ELES_PTR];

            			while(ader_mat_cluster_mem_ele > VALID_PTR)
            			{

            				num_eles++;

            				ader_mat_cluster_mem_ele = NextItem(ader_mat_cluster_mem_ele);

            			}

            			ader_mat_cluster_mem_cmp = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_CMPS_PTR];

                    	while(ader_mat_cluster_mem_cmp > VALID_PTR)
                    	{

                    		num_cmp_rows++;

                            /* Loop through any rtos attached to this group           */

                    		ader_mat_cluster_mem_cmp_rto = (long)RDB[ader_mat_cluster_mem_cmp + ADER_MAT_CMP_RTOS_PTR];

                            while(ader_mat_cluster_mem_cmp_rto > VALID_PTR)
                            {

                            	num_cmp_rows++;

                                if(RDB[ader_mat_cluster_mem_cmp_rto + ADER_MAT_CMP_RTO_MAX] > 0.0)
                                {

                                	num_cmp_rows++;

                                }

                                ader_mat_cluster_mem_cmp_rto = NextItem(ader_mat_cluster_mem_cmp_rto);

                            }

                            /* Report if group is a summation group                   */

                            if((long)RDB[ader_mat_cluster_mem_cmp + ADER_MAT_CMP_SUM_GRPS_PTR] > VALID_PTR)
                            {

                            	num_cmp_rows++;

                            }

                            ader_mat_cluster_mem_cmp = NextItem(ader_mat_cluster_mem_cmp);

                    	}

                    	/*Now loop through streams                            */

                    	ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

                    	while(ader_mat_cluster_mem_stream > VALID_PTR)
                    	{

                    		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_cluster_mem_stream, 0, 0);

                    	    if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
                    	    {

                    	    	num_stream_rows++;

                    	    }

                    	    ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

                    	}

                    	ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

                    	while(ader_mat_cluster_mem_stream > VALID_PTR)
                    	{

                    		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_cluster_mem_stream, 0, 0);

                    	    if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
                    	    {

                    	    	num_stream_rows++;

                    	    }

                    	    ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

                    	}

                    	ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

                    	while(ader_mat_cluster_mem_stream > VALID_PTR)
                    	{

                    		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_cluster_mem_stream, 0, 0);

                    	    if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
                    	    {

                    	    	num_stream_rows++;

                    	    }

                    	    ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

                    	}

                    	ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

                    	while(ader_mat_cluster_mem_stream > VALID_PTR)
                    	{

                    		num_stream_cols = num_stream_cols + ADERCountStream(ader_mat_cluster_mem_stream, 0, 0);

                    	    if((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SUM_GRPS_PTR] > VALID_PTR)
                    	    {

                    	    	num_stream_rows++;

                    	    }

                    	    ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

                    	}

                    	if((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_OXI_PTR] > VALID_PTR)
                    	{

                    		num_oxi++;

                    	}

                    	if((long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
                    	{

                    		num_reac = num_reac + 2;

                    	}

                    	ader_mat_cluster_mem_pres = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_PRESERVES_PTR];

						while(ader_mat_cluster_mem_pres > VALID_PTR)
						{

							num_pres++;

							ader_mat_cluster_mem_pres = NextItem(ader_mat_cluster_mem_pres);

						}

                    	ader_mat_cluster_mem_ent = NextItem(ader_mat_cluster_mem_ent);

            		}

            		/* Count the elements in the parent                       */

            		ader_mat_ele = (long)RDB[ader_mat_data + ADER_MAT_ELES_PTR];

            		while(ader_mat_ele > VALID_PTR)
            		{

            			num_eles++;

            			ader_mat_ele = NextItem(ader_mat_ele);

            		}

            		/* Count the pres entries, in the parent                  */

            		ader_mat_pres = (long)RDB[ader_mat_data + ADER_MAT_PRESERVES_PTR];

            		while(ader_mat_pres > VALID_PTR)
            		{

            			num_pres++;

            			ader_mat_pres = NextItem(ader_mat_pres);

            		}

            		fprintf(fp, "        Ele Cols:    %ld\n", (num_eles * 2));

            		fprintf(fp, "        Iso Cols:    %ld\n", (num_isos * 2));

            		fprintf(fp, "        Stream Cols: %ld\n", num_stream_cols);

            		fprintf(fp, "        Total Cols:  %ld\n", ((num_eles * 2) +
            				                                   (num_isos * 2) +
															   num_stream_cols));

            		fprintf(fp, "        Cmp Rows:    %ld\n", num_cmp_rows);

            		fprintf(fp, "        Ele Rows:    %ld\n", (num_eles * 4));

            		fprintf(fp, "        Iso Rows:    %ld\n", (num_isos * 3));

            		fprintf(fp, "        Opt Rows:    %d\n", 1);

            		if((long)RDB[ader_mat_data + ADER_MAT_OXI_PTR] > VALID_PTR)
            		{

            			num_oxi++;

            			fprintf(fp, "        Oxi Rows:    %d\n", 1);

            		}

            		fprintf(fp, "        Pres Rows:   %ld\n", num_pres);

            	    if(RDB[ader_mat_data + ADER_MAT_RHO_WEIGHT] > 0.0)
            		{

            			num_reac = num_reac + 2;

            			fprintf(fp, "        Oxi Rows:    %d\n", 1);

            		}

            		fprintf(fp, "        Stream Rows: %ld\n", num_stream_rows);

            		fprintf(fp, "        Total Rows:  %ld\n\n", (num_cmp_rows + (num_eles * 4) +
            				                                   (num_isos * 3) +
															   num_oxi +
															   num_pres +
															   num_reac +
															   num_stream_rows) + 1);

            	}

        	}

        	/* Rebuild the stream indices                                     */

        	dump_vector = ADERGetBurnMatrixSizeData(mat);

        	ADERDeallocateTarget(dump_vector, 5);

        	mat = NextItem(mat);

        }

        fprintf(fp, "\nEnd materials:\n\n");


        fprintf(fp, "********************************************************************************\n");

        fclose(fp);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintmaterialstreamisotopes.c              */
/*                                                                           */
/* Created:       2016/25/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Prints stream isotopes to file                               */
/*                                                                           */
/* Comments:This function is called from ADERPrintListsHierarchy             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintMaterialStreamIsotopes:"

void ADERPrintMaterialStreamIsotopes(long ader_mat_stream, FILE *fp, long mat)
{

	long ader_mat_iso = 0, ader_mat_stream_iso = 0;
    long ader_mat_stream_sum_stream = 0, ader_mat_stream_sum_stream_ent = 0;
    long mat_iso = 0, nuc = 0;

    /* Loop into sum streams                                                  */

    ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    {

    	ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        /* Process these streams if they exist                               */

    	ADERPrintMaterialStreamIsotopes( ader_mat_stream_sum_stream, fp, mat);

    	ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    }

    ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

    while(ader_mat_stream_iso > VALID_PTR)
    {

    	ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	fprintf(fp, "%s, %s, %s, %s, %ld\n",
    			GetText(mat + MATERIAL_PTR_NAME),
				GetText(ader_mat_stream + ADER_MAT_STREAM_ID),
				GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
				GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
				(long)RDB[nuc + NUCLIDE_ZAI]);

    	fprintf(fp, "    ADER_MAT_STREAM: %ld\n", ader_mat_stream);

    	fprintf(fp, "    ADER_MAT_STREAM_ISOS_PTR: %ld\n", ader_mat_stream_iso);

    	fprintf(fp, "    MATERIAL_COMPOSITION_PTR: %ld\n", mat_iso);

    	fprintf(fp, "    COMPOSITION_PTR_NUCLIDE: %ld\n", nuc);

    	fprintf(fp, "    ADER_MAT_ISOS_PTR: %ld\n", ader_mat_iso);

    	fprintf(fp, "    ADER_MAT_ISO_BURN_INDEX: %ld\n", (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]);

    	fprintf(fp, "\n");

    	ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintoutput.c                              */
/*                                                                           */
/* Created:       2017/08/06 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Prints ADER data for burn output for target material given   */
/*              by 'name'                                                    */
/*                                                                           */
/* Comments:This function is called from PrintDepVals                        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintOutput:"

void ADERPrintOutput(long burn_mat, FILE* fp, char* mat_name)
{

	long ader_mat_data = 0, ader_mat_cmp = 0, ader_mat_cmp_burn_step = 0, ader_mat_stream = 0;
	long i = 0, mat = 0;
	long burn_steps = 0;

	/* Go ahead and set burn_steps. If RDB[DATA_BURN_STEP] is 0 and this      */
	/* function has been called, set burnsteps to 1 so that some printing     */
	/* as it is supposed to if we make it here                                */

	if((long)RDB[DATA_BURN_STEP] == 0)
	{

		burn_steps = 1;

	}
	else
	{

		burn_steps = (long)RDB[DATA_BURN_STEP];

	}

	/* First, we need to find the material who's name is given by mat_name    */

	mat = (long)RDB[DATA_PTR_M0];

	while(mat > VALID_PTR)
	{

		if(strcmp(mat_name, GetText(mat + MATERIAL_PTR_NAME)) == 0)
		{

			break;

		}

		mat = NextItem(mat);

	}

	/* Get the ader_mat_data                                                  */

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	if(ader_mat_data < VALID_PTR)
	{

		return;

	}

	/* Set the printed flag, this is needed to avoid double printing when this*/
	/* function is called later to print non-burning ADER materials           */

	if(burn_mat > 0)
	{

		WDB[ader_mat_data + ADER_MAT_PRINTED_FLAG] = 1.0;

	}
	else if((long)RDB[ader_mat_data + ADER_MAT_PRINTED_FLAG] > 0)
	{

		return;

	}

	/* Loop through the cmp groups and print out their data                   */

	ader_mat_cmp = (long)RDB[ader_mat_data + ADER_MAT_CMPS_PTR];

	while(ader_mat_cmp > VALID_PTR)
	{

	    fprintf(fp, "MAT_%s_GRP_%s_FRAC = [ ", mat_name,
	    		GetText(ader_mat_cmp + ADER_MAT_CMP_ID));

	    /* Get the cmp burn data                                              */

	    ader_mat_cmp_burn_step = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_BURN_STEPS_PTR];

	    /* Print the burn data in the .m file vector format                   */

	    for(i = 0; i < burn_steps; i++)
	    {

	    	fprintf(fp, "%1.5E ", RDB[ader_mat_cmp_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE]);

	    	ader_mat_cmp_burn_step = NextItem(ader_mat_cmp_burn_step);

	    }

	    /* Close the vector                                                   */

	    fprintf(fp, "];\n\n");

		ader_mat_cmp = NextItem(ader_mat_cmp);

	}

	/* Now, loop through the material's streams and call a recurssive function*/
	/* to print the data out                                                  */

	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_FEED_STREAMS_PTR];

	while(ader_mat_stream > VALID_PTR)
	{

		ADERPrintOutputStreamData(ader_mat_stream, fp, mat_name);

		ader_mat_stream = NextItem(ader_mat_stream);

	}

	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REAC_STREAMS_PTR];

	while(ader_mat_stream > VALID_PTR)
	{

		ADERPrintOutputStreamData(ader_mat_stream, fp, mat_name);

		ader_mat_stream = NextItem(ader_mat_stream);

	}

	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REDOX_STREAMS_PTR];

	while(ader_mat_stream > VALID_PTR)
	{

		ADERPrintOutputStreamData(ader_mat_stream, fp, mat_name);

		ader_mat_stream = NextItem(ader_mat_stream);

	}

	ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

	while(ader_mat_stream > VALID_PTR)
	{

		ADERPrintOutputStreamData(ader_mat_stream, fp, mat_name);

		ader_mat_stream = NextItem(ader_mat_stream);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintoutputstreamdata.c                    */
/*                                                                           */
/* Created:       2017/08/06 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Prints ADER data for burn output for target stream and       */
/*              tunnels into sumstreams                                      */
/*                                                                           */
/* Comments:This function is called from ADERPrintOutput                     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintOutputStreamData:"

void ADERPrintOutputStreamData(long ader_mat_stream, FILE* fp, char* mat_name)
{

	long ader_mat_data = 0, ader_mat_stream_burn_step = 0, ader_mat_stream_sum_stream = 0;
	long ader_mat_stream_sum_stream_ent = 0, i = 0, mat = 0;
	long burn_steps = 0;

	/* Get the ader mat data, we will need it.                                */

	mat = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_MAT_PTR];

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Go ahead and set burn_steps. If RDB[DATA_BURN_STEP] is 0 and this      */
	/* function has been called, set burnsteps to 1 so that some printing     */
	/* as it is supposed to if we make it here                                */

	if((long)RDB[DATA_BURN_STEP] == 0)
	{

		burn_steps = 1;

	}
	else
	{

		burn_steps = (long)RDB[DATA_BURN_STEP];

	}

	fprintf(fp, "MAT_%s_STREAM_%s_STEP_AMT = [ ", mat_name,
			GetText(ader_mat_stream + ADER_MAT_STREAM_ID));

	/* Get the stream burn data                                                  */

	ader_mat_stream_burn_step = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_STEPS_PTR];

	/* Print the burn data in the .m file vector format                       */

	for(i = 0; i < burn_steps; i++)
	{

		fprintf(fp, "%1.5E ", RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE]);

		ader_mat_stream_burn_step = NextItem(ader_mat_stream_burn_step);

	}

	/* Close the vector                                                       */

	fprintf(fp, "];\n\n");

	/* Now, loop through the sum streams if there are any                     */

	ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	while(ader_mat_stream_sum_stream_ent > VALID_PTR)
	{

		ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

		ADERPrintOutputStreamData(ader_mat_stream_sum_stream, fp, mat_name);

		ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprintsumstreams.c                          */
/*                                                                           */
/* Created:       2016/25/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Provides information regarding ADER summation streams for the*/
/*              ADERPrintListsHierarchy function                             */
/*                                                                           */
/* Comments:This function is called from ADERPrintListsHierarchy             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERPrintSumStreams:"

void ADERPrintSumStreams(long ader_mat_stream_sum_ent, FILE* fp, int sum_level)
{

    char print_data[256];
    long ader_mat_stream_sum_stream = 0;

    while(ader_mat_stream_sum_ent > VALID_PTR)
    {

        /* Get the actual sum stream pointed to by the stream_sum_ent             */

        ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        /* Print the data                                                         */

    	sprintf(print_data, "        %i: %s, %ld\n", sum_level,
    			GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID),
    			ader_mat_stream_sum_stream);

    	fprintf(fp, "%s", print_data);

    	ADERPrintSumStreams((long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_SUM_GRPS_PTR],
    			            fp, sum_level + 1);

    	ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessaderclustermems.c                   */
/*                                                                           */
/* Created:       2016/03/03 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Based on the status of stream materials belonging or not to  */
/*              an ader cluster this function handles their assignment.      */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderClusters             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderClusterMems:"

void ADERProcessAderClusterMems(long ader_strm, long ader_strm_dest_cluster,
                                char* ader_strm_dest_id,
                                long ader_strm_src_cluster,
                                char* ader_strm_src_id)
{

    long ader_cluster = 0, ader_data = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    if((ader_strm_dest_cluster < 0) && (ader_strm_src_cluster < 0))
    {

        /* Neither material belongs to a cluster, create one and add them */

        ader_cluster = NewItem(ader_data + ADER_CLUSTERS_PTR,
                               ADER_CLUSTER_BLOCK_SIZE);

        if(strncmp("NULL", ader_strm_dest_id, 4) != 0)
        {

            WDB[ader_cluster + ADER_CLUSTER_PARENT_ID] = RDB[ader_strm + ADER_STREAM_DEST];

        }
        else
        {

            WDB[ader_cluster + ADER_CLUSTER_PARENT_ID] = RDB[ader_strm + ADER_STREAM_SRC];

        }

        ADERAddClusterMember(ader_cluster, ader_strm_dest_id,
                             RDB[ader_strm + ADER_STREAM_DEST]);

        ADERAddClusterMember(ader_cluster, ader_strm_src_id,
                             RDB[ader_strm + ADER_STREAM_SRC]);

    }
    else if((ader_strm_dest_cluster > 0) && (ader_strm_src_cluster < 0))
    {

        /* The dest material belongs to a cluster. Add the source to this cluster */

        ADERAddClusterMember(ader_strm_dest_cluster, ader_strm_src_id,
                             RDB[ader_strm + ADER_STREAM_SRC]);

    }
    else if((ader_strm_dest_cluster < 0) && (ader_strm_src_cluster > 0))
    {

        /* The src material belongs to a cluster. Add the dest to this cluster */

        ADERAddClusterMember(ader_strm_src_cluster, ader_strm_dest_id,
                             RDB[ader_strm + ADER_STREAM_DEST]);

    }
    else if((ader_strm_dest_cluster > 0) && (ader_strm_src_cluster > 0) &&
            ader_strm_dest_cluster != ader_strm_src_cluster)
    {

        /* Each material belongs to a different cluster. Merge these two clusters */

        ADERMergeClusters(ader_strm_dest_cluster, ader_strm_src_cluster);

    }
    else if((ader_strm_dest_cluster > 0) && (ader_strm_src_cluster > 0) &&
            ader_strm_dest_cluster == ader_strm_src_cluster)
    {

        /* Both materials already belong to the same cluster, do nothing */

    }
    else
    {

        Error(0, "Attempted to assign materials, \n \
%s, and %s \n \
to an ADER cluster and failed. These materials are part of a 'stream' entry.\n",
              ader_strm_dest_id, ader_strm_src_id);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessaderclusters.c                      */
/*                                                                           */
/* Created:       2016/03/03 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Goes through ader streams and determines the index, if any,  */
/*              of the ader cluster to which the streams materials belong to */
/*              Calls ADERProcessAderClusterMems to assign materials to      */
/*              clusters                                                     */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderMainData             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderClusters:"

void ADERProcessAderClusters()
{

    char *ader_cluster_ent_id = NULL, *ader_cluster_parent_id = NULL, *ader_strm_dest_id = NULL;
    char *ader_strm_src_id = NULL;
    long ader_cluster = 0, ader_cluster_ent = 0, ader_data = 0;
    long ader_strm = 0, ader_strm_dest_cluster = 0, ader_strm_src_cluster = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_strm = (long)RDB[ader_data + ADER_STREAMS_PTR];

    while(ader_strm > VALID_PTR)
    {

        ader_strm_dest_cluster = -1;

        ader_strm_src_cluster = -1;

        ader_strm_dest_id = GetText(ader_strm + ADER_STREAM_DEST);

        ader_strm_src_id = GetText(ader_strm + ADER_STREAM_SRC);

        ader_cluster = (long)RDB[ader_data + ADER_CLUSTERS_PTR];

        /* This loop simply finds if the materials in the given stream */
        /* already belongs to an ader cluster group. If they do, we save that */
        /* cluster index, if they don't, their index remains -1 */

        while(ader_cluster > VALID_PTR)
        {

            ader_cluster_parent_id = GetText(ader_cluster + ADER_CLUSTER_PARENT_ID);

            if(strncmp("VOID", ader_cluster_parent_id, 4) != 0)
            {

                ader_cluster_ent = (long)RDB[ader_cluster + ADER_CLUSTER_ENT_PTR];

                while(ader_cluster_ent > VALID_PTR)
                {

                    ader_cluster_ent_id = GetText(ader_cluster_ent + ADER_CLUSTER_ENT_ID);

                    if(strcmp(ader_cluster_ent_id, ader_strm_dest_id) == 0)
                    {

                        ader_strm_dest_cluster = ader_cluster;

                    }

                    if(strcmp(ader_cluster_ent_id, ader_strm_src_id) == 0)
                    {

                        ader_strm_src_cluster = ader_cluster;

                    }

                    ader_cluster_ent = NextItem(ader_cluster_ent);

                }

            }

            ader_cluster = NextItem(ader_cluster);

        }

        /* Now, there are a couple things that can happen once we know the */
        /* cluster indices, these are handled in the function below */

        ADERProcessAderClusterMems(ader_strm, ader_strm_dest_cluster,
                                   ader_strm_dest_id, ader_strm_src_cluster,
                                   ader_strm_src_id);

        ader_strm = NextItem(ader_strm);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessadergroupfractions.c                */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Converts elemental and isotopic ratios to fractions          */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderGroups               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderGroupFractions:"

void ADERProcessAderGroupFractions(long grp)
{

    double ele_sum = 0.0;
    double iso_sum = 0.0;
    long ele = 0, iso = 0;

    ele = (long)RDB[grp + ADER_GRP_COMP_PTR];

    /* Get the total */
    while(ele > VALID_PTR)
    {

        ele_sum += RDB[ele + ADER_GRP_COMP_FRAC];

        ele = NextItem(ele);

    }

    /* Turn that total into decimals. Also, do the same for isos */
    ele = (long)RDB[grp + ADER_GRP_COMP_PTR];

    while(ele > VALID_PTR)
    {

        WDB[ele + ADER_GRP_COMP_FRAC] = RDB[ele + ADER_GRP_COMP_FRAC] / ele_sum;

        iso_sum = 0.0;

        /* Get the iso sum if it exists, if no isos, both of these next while */
        /* loops will not run */

        iso = (long)RDB[ele + ADER_GRP_COMP_ISOS_PTR];

        while(iso > VALID_PTR)
        {

            iso_sum += RDB[iso + ADER_GRP_ISO_FRAC];

            iso = NextItem(iso);

        }

        iso = (long)RDB[ele + ADER_GRP_COMP_ISOS_PTR];

        while(iso > VALID_PTR)
        {

            WDB[iso + ADER_GRP_ISO_FRAC] = RDB[iso + ADER_GRP_ISO_FRAC] / iso_sum;

            iso = NextItem(iso);

        }

        ele = NextItem(ele);

    }
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessadergroups.c                        */
/*                                                                           */
/* Created:       2015/12/8 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Call ADERProcessAderGroupFractions to convert group element  */
/*            and isotopic ratios to decimals. Calls ADERProcessAderSumGroup */
/*              to link sum groups with their child groups                   */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderMainData             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderGroups:"

void ADERProcessAderGroups()
{

    long ader_data = 0, grp = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ader_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {

        ADERProcessAderGroupFractions(grp);

        if(RDB[grp + ADER_GRP_SUM_GRPS_PTR] > VALID_PTR)
        {

            ADERProcessAderSumGroup(grp);

        }

        grp = NextItem(grp);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessadermaindata.c                      */
/*                                                                           */
/* Created:       2015/12/8 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls various functions to process main ader input not       */
/*              not related to specific materials                            */
/*                                                                           */
/* Comments:This function is called from main.c                              */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMainData:"

void ADERProcessAderMainData()
{

    long ader_data = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    /* If no max iteration was set for the transport cycle, set it here       */

    if((long)RDB[ader_data + ADER_TRANS_ITER] < 1)
    {

        WDB[ader_data + ADER_TRANS_ITER] = 5.0;

    }

    /* Set the initial ADER iteration showing that ADER iterations have not   */
    /* yet started                                                            */

    WDB[(long)RDB[DATA_PTR_ADER] + ADER_TRANS_ITER_NUM] = -1.0;

    ADERProcessAderGroups();

    ADERProcessAderStreams();

    ADERProcessAderClusters();

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessaderstreams.c                       */
/*                                                                           */
/* Created:       2015/12/8 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to condition ADER stream data                */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderMainData             */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderStreams:"

void ADERProcessAderStreams()
{

    long ader_data = 0, ader_strm = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_strm = (long)RDB[ader_data + ADER_STREAMS_PTR];

    while(ader_strm > VALID_PTR)
    {

        ADERProcessAderStreamSourcesAndDests(ader_strm);

        ader_strm = NextItem(ader_strm);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessaderstreamsourcesanddests.c         */
/*                                                                           */
/* Created:       2015/12/8 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sets a streams source or dest to null if there is no data.   */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderStreams              */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderStreamSourcesAndDests:"

void ADERProcessAderStreamSourcesAndDests(long ader_strm)
{

    if(RDB[ader_strm + ADER_STREAM_DEST] < VALID_PTR)
    {

        WDB[ader_strm + ADER_STREAM_DEST] = (double)PutText("NULL");

    }

    if(RDB[ader_strm + ADER_STREAM_SRC] < VALID_PTR)
    {

        WDB[ader_strm + ADER_STREAM_SRC] = (double)PutText("NULL");

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessadersumgroup.c                      */
/*                                                                           */
/* Created:       2015/12/8 (DDW)                                            */
/* Last modified: 2015/12/8(DDW)                                             */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Links ADER_GRP_SUM_GRP_PTR to the group it should point to   */
/*                                                                           */
/* Comments:This function is called from ADERProcessAderGroups               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderSumGroup:"

void ADERProcessAderSumGroup(long grp)
{

    char *grp_id = NULL;
    long ader_data = 0, search_grp = 0, sum_grp = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    sum_grp = (long)RDB[grp + ADER_GRP_SUM_GRPS_PTR];

    while(sum_grp > VALID_PTR)
    {

        grp_id = GetText(sum_grp + ADER_GRP_SUM_GRP_ID);

        search_grp = (long)RDB[ader_data + ADER_GROUPS_PTR];

        /* We know the group's name we have to find, find it, store its location */
        /* in the ADER_GRP_SUM_GRP_PTR slot. Add this group's density, times  */
        /* it's weight value to the host's density                            */

        while(search_grp > VALID_PTR)
        {

            if(strcmp(GetText(search_grp + ADER_GRP_ID), grp_id) == 0)
            {

                WDB[sum_grp + ADER_GRP_SUM_GRP_PTR] = (double)search_grp;

                break;

            }

            search_grp = NextItem(search_grp);

        }

        sum_grp = NextItem(sum_grp);

    }
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderburnmatrixcontstream.c                     */
/*                                                                           */
/* Created:       2016/28/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Recursively uncovers summation streams if they exist. Once   */
/*              a base stream is found this function fills in the isotopic   */
/*              fractions for the base stream into its column vector         */
/*                                                                           */
/* Comments:This function is called from ADERMakeBurnMatrix                  */
/*                                       ADERProcessBurnMatrixContStream     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessBurnMatrixContStream:"

long ADERProcessBurnMatrixContStream(struct ccsMatrix* burn_matrix,
		                             long ader_mat_stream, double* col_vector,
		                             long entry_number, long mat, long num_rows,
									 long* return_array)
{

	double volume_corr_factor = 0.0;
	long ader_mat_iso = 0, ader_mat_stream_iso = 0, ader_mat_stream_shadow_stream = 0;
	long ader_mat_stream_sum_ent = 0, ader_mat_stream_sum_stream = 0;
	long ader_shadow_mat = 0, check_column = 0;
	long expected_col_index = 0, found = 0, mat_iso = 0, nuc = 0;
	long rem_stream = 0, sign = 0;

	if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
	{

		rem_stream = 1;

	}

	/* Tunnel into the sum streams of the parent stream if they exist         */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	if(ader_mat_stream_sum_ent > VALID_PTR)
	{

		/* If there are sum streams, pass them to this function               */

		while(ader_mat_stream_sum_ent > VALID_PTR)
		{

			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

			entry_number = ADERProcessBurnMatrixContStream(burn_matrix,
					                                       ader_mat_stream_sum_stream,
														   col_vector,
														   entry_number,
														   mat, num_rows,
														   return_array);

			ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

		}

	}
	else
	{

		/* Once the function finds a stream with no sum components, it is time*/
		/* to fill in its isotopic data. First wipe col_vector                */

		memset(col_vector, 0.0, sizeof(double) * num_rows);

		/* This procedure will need to be executed for both sides of a shadow */
		/* pair if this stream has a shadow, which by the way this function is*/
		/* called, will always be a destination side shadow if it exists      */

		/* Now, determine if this stream is entering or leaving the material  */

		if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
				  GetText(mat + MATERIAL_PTR_NAME)) == 0)
		{

			sign = 1;

		}
		else
		{

			sign = -1;
		}

		/* Now, loop through the stream's isotopes to fill in their fractions */
		/* into the burnup matrix                                             */

		ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_iso > VALID_PTR)
		{

			ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

			mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

			/* Do not process isotopes with no contribution rate              */

			if(RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] != 0.0)
			{

				if(rem_stream > 0)
				{

					if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
					{

						col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
								                                                         RDB[mat_iso + COMPOSITION_ADENS] * sign;

					}
					else
					{

						col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
								                                                         RDB[mat_iso + COMPOSITION_ADENS_BOS] * sign;

					}



				}
				else
				{

					col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] * sign;

				}

			}

			ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

		}

		/* Now, if that destination side shadow stream exists, process it     */
		/* The sign will be 1, because it will be a destination side stream   */

		sign = 1;

		ader_mat_stream_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] * -1;

		if(ader_mat_stream_shadow_stream > VALID_PTR)
		{

			/* Get the volume correction factor for the destination material  */

			ader_shadow_mat = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

			volume_corr_factor = RDB[mat + MATERIAL_VOLUME] /
					             RDB[ader_shadow_mat + MATERIAL_VOLUME];

			/* Now, loop through the stream's isotopes to fill in their       */
			/* fractions into the burnup matrix                               */

			ader_mat_stream_iso = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_ISOS_PTR];

			while(ader_mat_stream_iso > VALID_PTR)
			{

				/* Do not process isotopes with no contribution rate          */

				/* NOTICE!!! The mat_iso variable is NOT RESET. IT IS THE SAME*/
				/* FROM THE NON-SHADOW stream iso. This is to give the        */
				/* correct mass transfer rate                                 */

				if(RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] != 0.0)
				{

					/* Find the corresponding isotope in the source side      */
					/* stream for density information                         */

					found = 0;

					mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

					while(mat_iso > VALID_PTR)
					{

						nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

						if((long)RDB[nuc + NUCLIDE_ZAI] == (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI])
						{

							found = 1;

							break;

						}

						mat_iso = NextItem(mat_iso);

					}

					if(found < 1)
					{

						Die(FUNCTION_NAME, "A matching isotope in the source side material %s\n\
was not found for isotope %ld in stream %s in\n\
the destination side material %s\n", GetText(mat + MATERIAL_PTR_NAME),
                            (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI],
							GetText(ader_mat_stream_shadow_stream + ADER_MAT_STREAM_ID),
							GetText((long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR] + MATERIAL_PTR_NAME));

					}

					ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

					if(rem_stream > 0)
					{

						if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
						{

							col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
									                                                         RDB[mat_iso + COMPOSITION_ADENS] * sign * volume_corr_factor;

						}
						else
						{

							col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
									                                                         RDB[mat_iso + COMPOSITION_ADENS_BOS] * sign * volume_corr_factor;

						}

					}
					else
					{

						col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] += RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] * sign * volume_corr_factor;

					}

				}

				ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

			}

		}

		/* Now that the col_vector has been populated, it needs to be inserted*/
		/* into the burnup matrix                                             */

#ifdef ADER_DIAG
		    /* Check to make sure column indices match                        */

		    check_column = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

		    expected_col_index = return_array[0];

		    if(expected_col_index != check_column)
		    {

				Die(FUNCTION_NAME, "Expected to store column %ld but got column %ld.\n",
				    expected_col_index, check_column);

		    }

#endif

	    entry_number = ADERStoreBurnMatrixColumn(burn_matrix,
	    		                                 (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX],
												 col_vector,
	    		                                 entry_number, num_rows);

	    return_array[0] = return_array[0] + 1;

	}

	return(entry_number);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessburnmatrixfissionyield.c            */
/*                                                                           */
/* Created:       2016/29/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills fission yield effects for isotope and its products     */
/*                                                                           */
/* Comments: This function is called from ADERMakeBurnMatrix                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessBurnMatrixFissionYield"

void ADERProcessBurnMatrixFissionYield(long ader_mat_iso, double* col_vector,
		                               long fission_yield_data, long mat,
									   double mat_flux, long nuc, long omp_id,
									   long rea, long type)
{

	double micro_cross_section = 0, reaction_rate = 0;
	long ader_mat_iso_product_index = 0, fission_yield = 0, fission_yield_nuc = 0;

	/* If this is spontaneous fission, the reaction rate is the decay constant*/

	if(type == REACTION_TYPE_DECAY)
	{

		reaction_rate = RDB[nuc + NUCLIDE_LAMBDA] *
				        RDB[rea + REACTION_BR];

	}
	else
	{

		/* This is a particle induced fission, to get the rate GetPrivateData is */
		/* used as opposed to TestValuePair ( the function used in the normal */
		/* SERPENT version as, at the time of development, there were         */
		/* unresolved bug concerns with TestValuePair. When used properly     */
		/* GetPrivateData is equivalent to a correct implementation of        */
		/* TestValuePair. It is important to know that TestValuePair takes    */
		/* the RDB LOCATION of the data, and not the data itself while        */
		/* GetPrivateData DOES take the actual data ICREMENTED BY 1           */

		micro_cross_section = GetPrivateData(((long)RDB[rea + REACTION_PTR_TRANSMUXS]) + 1,
				                             omp_id);

		/* Make sure a physical answer is provided                            */

		if(micro_cross_section > 0.0)
		{

			reaction_rate = micro_cross_section * mat_flux *
					        BARN * RDB[rea + REACTION_BR];

		}
		else
		{

			/* The cross section is not real                                  */

			reaction_rate = 0.0;

		}

	}

	/* Go ahead and add this removal rate to the isotope's own                */
	/* production/destruction rate                                            */

	col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] -= reaction_rate;

	/* Now, loop through the fission yield products and fill in their         */
	/* production data from this isotope                                      */

	fission_yield = (long)RDB[fission_yield_data + FISSION_YIELD_PTR_DISTR];

	while(fission_yield > VALID_PTR)
	{

		/* Get the product "nuc" data                                         */

		fission_yield_nuc = (long)RDB[fission_yield + FY_PTR_TGT];

		/* Get the matching ader isotope IN THIS MATERIAL                     */

		ader_mat_iso_product_index = ADERGetIsoBurnMatrixIndex(FUNCTION_NAME,
				                                               mat,
														       fission_yield_nuc);

		/* Now, add the fractional reaction rate to the production of the     */
		/*target isotope from the isotope undergoing fission                  */

		col_vector[ader_mat_iso_product_index] += reaction_rate *
				                                  RDB[fission_yield + FY_INDEPENDENT_FRAC] *
                                                  RDB[rea + REACTION_BR];

		fission_yield = NextItem(fission_yield);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessburnmatrixproxstream.c              */
/*                                                                           */
/* Created:       2016/29/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills in prop stream contributions to isotopic balances and  */
/*              fills in isotopic contributions to prop stream balances      */
/*                                                                           */
/* Comments: This function is called from ADERMakeBurnMatrix                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessBurnMatrixPropStream:"

void ADERProcessBurnMatrixPropStream(long ader_mat_ader_iso, long ader_mat_stream,
		                             double* col_vector, long mat)
{

	double adens_corr_factor = 0.0, lambda = 0, sign = 0;
	double iso_transfer_amount = 0.0;
	long ader_mat_data = 0;
	long ader_stream = 0, ader_mat_stream_iso = 0, ader_mat_stream_shadow_stream = 0;
	long ader_mat_stream_sum_ent = 0, ader_mat_stream_sum_stream = 0, mat_iso = 0, nuc = 0;
	long shadow_mat = 0, shadow_mat_ader_data = 0, shadow_mat_ader_iso = 0, shadow_mat_iso = 0;
	long shadow_mat_nuc = 0;

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Tunnel into the sum streams of the parent stream if they exist         */

	ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

	if(ader_mat_stream_sum_ent > VALID_PTR)
	{

		/* If there are sum streams, pass them to this function               */

		while(ader_mat_stream_sum_ent > VALID_PTR)
		{

			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

	    	ADERProcessBurnMatrixPropStream(ader_mat_ader_iso,
	    			                        ader_mat_stream_sum_stream,
											col_vector, mat);

			ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

		}

	}
	else
	{

		/* Determine if this stream is entering or leaving the material       */

		if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_DEST),
				  GetText(mat + MATERIAL_PTR_NAME)) == 0)
		{

			sign = 1.0;

		}
		else
		{

			sign = -1.0;

		}

		/* Search through the stream's isotopes to see if it has data for the     */
		/* isotope currently being processed. To find matching isotopes simply see*/
		/* if the pointer in the stream iso matches the pointer of the current    */
		/* isotope                                                                */

		ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_iso > VALID_PTR)
		{

			/* Skip isos with zero fraction                                   */

			if(RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] == 0.0)
			{

				ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

				continue;

			}

			if((long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR] ==
			   ader_mat_ader_iso)
			{

				mat_iso = (long)RDB[ader_mat_ader_iso + ADER_MAT_ISO_PTR];

				/* If the stream is a rem type stream, it will be processed   */
				/* differently from a non-rem type stream. Rem type streams   */
				/* have a fixed transfer rate while non-rem type streams have */
				/* a claculated rate                                          */

				if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
				{

					/* The original ader stream will be needed to get the other part  */
					/* of the removal rate                                            */

					ader_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_PTR];

					lambda = RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
							 RDB[ader_stream + ADER_STREAM_OPT1] * sign;

				}
				else
				{

					/* This is a non-rem type stream. It has a target removal */
					/* amount given as its "CUR_AMT". This amount must be     */
					/* converted to an approximate removal rate constant for  */
					/* each isotope in question                               */

					if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
					{

						iso_transfer_amount = (RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] *
							                   RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
								               RDB[ader_mat_data + ADER_MAT_PRE_STEP_ADENS]) /
							                  RDB[mat_iso + COMPOSITION_ADENS];

					}
					else
					{

						iso_transfer_amount = (RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] *
							                   RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] *
								               RDB[ader_mat_data + ADER_MAT_PRE_STEP_ADENS]) /
							                  RDB[mat_iso + COMPOSITION_ADENS_BOS];

					}

					if(sign > 0)
					{

						lambda = (1.0 / RDB[DATA_BURN_TIME_INTERVAL]) *
								 log(1.0 + iso_transfer_amount);

					}
					else
					{

						if(iso_transfer_amount == 1.0)
						{

							iso_transfer_amount = 0.9999999999;

						}

						lambda = (1.0 / RDB[DATA_BURN_TIME_INTERVAL]) *
								 log(1.0 - iso_transfer_amount);

					}

				}

				col_vector[(long)RDB[ader_mat_ader_iso + ADER_MAT_ISO_BURN_INDEX]] += lambda;

	            /* Add this removal amount to the proportional stream accumulator */
				/* line only if the stream is the source side of a shadow pair or */
				/* a lone stream                                                  */

				if((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR)
				{

					col_vector[(long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX]] += fabs(lambda);

				}

				/* If this stream is a shadow stream the information for the      */
				/* destination end, as the way this function is called if it is a */
				/* shadow stream it will be the source end, needs to be filled in */
				/* as well                                                        */

				ader_mat_stream_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] * -1;

				if(ader_mat_stream_shadow_stream > VALID_PTR)
				{

					/* Get the mat that the shadow stream belongs to              */

					shadow_mat = (long)RDB[ader_mat_stream_shadow_stream + ADER_MAT_STREAM_MAT_PTR];

					if(ader_mat_stream_shadow_stream > VALID_PTR)
					{

						adens_corr_factor = (RDB[mat + MATERIAL_VOLUME] /
								             RDB[shadow_mat + MATERIAL_VOLUME]);

					}

					shadow_mat_ader_data = (long)RDB[shadow_mat + MATERIAL_ADER_DATA];

					/* Get the nuc that is attached to the mat iso that           */
					/* corresponds to the passed in ader_iso                      */

					nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

					/* Loop through the shadow_mat's ader isostopes to find the   */
					/* matching one to the isotope that was passed in             */

					shadow_mat_ader_iso = (long)RDB[shadow_mat_ader_data + ADER_MAT_ISOS_PTR];

					while(shadow_mat_ader_iso > VALID_PTR)
					{

						shadow_mat_iso = (long)RDB[shadow_mat_ader_iso + ADER_MAT_ISO_PTR];

						shadow_mat_nuc = (long)RDB[shadow_mat_iso + COMPOSITION_PTR_NUCLIDE];

						if((long)RDB[nuc + NUCLIDE_ZAI] == (long)RDB[shadow_mat_nuc + NUCLIDE_ZAI])
						{

							/* We use the fraction from the original passed in    */
							/* stream's iso because these are shadow streams,     */
							/* these isos by definition have the same fraction    */
							/* and by not searching for it, we save cpu time      */

							col_vector[(long)RDB[shadow_mat_ader_iso + ADER_MAT_ISO_BURN_INDEX]] += fabs(lambda) * adens_corr_factor;

							break;

						}

						shadow_mat_ader_iso = NextItem(shadow_mat_ader_iso);

					}

				}

				/* Each prop stream can only have one entry for any given isotope,*/
				/* so break                                                       */

				break;

			}

			ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessburnmatrixtransmutationanddecay.c   */
/*                                                                           */
/* Created:       2016/29/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fills transmutation effects for isotope and its products     */
/*              Also handles decay effects                                   */
/*                                                                           */
/* Comments: This function is called from ADERMakeBurnMatrix                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessBurnMatrixTransmutationAndDecay"

void ADERProcessBurnMatrixTransmutationAndDecay(long ader_mat_iso,
		                                        double* col_vector,
		                                        long mat, double mat_flux,
												long nuc, long omp_id, long rea,
												long reaction_product_nuc,
												long type)
{

	double micro_cross_section = 0, reaction_rate = 0;
	long ader_mat_iso_product_index = 0;

	/* If this reaction is a decay reaction, set the reaction rate            */

	if((type == REACTION_TYPE_DECAY) ||
	   (type == REACTION_TYPE_DEC_BRANCH))
	{

		/* The branching ratio is purposefully left out here because it must  */
		/* be left out below, see below comment for reason. The branching     */
		/* ratio will be included when the vector values are adjusted         */

		reaction_rate = RDB[nuc + NUCLIDE_LAMBDA];

		/* Go ahead and add this removal rate to the isotope's own            */
		/* production/destruction rate, but only if it is not a branch rea    */

		if(type == REACTION_TYPE_DECAY)
		{

			col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] -= reaction_rate *
					                                                         RDB[rea + REACTION_BR];

		}

	}
	else if((type == REACTION_TYPE_PARTIAL) ||
            (type == REACTION_TYPE_TRA_BRANCH))
	{

		/* If this reaction is a transmutation reaction get the rate          */

		micro_cross_section = GetPrivateData(((long)RDB[rea + REACTION_PTR_TRANSMUXS]) + 1,
				                             omp_id);

		/* Make sure a physical answer is provided                           */

		if(micro_cross_section > 0.0)
		{

			/* The branching ratio is purposefully left out here thanks to how*/
			/*the reactions are tabulated                                     */

			reaction_rate = micro_cross_section * mat_flux *
					        BARN;

			/* Go ahead and add this removal rate to the isotope's own            */
			/* production/destruction rate, but only if it is not a branch rea    */

			if(type == REACTION_TYPE_PARTIAL)
			{

				col_vector[(long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX]] -= reaction_rate;

			}

		}
		else
		{

			/* The cross section is not real                                  */

			reaction_rate = 0.0;

		}

	}

	/* Get the product ader isotope index IN THIS MATERIAL                    */

	ader_mat_iso_product_index = ADERGetIsoBurnMatrixIndex(FUNCTION_NAME,
			                                               mat,
											               reaction_product_nuc);

	/* Now add the production rate for the product isotope                    */

	col_vector[ader_mat_iso_product_index] += reaction_rate *
			                                  RDB[rea + REACTION_BR];

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderclustermems.c           */
/*                                                                           */
/* Created:       2016/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Gets material indices for every material in an ader cluster  */
/*              Assigns this information to the mat ader data that was passed*/
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderClusters     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialAderClusterMems:"

void ADERProcessMaterialAderClusterMems(long ader_cluster, long mat_ader_data)
{

    long ader_cluster_ent = 0, mat = 0, mat_cluster_mem = 0;

    ader_cluster_ent = (long)RDB[ader_cluster + ADER_CLUSTER_ENT_PTR];

    while(ader_cluster_ent > VALID_PTR)
    {

        mat = (long)RDB[DATA_PTR_M0];

        while(mat > VALID_PTR)
        {

            if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                      GetText(ader_cluster_ent + ADER_CLUSTER_ENT_ID)) == 0)
            {

                /* For every member of the cluster, provide the new member */
                /* (who's ader data we have passed in ) with all the other */
                /* cluster member's indices */

                mat_cluster_mem = NewItem(mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR,
                                          ADER_MAT_CLUSTER_MEM_BLOCK_SIZE);

                WDB[mat_cluster_mem + ADER_MAT_CLUSTER_MEM_PTR] = mat;

                break;

            }

            mat = NextItem(mat);

        }

        ader_cluster_ent = NextItem(ader_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderclusterparent.c         */
/*                                                                           */
/* Created:       2016/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Searches materials for one whose id matches the selected     */
/*              cluster parent id. Sets this material's index to the parent  */
/*              pointer for the given material ader data block               */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderClusters     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialAderClusterParent:"

void ADERProcessMaterialAderClusterParent(long ader_cluster, long mat_ader_data)
{

    long mat = 0;

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp(GetText(mat + MATERIAL_PTR_NAME),
                  GetText(ader_cluster + ADER_CLUSTER_PARENT_ID)) == 0)
        {

            /* find the material who's name matches that of the ader parent */
            /* store this mat's pointer in the current mat's ader data */

            WDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR] = mat;

            break;

        }

        mat = NextItem(mat);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderclusters.c              */
/*                                                                           */
/* Created:       2016/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Searches ader clusters to see if current mat is a member     */
/*              If so the cluster, and its parent, are added to the materials*/
/*              ADER data.                                                   */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialAderClusters:"

void ADERProcessMaterialAderClusters(long mat)
{

    char *mat_id = NULL;
    long ader_cluster = 0, ader_cluster_ent = 0, ader_data = 0, mat_ader_data = 0;
    long found = 0;

    mat_id = GetText(mat + MATERIAL_PTR_NAME);

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_cluster = (long)RDB[ader_data + ADER_CLUSTERS_PTR];

    while(ader_cluster > VALID_PTR)
    {

        /* If this is not a voided ader cluster (ie, has been merged ) */
        /* see if it fits this material */

        if(strncmp("VOID", GetText(ader_cluster + ADER_CLUSTER_PARENT_ID), 4) != 0)
        {

            /* If the parent of this cluster is this material, save this material */
            /* as its own parent and create it's cluster list */

            if(strcmp(mat_id, GetText(ader_cluster + ADER_CLUSTER_PARENT_ID)) == 0)
            {

                WDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR] = (double)mat;

                ADERProcessMaterialAderClusterMems(ader_cluster, mat_ader_data);

                break;

            }

            ader_cluster_ent = (long)RDB[ader_cluster + ADER_CLUSTER_ENT_PTR];

            while(ader_cluster_ent > VALID_PTR)
            {

                /* Go through the cluster's members, if this material matches */
                /* one, give it its parent pointer and add itself to the list */

                if(strcmp(mat_id, GetText(ader_cluster_ent + ADER_CLUSTER_ENT_ID)) == 0)
                {

                    ADERProcessMaterialAderClusterParent(ader_cluster, mat_ader_data);

                    ADERProcessMaterialAderClusterMems(ader_cluster, mat_ader_data);

                    found = 1;

                }

                ader_cluster_ent = NextItem(ader_cluster_ent);

            }

            if(found == 1)
            {

                /* If you've already found where the material belongs, quite searching! */

                break;

            }

        }

        ader_cluster = NextItem(ader_cluster);

    }
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialadercndcntdata.c            */
/*                                                                           */
/* Created:       2015/1/2 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link read in ader conditions controlled   */
/*              item data with the appropriate material                      */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialConditions      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderCndCntData:"

void ADERProcessMaterialAderCndCntData(long ader_cnd_cnt, long mat)
{

    char *ader_cnd_cnt_id = 0, *ader_cnt_id = 0;
    long ader_cnt = 0, ader_data = 0, ader_mat_cnt = 0, mat_ader_data = 0;

    ader_cnd_cnt_id = GetText(ader_cnd_cnt + ADER_CND_CNT_ID);

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_cnt = (long)RDB[ader_data + ADER_CONTROL_PTR];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    while(ader_cnt > VALID_PTR)
    {

        ader_cnt_id = GetText(ader_cnt + ADER_CONTROL_TBL_ID);

        if(strcmp(ader_cnd_cnt_id, ader_cnt_id) == 0)
        {

            /* if found the matching control table give the material a pointer */
            /* to its data */

            ader_mat_cnt = NewItem(mat_ader_data + ADER_MAT_CNT_TBLS_PTR,
                                   ADER_MAT_CNT_ENT_BLOCK_SIZE);

            WDB[ader_mat_cnt + ADER_MAT_CNT_TBL_PTR] = ader_cnt;

            break;

        }

        ader_cnt = NextItem(ader_cnt);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialadercnddata.c            */
/*                                                                           */
/* Created:       2015/12/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Assigns ader condition entries to material composition groups*/
/*              If no composition group exists, it calls                     */
/*              ADERProcessMaterialCndGroupData to create the composition    */
/*              group and then calls itself again to assign the condition.   */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialConditions      */
/*          and itself.                                                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderCndData:"

void ADERProcessMaterialAderCndData(long ader_cnd_ent, char *ader_type, long mat)
{

    char *ader_cnd_ent_grp_id = NULL, *ader_mat_cmp_id = NULL;
    long ader_mat_cmp = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the name of the group which has conditions which are being processed */

    if(strncmp("range", ader_type, 5) == 0)
    {

        ader_cnd_ent_grp_id = GetText(ader_cnd_ent + ADER_CND_RNG_GRP_ID);

    }
    else if(strncmp("ratio", ader_type, 5) == 0)
    {

        ader_cnd_ent_grp_id = GetText(ader_cnd_ent + ADER_CND_RTO_GRP1_ID);

    }
    else
    {

        Die(FUNCTION_NAME, "ader_type pased to ADERProcessMaterialCndData is not of string 'range' or 'ratio'.\n");

    }

    ader_mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    /* check to see if that group already has an entry in that material */

    while(ader_mat_cmp > VALID_PTR)
    {

        ader_mat_cmp_id = GetText(ader_mat_cmp + ADER_MAT_CMP_ID);

        if(strcmp(ader_cnd_ent_grp_id, ader_mat_cmp_id) == 0)
        {

            /* if name matches attach the cnd data to the material cmp group */

            if(strncmp("range", ader_type, 5) == 0)
            {

                ADERProcessMaterialCndRngData(ader_cnd_ent, ader_mat_cmp, mat);

                return;

            }
            else if(strncmp("ratio", ader_type, 5) == 0)
            {

                ADERProcessMaterialCndRtoData(ader_cnd_ent, ader_mat_cmp, mat);

                return;

            }
            else
            {

                Die(FUNCTION_NAME, "ader_type of %s did not match either \n \
'range' or 'ratio' for ader_cnd_ent_grp_id of %s and ader_mat_cmp_id of \
%s.\n", ader_type, ader_cnd_ent_grp_id, ader_mat_cmp_id);

            }

        }

        ader_mat_cmp = NextItem(ader_mat_cmp);

    }

    /* If not, create the entry, call again to process the ader_cnd_ent */

    ADERProcessMaterialCndGroupData(ader_cnd_ent_grp_id,
                                    mat);

    ADERProcessMaterialAderCndData(ader_cnd_ent, ader_type, mat);

    return;

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialadercndoptdata.c            */
/*                                                                           */
/* Created:       2015/1/2 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Copies CND opt data to a material. Checks user input.        */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialConditions      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderCndOptData:"

void ADERProcessMaterialAderCndOptData(long ader_cnd_opt, long mat)
{

    long ader_mat_opt = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if((long)RDB[mat_ader_data + ADER_MAT_OPT_PTR] > VALID_PTR)
    {

        Error(0, "Attempting to add a SECOND 'opt' entry from a conditions block \n \
to material %s. A material may only have one 'opt' entry from a conditions block \n \
assigned to it. Additionally, an ADER 'cluster'* may only have one material with \n \
an 'opt' entry.\n \n *An ADER 'cluster' is a group of materials which are connected \n \
with ADER 'stream' entries. I.e., materials which are sources and sinks for one another.\n",
             GetText(mat + MATERIAL_PTR_NAME));

    }

    /* copy that optimization data! */

    ader_mat_opt = NewItem(mat_ader_data + ADER_MAT_OPT_PTR,
                           ADER_MAT_OPT_BLOCK_SIZE);

    WDB[ader_mat_opt + ADER_MAT_OPT_DIR] = RDB[ader_cnd_opt + ADER_CND_OPT_DIR];

    WDB[ader_mat_opt + ADER_MAT_OPT_TYPE] = RDB[ader_cnd_opt + ADER_CND_OPT_TYPE];

    WDB[ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET] = RDB[ader_cnd_opt + ADER_CND_OPT_TYPE_TARGET];

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialadercndoxidata.c            */
/*                                                                           */
/* Created:       2015/1/2 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link read in ader conditions              */
/*              oxidation data with the appropriate material                 */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialConditions      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderCndOxiData:"

void ADERProcessMaterialAderCndOxiData(long ader_cnd_oxi, long mat)
{

    char *ader_cnd_oxi_id = NULL, *ader_first_oxi_id = NULL, *ader_oxi_id = NULL;
    long ader_data, ader_first_oxi = 0, ader_mat_oxi = 0, ader_oxi = 0;
    long mat_ader_data = 0;

    ader_cnd_oxi_id = GetText(ader_cnd_oxi + ADER_CND_OXI_ID);

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_oxi = (long)RDB[ader_data + ADER_OXIS_PTR];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    while(ader_oxi > VALID_PTR)
    {

        /* Find the desired ader oxidation table */

        ader_oxi_id = GetText(ader_oxi + ADER_OXI_TBL_ID);

        if(strcmp(ader_cnd_oxi_id, ader_oxi_id) == 0)
        {

            /* It's a match! Process it! ( Mats are only allowed one oxidation */
            /* table so error out if there is already one */

            if((long)RDB[mat_ader_data + ADER_MAT_OXI_PTR] > VALID_PTR)
            {

                ader_mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

                ader_first_oxi = (long)RDB[ader_mat_oxi + ADER_MAT_OXI_PTR];

                ader_first_oxi_id = GetText(ader_first_oxi + ADER_OXI_TBL_ID);

                Error(0, "Attempting to add oxidation table %s \n \
to material ader data for material %s. Material %s already has oxidation table \n \
%s. Materials are only allowed one oxidation table.\n",
                      ader_oxi_id, GetText(mat + MATERIAL_PTR_NAME),
                      GetText(mat + MATERIAL_PTR_NAME), ader_first_oxi_id);

            }

            ader_mat_oxi = NewItem(mat_ader_data + ADER_MAT_OXI_PTR,
                                   ADER_MAT_OXI_BLOCK_SIZE);

            WDB[ader_mat_oxi + ADER_MAT_OXI_TBL_PTR] = ader_oxi;

            WDB[ader_mat_oxi + ADER_MAT_OXI_MAX] = RDB[ader_cnd_oxi + ADER_CND_OXI_MAX];

            WDB[ader_mat_oxi + ADER_MAT_OXI_MIN] = RDB[ader_cnd_oxi + ADER_CND_OXI_MIN];

            break;

        }

        ader_oxi = NextItem(ader_oxi);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialadercndpresdata.c           */
/*                                                                           */
/* Created:       2016/3/20 (DDW)                                            */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Copies CND pres data to a material. Checks user input.       */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialConditions      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderCndPresData:"

void ADERProcessMaterialAderCndPresData(long ader_cnd_pres, long mat)
{

    long ader_mat_preserve = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* copy that preserve data! */

    ader_mat_preserve = NewItem(mat_ader_data + ADER_MAT_PRESERVES_PTR,
                               ADER_MAT_PRESERVE_BLOCK_SIZE);

    WDB[ader_mat_preserve + ADER_MAT_PRESERVE_ENT] = RDB[ader_cnd_pres + ADER_CND_PRES_ENT];

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderdata.c                  */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link read in ader data with the           */
/*              appropriate materials                                        */
/*                                                                           */
/* Comments:This function is called from ProcessMaterials                    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialAderData:"

void ADERProcessMaterialAderData()
{

    long mat = 0;

    fprintf(outp, "Processing ADER data and allocating memory.\n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR)
        {

        	if((long)RDB[DATA_BURN_BUMODE] == BUMODE_TTA)
        	{

        		Warn(FUNCTION_NAME, "ADER material burnup simulations may only \n\
be completed using the CRAM burn matrix solution methodology.\n\
TTA was set by the user but has been overridden by ADER to CRAM.\n");


        		WDB[DATA_BURN_BUMODE] = (double)BUMODE_CRAM;

        	}

            if(((long)RDB[mat + MATERIAL_BURN_RINGS] > VALID_PTR) ||
               ((long)RDB[mat + MATERIAL_BURN_RINGS] > 0) ||
               ((long)RDB[mat + MATERIAL_PTR_DIV] > VALID_PTR))
            {

                /* ADER is not compatible with divided materials */

                Error(0, "Use of the ADER components of SERPENT is not \n \
compatible with 'divided'* materials in SERPENT. \n \
Material %s is both an ADER material and a divided material. \n \
*['divided' materials are those which have been given an integer number \n \
, greater than 0, following the 'burn' entry in the material definition card, \n \
or those materials which were created from parent materials defined with the \n \
'burn' card followed by an integer.\n", GetText(mat + MATERIAL_PTR_NAME));

            }

            ADERProcessMaterialAderClusters(mat);

            ADERCheckMaterialClusterIsotopes(mat);

            ADERProcessMaterialConditions(mat);

            ADERProcessMaterialStreams(mat);

            ADERLinkMaterialIsotopeIndices(mat);

        }

        mat = NextItem(mat);

    }

    /* Now we loop through the materials again as these next set of processing*/
    /* functions requires that all ADER materials already have been processed */
    /* with the above functions.                                              */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR)
        {

            ADERProcessMaterialShadowStreams(mat);

            ADERProcessMaterialClusterOptEntry(mat);

        }

        mat = NextItem(mat);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR)
        {

            ADERCheckMaterialRemovalTables(mat, 0);

            ADERCreateMaterialCompMatrix(mat);

        }

        mat = NextItem(mat);

    }

    /* Send out the below while loop to differing threads. If a material      */
    /* doesn't belong to a thread it will get skipped                         */

#ifdef OPEN_MP
#pragma omp parallel private(mat)
#endif
    {

		mat = (long)RDB[DATA_PTR_M0];

		while(mat > VALID_PTR)
		{

			if(MyParallelMat(mat, NO) == NO)
			{

				mat = NextItem(mat);

				continue;

			}

			if((long)RDB[mat + MATERIAL_ADER_DATA] > VALID_PTR)
			{

				if((long)RDB[(long)RDB[mat + MATERIAL_ADER_DATA] + ADER_MAT_MATRIX_PTR] > VALID_PTR)
				{

#ifdef ADER_INT_TEST
#ifdef OPEN_MP

				fprintf(outp, "ADER Thread %d reporting in!\n", OMP_THREAD_NUM);

#endif
#endif

					ADERFillMaterialCompMatrix(mat);

				}

			}

			mat = NextItem(mat);

		}

#ifdef OPEN_MP
#pragma omp barrier
#endif


    }

    fprintf(outp, "OK.\n\n");

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderisosdata.c              */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates ADER_MAT_ISO entry for every iso in a material       */
/*                                                                           */
/* Comments: This function is called from ADERLinkMaterialIsostopeIndicies   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialAderIsosData:"

void ADERProcessMaterialAderIsosData(long mat)
{

    long i = 0, iso = 0, mat_ader_data = 0, mat_ader_ele = 0, mat_ader_ele_iso = 0, mat_ader_iso = 0;
    long nuc = 0, z = 0, zai = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* loop through all of a materials isotopes */

    iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(iso > VALID_PTR)
    {

        nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

        z = (long)RDB[nuc + NUCLIDE_Z];

        zai = (long)RDB[nuc + NUCLIDE_ZAI];

        /* protect against fake burnup isotope */

        if(zai == -1)
        {

            iso = NextItem(iso);

            continue;

        }

        /* Create an iso list entry for every iso in a material */

        mat_ader_iso = NewItem(mat_ader_data + ADER_MAT_ISOS_PTR,
                               ADER_MAT_ISOS_BLOCK_SIZE);

        WDB[mat_ader_iso + ADER_MAT_ISO_PTR] = (double)iso;

        /* Now, we need to find the element which corresponds to this isotope */
        /* Create an isotope entry for that element, and give it the ptr      */

        mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

        for(i = 0; i < (z - 1); i++)
        {

            mat_ader_ele = NextItem(mat_ader_ele);

        }

        mat_ader_ele_iso = NewItem(mat_ader_ele + ADER_MAT_ELE_ISOS_PTR,
                                   ADER_MAT_ELE_ISO_BLOCK_SIZE);

        WDB[mat_ader_ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR] = (double)mat_ader_iso;

        iso = NextItem(iso);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialclusteroptentry.c           */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material cluster to ensure that the parent   */
/*              is given the optimization data. Errors when appropriate      */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialClusterOptEntry:"

void ADERProcessMaterialClusterOptEntry(long mat)
{

    long ader_mat_cluster_ent = 0, ader_mat_cluster_mem = 0, ader_mat_opt = 0;
    long ader_parent_mat_opt = 0, mat_ader_data = 0, parent_mat_ader_data = 0;

    parent_mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* We only want to process for the parent of a cluster, so skip if this mat*/
    /* is not a cluster parent                                                */

    if(mat != (long)RDB[parent_mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR])
    {

        return;

    }

    /* Loop through the cluster members                                       */

    ader_mat_cluster_ent = (long)RDB[parent_mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

        ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        if(ader_mat_cluster_mem == mat)
        {

            /* Again, not trying to process the parent, so skip if the cluster*/
            /* mem is the parent                                              */

            ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

            continue;

        }

        mat_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

        ader_mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

        /* If this cluster member has an opt entry, go ahead and check the    */
        /* parent                                                             */

        if(ader_mat_opt > VALID_PTR)
        {

            /* IF the parent already has an opt entry this is a user error    */

            if((long)RDB[parent_mat_ader_data + ADER_MAT_OPT_PTR] > VALID_PTR)
            {

                Error(0, "Parent material, %s, already has an opt entry*.\n \
Cluster** member material, %s, also has an opt entry. Only one opt entry is\n \
is allowed per cluster. This may not be the only excess opt entry. ADER errors\n \
on first multiple opt entry.\n\n *ADER searches a cluster for all opt entries.\n \
If a parent material in a cluster doesn't already have an opt entry and one is \n \
found in a cluster it is attached to the parent. As such, it is possible that \n \
the multiple opt entries ( causing the error ) were never originally associated \n \
with the parent material in the input file but rather with cluster members.\n \
Please check all materials in this cluster.\n\n \
** An ADER 'cluster' is a group of materials which are connected with ADER\n \
'stream' entries. I.e., materials which are sources and sinks for one another.\n",
                      GetText(mat + MATERIAL_PTR_NAME),
                      GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

            }
            else
            {

                /* Otherwise, give the current cluster mem opt data to the    */
                /* parent so that it may be incorporated into the matrix      */

                ader_parent_mat_opt = NewItem(parent_mat_ader_data + ADER_MAT_OPT_PTR,
                                              ADER_MAT_OPT_BLOCK_SIZE);

                WDB[ader_parent_mat_opt + ADER_MAT_OPT_DIR] = RDB[ader_mat_opt + ADER_MAT_OPT_DIR];

                WDB[ader_parent_mat_opt + ADER_MAT_OPT_TYPE] = RDB[ader_mat_opt + ADER_MAT_OPT_TYPE];

                WDB[ader_parent_mat_opt + ADER_MAT_OPT_TYPE_TARGET] = RDB[ader_mat_opt + ADER_MAT_OPT_TYPE_TARGET];

            }

        }

        ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialcndgroupdata.c              */
/*                                                                           */
/* Created:       2015/12/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles the linking of group data to material comp lists     */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialCndData and by   */
/*          itself, as well as ADERProcessMaterialCndRtoData.                */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialCndGroupData:"

long ADERProcessMaterialCndGroupData(char *ader_grp_id, long mat)
{

    char *ader_grp_sum_grp_id = NULL, *ader_mat_cmp_id = NULL, *ader_root_grp_id = NULL;
    long ader_data, ader_root_grp = 0, ader_grp_sum_grp_data = 0, ader_mat_cmp = 0;
    long ader_mat_cmp_ele_ptr = 0, ader_mat_cmp_iso_ptr = 0, ader_mat_cmp_sum_grp = 0;
    long ader_mat_data = 0, dep = 0, i = 0;
    long found = 0, total_steps = 0;

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cmp = (long)RDB[ader_mat_data + ADER_MAT_CMPS_PTR];

    while(ader_mat_cmp > VALID_PTR)
    {

        ader_mat_cmp_id = GetText(ader_mat_cmp + ADER_MAT_CMP_ID);

        if(strcmp(ader_mat_cmp_id, ader_grp_id) == 0)
        {

            /* This was a recursive call from ADERProcessCndGroupSumGroups or */
            /* From the rto processor. All these need are the index of the */
            /* desired group */

            return(ader_mat_cmp);

        }

        ader_mat_cmp = NextItem(ader_mat_cmp);

    }

    /* if the group hasn't already been added to the material cmp group's data */
    /* Do so */

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_root_grp = (long)RDB[ader_data + ADER_GROUPS_PTR];

    while(ader_root_grp > VALID_PTR)
    {

        ader_root_grp_id = GetText(ader_root_grp + ADER_GRP_ID);

        if(strcmp(ader_root_grp_id, ader_grp_id) == 0)
        {

            /* Search through ader groups, if it's name matches that of the */
            /* desired group, process it into the material */

            found = 1;

            ader_mat_cmp = NewItem(ader_mat_data + ADER_MAT_CMPS_PTR,
                                   ADER_MAT_CMP_BLOCK_SIZE);

            WDB[ader_mat_cmp + ADER_MAT_CMP_ID] = RDB[ader_root_grp + ADER_GRP_ID];

            WDB[ader_mat_cmp + ADER_MAT_CMP_GRP_PTR] = (double)ader_root_grp;

            /* Go ahead and give this grp data slots for its future burn data */
            /* First we need to count the total number of steps               */

            dep = (long)RDB[DATA_BURN_PTR_DEP];

            while(dep > VALID_PTR)
            {

            	total_steps = total_steps + (long)RDB[dep + DEP_HIS_N_STEPS];

            	dep = NextItem(dep);

            }

            /* Add a step for the final burn interval                         */

            total_steps++;

            /* Now actually create the burn value data holders                */

            for(i = 0; i < total_steps; i++)
            {

            	NewItem(ader_mat_cmp + ADER_MAT_CMP_BURN_STEPS_PTR,
            			ADER_MAT_GRP_BURN_STEP_BLOCK_SIZE);

            }

            /* YOU ARE PASSING THE INDEX NOT THE VALUE AT THE INDEX!!! (next 2) */

            ader_mat_cmp_ele_ptr = (long)(ader_mat_cmp + ADER_MAT_CMP_ELES_PTR);

            ader_mat_cmp_iso_ptr = (long)(ader_mat_cmp + ADER_MAT_CMP_ISOS_PTR);

            ADERProcessMaterialGroupComposition(ader_root_grp,
                                                ader_mat_cmp_ele_ptr,
                                                ader_mat_cmp_iso_ptr,
                                                0, mat, 0);

            ader_grp_sum_grp_data = (long)RDB[ader_root_grp +
                                              ADER_GRP_SUM_GRPS_PTR];

            while(ader_grp_sum_grp_data > VALID_PTR)
            {

                /* If the group has summation groups, process these */

                ader_mat_cmp_sum_grp = NewItem(ader_mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR,
                                               ADER_MAT_GRP_SUM_GRP_BLOCK_SIZE);

                ader_grp_sum_grp_id = GetText(ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_ID);

                WDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_ID] = RDB[ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_ID];

                WDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_WEIGHT] = RDB[ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_WEIGHT];

                WDB[ader_mat_cmp_sum_grp + ADER_MAT_GRP_SUM_GRP_PTR] = (double)ADERProcessMaterialCndGroupData(ader_grp_sum_grp_id, mat);

                ader_grp_sum_grp_data = NextItem(ader_grp_sum_grp_data);

            }

            break;

        }

        ader_root_grp = NextItem(ader_root_grp);

    }

    if(found == 0)
    {

        Error(0, "No matching group definition for ADER conditions entry involving group %s.\n \
WARNING: This may be a recursive call and the named group may be a nested \n \
summation group of another group.\n",
              ader_grp_id);

    }

    return(ader_mat_cmp);

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialcndrngdata.c                */
/*                                                                           */
/* Created:       2016/1/1 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Assigns ader range condition entries to material composition */
/*              groups.                                                      */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialCndData      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialCndRngData:"

void ADERProcessMaterialCndRngData(long ader_cnd_rng, long ader_mat_cmp,
                                   long mat)
{

    char *ader_cnd_rng_grp_id = NULL, *mat_id = NULL;
    long ader_mat_cmp_rng = 0;

    if(RDB[ader_mat_cmp + ADER_MAT_CMP_RNG_PTR] > VALID_PTR)
    {

        ader_cnd_rng_grp_id = GetText(ader_cnd_rng + ADER_CND_RNG_GRP_ID);

        mat_id = GetText(mat + MATERIAL_PTR_NAME);

        Error(0, "More than one range condition entered for group %s \n \
in material %s.\n", ader_cnd_rng_grp_id, mat_id);

    }

    /* Add new range data to a material cmp group */

    ader_mat_cmp_rng = NewItem(ader_mat_cmp + ADER_MAT_CMP_RNG_PTR,
                               ADER_MAT_CMP_RNG_BLOCK_SIZE);

    WDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MAX] = RDB[ader_cnd_rng +
                                                       ADER_CND_RNG_MAX];

    WDB[ader_mat_cmp_rng + ADER_MAT_CMP_RNG_MIN] = RDB[ader_cnd_rng +
                                                           ADER_CND_RNG_MIN];


}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialcndrtodata.c                */
/*                                                                           */
/* Created:       2016/1/2 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Assigns ader ratio condition entries to material composition */
/*              groups.                                                      */
/*                                                                           */
/* Comments: This function is called from ADERProcessMaterialCndCmpData      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialCndRtoData:"

void ADERProcessMaterialCndRtoData(long ader_cnd_rto, long ader_mat_cmp,
                                   long mat)
{

    char *ader_cnd_rto_grp2_id = NULL;
    long ader_mat_cmp_rto = 0;

    /* Add an rto entry to a material composition control group */

    ader_mat_cmp_rto = NewItem(ader_mat_cmp + ADER_MAT_CMP_RTOS_PTR,
                               ADER_MAT_CMP_RTO_BLOCK_SIZE);

    WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MAX] = RDB[ader_cnd_rto +
                                                       ADER_CND_RTO_MAX];

    WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_MIN] = RDB[ader_cnd_rto +
                                                           ADER_CND_RTO_MIN];

    ader_cnd_rto_grp2_id = GetText(ader_cnd_rto + ADER_CND_RTO_GRP2_ID);

    /* Provide index of the other group involved in this ratio */

    WDB[ader_mat_cmp_rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR] = (double)ADERProcessMaterialCndGroupData(ader_cnd_rto_grp2_id, mat);

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialaderconditions.c            */
/*                                                                           */
/* Created:       2015/12/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link read in ader conditions data with    */
/*              the appropriate material                                     */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessAderMaterialConditions:"

void ADERProcessMaterialConditions(long mat)
{

    char *ader_cnd_id = NULL, *ader_mat_cnd_id = NULL;
    char ader_type[10];
    long ader_data = 0, ader_cnd = 0, ader_cnd_cnt = 0, ader_cnd_rng = 0, ader_cnd_rto = 0;
    long ader_cnd_opt = 0, ader_cnd_oxi = 0, ader_cnd_pres = 0, ader_mat_cnd = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cnd = (long)RDB[mat_ader_data + ADER_MAT_CNDS_PTR];

    ader_data = (long)RDB[DATA_PTR_ADER];

    /* Loop through all ader conditions blocks. If the block id matches */
    /* A condition block id stored for the material ( from its input defintion */
    /* Then add this condition's data to the material */

    while(ader_mat_cnd > VALID_PTR)
    {

        ader_mat_cnd_id = GetText(ader_mat_cnd + ADER_MAT_CND_ID);

        ader_cnd = (long)RDB[ader_data + ADER_CONDITIONS_PTR];

        while(ader_cnd > VALID_PTR)
        {

            ader_cnd_id = GetText(ader_cnd + ADER_CND_ID);

            if(strcmp(ader_cnd_id, ader_mat_cnd_id) == 0)
            {

                /* IT matches, go through its components and process them into */
                /* the material */

                WDB[ader_mat_cnd + ADER_MAT_CND_PTR] = (double)ader_cnd;

                ader_cnd_cnt = (long)RDB[ader_cnd + ADER_CND_CNT_PTR];

                ader_cnd_rng = (long)RDB[ader_cnd + ADER_CND_RNGS_PTR];

                ader_cnd_rto = (long)RDB[ader_cnd + ADER_CND_RTOS_PTR];

                ader_cnd_opt = (long)RDB[ader_cnd + ADER_CND_OPT_PTR];

                ader_cnd_oxi = (long)RDB[ader_cnd + ADER_CND_OXI_PTR];

                ader_cnd_pres = (long)RDB[ader_cnd + ADER_CND_PRES_PTR];

                while(ader_cnd_cnt > VALID_PTR)
                {

                    ADERProcessMaterialAderCndCntData(ader_cnd_cnt, mat);

                    ader_cnd_cnt = NextItem(ader_cnd_cnt);

                }

                while(ader_cnd_rng > VALID_PTR)
                {

                    sprintf(ader_type, "range");

                    ADERProcessMaterialAderCndData(ader_cnd_rng, ader_type, mat);

                    ader_cnd_rng = NextItem(ader_cnd_rng);

                }

                while(ader_cnd_rto > VALID_PTR)
                {

                    sprintf(ader_type, "ratio");

                    ADERProcessMaterialAderCndData(ader_cnd_rto, ader_type, mat);

                    ader_cnd_rto = NextItem(ader_cnd_rto);

                }

                while(ader_cnd_opt > VALID_PTR)
                {

                    ADERProcessMaterialAderCndOptData(ader_cnd_opt, mat);

                    ader_cnd_opt = NextItem(ader_cnd_opt);

                }

                while(ader_cnd_oxi > VALID_PTR)
                {

                    ADERProcessMaterialAderCndOxiData(ader_cnd_oxi, mat);

                    ader_cnd_oxi = NextItem(ader_cnd_oxi);

                }

                while(ader_cnd_pres > VALID_PTR)
                {

                    ADERProcessMaterialAderCndPresData(ader_cnd_pres, mat);

                    ader_cnd_pres = NextItem(ader_cnd_pres);

                }

            }

            ader_cnd = NextItem(ader_cnd);

        }

        ader_mat_cnd = NextItem(ader_mat_cnd);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialdiscstreameffects.c         */
/*                                                                           */
/* Created:       2016/10/19 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Actually updates a material's isotopic composition and       */
/*              density based on disc stream effects                         */
/*                                                                           */
/* Comments:This function is called from ADERUpdateMaterialDiscStreamEffects */
/*                                       ADERProcessMaterialDiscStreamEffects*/
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialDiscStreamEffects:"

void ADERProcessMaterialDiscStreamEffects(long ader_mat_stream, long adj,
		                                  long i, long mat)
{

	double src_mat_adens = 0, sign = 0, stream_iso_transfer_amount = 0;
	double stream_transfer_amount = 0;
	long ader_mat_iso = 0;
    long ader_mat_shadow = 0, ader_mat_src_mat = 0, ader_mat_stream_iso = 0;
    long ader_mat_sum_stream = 0, ader_mat_sum_stream_ent = 0, mat_ader_data = 0, mat_iso = 0;
    long src_mat_ader_data = 0;
    long rem_stream = 0;

    /* If this is a rem type stream and this is an adjustment cycle, skip this*/
    /* stream                                                                 */

    if(strncmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE), 3) == 0)
    {

    	rem_stream = 1;

    	if((adj > 0) || (i > 0))
    	{

        	return;

    	}

    }

    /* If this stream has summation streams, they contain the relevant info   */
    /* Ignore the parent stream and deal with the sum streams                 */

    ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    if(ader_mat_sum_stream_ent > VALID_PTR)
    {

    	while(ader_mat_sum_stream_ent > VALID_PTR)
    	{

    		ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

    		ADERProcessMaterialDiscStreamEffects(ader_mat_sum_stream, adj, i, mat);

    		ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);

    	}

    	return;

    }

    /* A material adens is needed to calculate the stream amounts. Get the    */
    /* adens from the source material. If this stream has a positive shadow   */
    /* pointer it has a separate source material. If not, it is the "source"  */
    /* even if it receiving material, it is the source because its atomic     */
    /* density is used for the stream amount calculation                      */

    if(rem_stream > 0)
    {

    	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    	src_mat_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    }
    else
    {

        ader_mat_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

        if(ader_mat_shadow > VALID_PTR)
        {

        	ader_mat_src_mat = (long)RDB[ader_mat_shadow + ADER_MAT_STREAM_MAT_PTR];

        	src_mat_ader_data = (long)RDB[ader_mat_src_mat + MATERIAL_ADER_DATA];

        	src_mat_adens = RDB[src_mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

        }
        else
        {

        	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

        	src_mat_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

        }

    }



    /* We need to know if the stream is brining in or taking out material     */

    /* We need to determine if the stream is leaving or entering the material */
    /* This is most easily done by comparing src and dest names               */

    if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
              GetText(mat + MATERIAL_PTR_NAME)) == 0)
    {

        /* Stream is leaving the material                                     */

        sign = -1.0;

    }
    else
    {

        /* Stream is entering the material                                    */

        sign = 1.0;

    }

    /* Store the stream transfer amount to reduce code complexity             */

    if(rem_stream > 0)
    {

    	stream_transfer_amount = sign *
    			                 RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] *
								 src_mat_adens;

    }
    else
    {

        if(adj > 0)
        {

        	stream_transfer_amount = sign *
        			                 RDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] *
    								 src_mat_adens;

        }
        else
        {

        	stream_transfer_amount = sign *
        			                 RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] *
    								 src_mat_adens;

        }

    }

    /* Go ahead and update the material density.                              */

	WDB[mat + MATERIAL_ADENS] = RDB[mat + MATERIAL_ADENS] +
			                    stream_transfer_amount;

	/* Now, loop through the stream isotopes and update the material isotopes */
	/* accordingly                                                            */

	ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

	while(ader_mat_stream_iso > VALID_PTR)
	{

		/* Store the amount of the isotope moved                              */

	    if(rem_stream > 0)
	    {

	    	stream_iso_transfer_amount = sign *
	    			                     RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] *
									     src_mat_adens;

	    }
	    else
	    {

			stream_iso_transfer_amount = stream_transfer_amount *
					                     RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC];

	    }

		ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

		mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

		/* Adjust isotopic adens                                              */

		WDB[mat_iso + COMPOSITION_ADENS] = RDB[mat_iso + COMPOSITION_ADENS] +
				                           stream_iso_transfer_amount;

		ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialgroupcomposition.c          */
/*                                                                           */
/* Created:       2016/1/1 (DDW)                                             */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Handles the linking of group composition data to material    */
/*              comp lists and streams.                                      */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialCndGroupData     */
/*          and by ADERProcessMaterialStreamGroupData                        */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialGroupComposition:"

void ADERProcessMaterialGroupComposition(long ader_grp,
                                         long ader_mat_ent_ele_ptr,
                                         long ader_mat_ent_iso_ptr,
                                         long ele_iso_fix_check,
                                         long mat,
                                         long stream_check)
{

    long ader_grp_comp_ent = 0, ader_grp_comp_iso = 0, ader_mat_ent_ele = 0;
    long ader_mat_ent_ele_iso = 0, ader_mat_ent_iso = 0;

    ader_grp_comp_ent = (long)RDB[ader_grp + ADER_GRP_COMP_PTR];

    while(ader_grp_comp_ent > VALID_PTR)
    {

        /* store the ader group's element data in the appropriate list */

        ader_mat_ent_ele = NewItem(ader_mat_ent_ele_ptr,
                                   ADER_MAT_GRP_ELE_BLOCK_SIZE);

        WDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_FRAC] = RDB[ader_grp_comp_ent + ADER_GRP_COMP_FRAC];

        WDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_Z] = RDB[ader_grp_comp_ent + ADER_GRP_COMP_Z];

        ader_grp_comp_iso = (long)RDB[ader_grp_comp_ent + ADER_GRP_COMP_ISOS_PTR];

        /* Here we check for fixed isotopic composition, for all elements, if */
        /* that requirement has been stated in the passed in parameters       */

        if(ele_iso_fix_check > 0 && ader_grp_comp_iso < VALID_PTR)
        {

            Error(0, "ADER group, %s, has no isotopes listed for element with \n\
Z value of %ld. This ADER group has been used to define an ADER stream. ADER \n \
streams with a destination material and no source material MUST have an      \n \
explicit isotopic composition for each element.\n",
                  GetText(ader_grp + ADER_GRP_ID),
                  (long)RDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_Z]);

        }
        else if(ader_grp_comp_iso > VALID_PTR)
        {

            /* The element in this group has an isotopic composition. Mark    */
            /* this in the grp ele data block                                 */

            WDB[ader_mat_ent_ele + ADER_MAT_GRP_ELE_ISO_FIXED] = 1.0;

        }
        else if(stream_check > 0)
        {

            /* The element in this group has no isotopic composition.         */
            /* Furthermore, this data is for a stream. As such, we must assign*/
            /* every possible isotope, but with no fraction, to this element  */

            ADERProcessMaterialStreamUnFixedEle(ader_mat_ent_ele,
                                                ader_mat_ent_iso_ptr, mat);

        }

        while(ader_grp_comp_iso > VALID_PTR)
        {

            /* If there are isos, store these as well */

            ader_mat_ent_iso = NewItem(ader_mat_ent_iso_ptr,
                                       ADER_MAT_GRP_ISO_BLOCK_SIZE);

            /* Don't forget to give the element a pointer to its isotope */

            ader_mat_ent_ele_iso = NewItem(ader_mat_ent_ele + ADER_MAT_GRP_ELE_ISOS_PTR,
                                           ADER_MAT_GRP_ELE_ISO_BLOCK_SIZE);

            WDB[ader_mat_ent_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] = (double)ader_mat_ent_iso;

            /* now store the iso's information                                */

            WDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = RDB[ader_grp_comp_iso + ADER_GRP_ISO_FRAC];

            WDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_FRAC] = RDB[ader_grp_comp_iso + ADER_GRP_ISO_FRAC] * RDB[ader_grp_comp_ent + ADER_GRP_COMP_FRAC];

            WDB[ader_mat_ent_iso + ADER_MAT_GRP_ISO_ZAI] = RDB[ader_grp_comp_iso + ADER_GRP_ISO_ZAI];

            ader_grp_comp_iso = NextItem(ader_grp_comp_iso);

        }

        ader_grp_comp_ent = NextItem(ader_grp_comp_ent);

    }

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialremovaldata.c                 */
/*                                                                           */
/* Created:       2016/1/20   (DDW)                                          */
/* Last modified: 2016/1/20   (DDW)                                          */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link ader streams, of the 'rem' group     */
/*              type, data with the                                          */
/*              appropriate material and to the appropriate material hook    */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialStreams          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialRemovalData:"

void ADERProcessMaterialRemovalData(long ader_mat_strm, long ader_strm, long mat)
{

    char *ader_rem_id = NULL, *ader_strm_rem_id = NULL;
    long ader_data = 0, ader_rem = 0, dep = 0, i = 0;
    long ele_iso_fix_check = 0, found = 0, total_steps = 0;

    /* Copy over some information about the repro table to a material stream */
    /* structure, repro tables are treated as streams */

    WDB[ader_mat_strm + ADER_MAT_STREAM_PTR] = (double)ader_strm;

    WDB[ader_mat_strm + ADER_MAT_STREAM_MAT_PTR] = (double)mat;

    WDB[ader_mat_strm + ADER_MAT_STREAM_SRC] = RDB[ader_strm + ADER_STREAM_SRC];

    WDB[ader_mat_strm + ADER_MAT_STREAM_DEST] = RDB[ader_strm + ADER_STREAM_DEST];

    WDB[ader_mat_strm + ADER_MAT_STREAM_FORM] = RDB[ader_strm + ADER_STREAM_FORM];

    WDB[ader_mat_strm + ADER_MAT_STREAM_TYPE] = RDB[ader_strm + ADER_STREAM_GRP_TYPE];

    WDB[ader_mat_strm + ADER_MAT_STREAM_ID] = RDB[ader_strm + ADER_STREAM_GRP_ID];

    /* Create the burn data storage space                                     */

    /* Count the number of steps                                              */

    dep = (long)RDB[DATA_BURN_PTR_DEP];

    while(dep > VALID_PTR)
    {

    	total_steps = total_steps + (long)RDB[dep + DEP_HIS_N_STEPS];

    	dep = NextItem(dep);

    }

    /* Add a step for the final burn interval                                 */

    total_steps++;

    /* Now actually create the burn value data holders                        */

    for(i = 0; i < total_steps; i++)
    {

    	NewItem(ader_mat_strm + ADER_MAT_STREAM_BURN_STEPS_PTR,
    			ADER_MAT_GRP_BURN_STEP_BLOCK_SIZE);

    }

    /* We need to determine if this stream has a destination material and no  */
    /* source material                                                        */

    if((strncmp("NULL", GetText(ader_mat_strm + ADER_MAT_STREAM_DEST), 4) != 0) &&
       (strncmp("NULL", GetText(ader_mat_strm + ADER_MAT_STREAM_SRC), 4) == 0))
    {

        /* This is needed by ADERProcessMaterialRemovalEntryData                */

        ele_iso_fix_check = 1;

    }

    ader_strm_rem_id = GetText(ader_strm + ADER_STREAM_GRP_ID);

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_rem = (long)RDB[ader_data + ADER_REPROS_PTR];

    while(ader_rem > VALID_PTR)
    {

        ader_rem_id = GetText(ader_rem + ADER_REPRO_TBL_ID);

        if(strcmp(ader_strm_rem_id, ader_rem_id) == 0)
        {

            /* Find the matching removal table for this stream. Process it */

            found = 1;

            ADERProcessMaterialRemovalEntryData(ader_mat_strm,
            	                                               ader_rem,
                                                               ele_iso_fix_check, mat);

            /* Ensure that all repro isos have an element which they are      */
            /* attached to                                                    */

            ADERProcessMaterialRemovalIsos(ader_mat_strm, mat);

            /* We now call the below function as all removal table elements   */
            /* need corresponding isotope entries for matrix creation purposes*/

            ADERProcessMaterialRemovalEle(ader_mat_strm, mat);

            break;

        }

        ader_rem = NextItem(ader_rem);

    }

    if(found == 0)
    {

        Error(0, "No matching removal table definition for ADER stream entry \n \
involving removal table %s.\n", ader_strm_rem_id);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialremovalele.c                  */
/*                                                                           */
/* Created:       2016/04/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates isotope entries for elements in removal tables       */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialRemovalData        */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialRemovalEle:"

void ADERProcessMaterialRemovalEle(long ader_mat_stream, long mat)
{

    long ader_mat_stream_ele = 0, ader_mat_stream_ele_iso = 0, ader_mat_stream_iso = 0;
    long mat_iso = 0, nuc = 0;
    long found = 0;

    /* loop through this material rem table's elements, they need isotopes    */

    ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

    while(ader_mat_stream_ele > VALID_PTR)
    {

        /* loop through the material's isotopes to find all possible isotopes for */
        /* this element                                                           */

        mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

        while(mat_iso > VALID_PTR)
        {

            nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

            /* We must protect against a fictitious nuclide used in burnup routines */

            if((long)RDB[nuc + NUCLIDE_ZAI] == -1)
            {

                mat_iso = NextItem(mat_iso);

                continue;

            }

            /* if this isotope belongs to this element, go ahead and process it   */

            if((long)RDB[nuc + NUCLIDE_Z] == (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z])
            {

                found += 1;

                /* Now we must check to make sure this isotope was not already    */
                /* added independently from this element. If it was, its value is */
                /* meant to overwrite that from this element                      */

                ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

                while(ader_mat_stream_iso > VALID_PTR)
                {

                    if((long)RDB[nuc + NUCLIDE_ZAI] == (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI])
                    {

                        /* This isotope already exists in the list, and the   */
                    	/* ReproIsos processing function already linked it    */
                    	/* to this element, so break                          */

                        break;

                    }

                    ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

                }

                /* If ader_mat_stream_iso is not a valid pointer, it means one of */
                /* two things. One, there are no isotopes in which case there was */
                /* no isotope already in existence for the isotope we found in the*/
                /* material list. Two, we cycled through the entire list and      */
                /* didn't find a match. Either way, create a new stream isotope   */
                /* entry and link it to the element.                              */

                if(ader_mat_stream_iso < VALID_PTR)
                {

                    /* Create the isotope entry                                       */

                    ader_mat_stream_iso = NewItem(ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR,
                                               ADER_MAT_GRP_ISO_BLOCK_SIZE);

                    /* Create the element's isotope entry                             */

                    ader_mat_stream_ele_iso = NewItem(ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR,
                                                   ADER_MAT_GRP_ELE_ISO_BLOCK_SIZE);

                    /* Give the element a pointer to its new isotope                  */

                    WDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] = (double)ader_mat_stream_iso;

                    /* Populate the isotope's data                                    */

                    WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] = RDB[nuc + NUCLIDE_ZAI];

                    /* We store the element's ( and thus the isotope's ) removal */
                    /* rate in the iso_frac slot. We leave the iso_ele_frac open */
                    /* for future calculation data storage                       */

                    WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_FRAC] = RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC];

                }

            }

            mat_iso = NextItem(mat_iso);

        }

        /* Here we do something interesting. Removal tables are designed to allow */
        /* the user to enter a removal fraction for ALL elements, regardless of   */
        /* Whether or not they are present in the material. Lacking any isotopes  */
        /* at all indicates that the material lacks this element. As such, it     */
        /* should have a 0 removal rate to prevent fictitious removal of it.      */
        /* We avoid warning the user as this could produce copious warnings       */

        if(found < 1)
        {

            WDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] = 0.0;

        }

        ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

    }

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialremovalentrydata.c            */
/*                                                                           */
/* Created:       2016/1/20   (DDW)                                          */
/* Last modified: 2016/1/20   (DDW)                                          */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Links removal entries to a material stream's element and iso   */
/*              lists                                                        */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialRemovalData        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialRemovalEntryData:"

void ADERProcessMaterialRemovalEntryData(long ader_mat_strm, long ader_rem,
                                       long ele_iso_fix_check, long mat)
{

    long ader_mat_strm_ele_ent = 0, ader_mat_strm_iso_ent = 0;
    long ader_rem_entry = 0, ader_rem_entry_z = 0, ader_rem_entry_zai = 0;

    ader_rem_entry = (long)RDB[ader_rem + ADER_REPRO_ENT_PTR];

    while(ader_rem_entry > VALID_PTR)
    {

        ader_rem_entry_z = (long)RDB[ader_rem_entry + ADER_REPRO_ENT_Z];

        ader_rem_entry_zai = (long)RDB[ader_rem_entry + ADER_REPRO_ENT_ZAI];

        if(ader_rem_entry_z > 0)
        {

            /* If the ele_iso_fix_check is enabled, this is an error as all   */
            /* elements in this stream must have an explicit isotopic         */
            /* composition                                                    */

            if(ele_iso_fix_check > 0)
            {

                Error(0, "Element, Z value of %ld, found in removal table %s. \n\
This removal table is part of an ADER stream for which there is a destination \n \
material but no source material. These streams must have an explicit isotopic \n \
composition for every element. In the case of removal tables, this means the \n \
absence of any elemental entries.\n", ader_rem_entry_z,
                      GetText(ader_mat_strm + ADER_MAT_STREAM_ID));

            }

            /* if the removal item is an element, add it to the element list */

            ader_mat_strm_ele_ent = NewItem(ader_mat_strm + ADER_MAT_STREAM_ELES_PTR,
                                            ADER_MAT_GRP_ELE_BLOCK_SIZE);

            WDB[ader_mat_strm_ele_ent + ADER_MAT_GRP_ELE_Z] = RDB[ader_rem_entry + ADER_REPRO_ENT_Z];

            WDB[ader_mat_strm_ele_ent + ADER_MAT_GRP_ELE_FRAC] = RDB[ader_rem_entry + ADER_REPRO_ENT_VAL];

            /* We do not need to set the ADER_MAT_GRP_ELE_ISO_FIXED tag as all*/
            /* elements in a removal table have free isotopic compositions and*/
            /* this is indicated by a value of 0 for this tag which is the    */
            /* default value in the WDB array                                 */

        }
        else if(ader_rem_entry_zai > 0)
        {

			ader_mat_strm_iso_ent = NewItem(ader_mat_strm + ADER_MAT_STREAM_ISOS_PTR,
											ADER_MAT_GRP_ISO_BLOCK_SIZE);

			WDB[ader_mat_strm_iso_ent + ADER_MAT_GRP_ISO_ZAI] = RDB[ader_rem_entry + ADER_REPRO_ENT_ZAI];

			/* We skip assigning to ISO_ELE_FRAC as it has no meaning in the */
			/* removal table scheme. However, this tag will be used to store */
			/* the amount of an isotope removed every time step              */
			/*

			WDB[ader_mat_strm_iso_ent + ADER_MAT_GRP_ISO_ELE_FRAC] = 0.0      */

			WDB[ader_mat_strm_iso_ent + ADER_MAT_GRP_ISO_FRAC] = RDB[ader_rem_entry + ADER_REPRO_ENT_VAL];

        }

        ader_rem_entry = NextItem(ader_rem_entry);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialremovalisos.c                 */
/*                                                                           */
/* Created:       2016/1/20   (DDW)                                          */
/* Last modified: 2016/1/20   (DDW)                                          */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through all rem table isotopes and connects them to    */
/*              parent elements or creates this elements                     */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialRemovalData        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialRemovalIsos:"

void ADERProcessMaterialRemovalIsos(long ader_mat_stream, long mat)
{

	long ader_mat_stream_ele = 0, ader_mat_stream_ele_iso = 0, ader_mat_stream_iso = 0;
	long ader_mat_stream_iso_z = 0, found = 0;

	/* Loop through the stream's isotopes, we need to ensure they have a      */
	/* parent element                                                         */

	ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

	while(ader_mat_stream_iso > VALID_PTR)
	{

		/* Get the Z of the isotope                                           */

		ader_mat_stream_iso_z = (long)floor(RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] / 10000.0);

		found = 0;

		/* Loop through the streams elements to see if a matching one is found*/

		ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

		while(ader_mat_stream_ele > VALID_PTR)
		{

			if((long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z] == ader_mat_stream_iso_z)
			{

				found = 1;

				break;

			}

			ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

		}

		if(found > 0)
		{

			/* If there is an element, provide this element with a pointer to */
			/* the isotope                                                    */

			ader_mat_stream_ele_iso = NewItem(ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR,
					                          ADER_MAT_GRP_ELE_ISO_BLOCK_SIZE);

			WDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] = (double)ader_mat_stream_iso;

		}
		else
		{

			/* There is no element, create it and give it a pointer to the iso*/

			ader_mat_stream_ele = NewItem(ader_mat_stream + ADER_MAT_STREAM_ELES_PTR,
					                      ADER_MAT_GRP_ELE_BLOCK_SIZE);

			WDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z] = (double)ader_mat_stream_iso_z;

			ader_mat_stream_ele_iso = NewItem(ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR,
					                          ADER_MAT_GRP_ELE_ISO_BLOCK_SIZE);

			WDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] = (double)ader_mat_stream_iso;

		}


		ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialshadowstreamcompmatrixsection.c */
/*                                                                           */
/* Created:       2016/03/06 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Copies information from a shadow stream's primary stream.    */
/*              This way the matrix creation routines can be aware of the    */
/*              linked nature of these entities                              */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERCreateMaterialStreamCompMatrixSection                        */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialShadowStreamCompMatrixSection:"

void ADERProcessMaterialShadowStreamCompMatrixSection(long ader_mat_stream)
{

    long ader_mat_stream_sum_stream = 0, ader_mat_stream_sum_stream_ent = 0;
    long ader_shadow_stream = 0;

    ader_shadow_stream = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

    /* Copy over the column index */

    WDB[ader_shadow_stream + ADER_MAT_STREAM_COL_ID] = RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID];

    /* Copy over the sum stream row, doesn't matter if there is one or isn't */

    WDB[ader_shadow_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID] = RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID];

    /* If there are sum streams, this will need to be called recursively */

    ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    {

        ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        ADERProcessMaterialShadowStreamCompMatrixSection(ader_mat_stream_sum_stream);

        ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialshadowstreameleandisofracs.c*/
/*                                                                           */
/* Created:       2016/04/05 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's shadow streams which are the      */
/*              destination end and populates their isotopic fractions for   */
/*              each element with those from the source side as these are the*/
/*              the ratios which will be coming in                           */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialShadowStreamEleAndIsoFracs:"

void ADERProcessMaterialShadowStreamEleAndIsoFracs(long mat)
{

    long ader_mat_cluster_parent = 0, ader_mat_matrix_data = 0;
    long ader_mat_stream = 0, cluster_parent_ader_data = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* We need the cluster parent to be able to update the comp matrix info  */

    ader_mat_cluster_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    cluster_parent_ader_data = (long)RDB[ader_mat_cluster_parent + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[cluster_parent_ader_data + ADER_MAT_MATRIX_PTR];

    /* Loop through the material's streams. Only process those streams which  */
    /* have a postive shadow stream pointer indicating they have a source     */
    /* stream, skip rem type streams as they have already been processed      */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
    	           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Copy isotopics from the source stream                              */

        ADERGetMaterialShadowStreamIsoFracs(ader_mat_stream);

        /* Re-do the streams element and isotopic fractions in the matrix. Not*/
        /* only does this update the isotopics but it updates the material    */
        /* density correction factor for teh elements and isotopes            */

        ADERFillMaterialStreamCompMatrixSection(mat,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
    	           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Copy isotopics from the source stream                              */

        ADERGetMaterialShadowStreamIsoFracs(ader_mat_stream);

        /* Re-do the streams element and isotopic fractions in the matrix. Not*/
        /* only does this update the isotopics but it updates the material    */
        /* density correction factor for teh elements and isotopes            */

        ADERFillMaterialStreamCompMatrixSection(mat,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
    	           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Copy isotopics from the source stream                              */

        ADERGetMaterialShadowStreamIsoFracs(ader_mat_stream);

        /* Re-do the streams element and isotopic fractions in the matrix. Not*/
        /* only does this update the isotopics but it updates the material    */
        /* density correction factor for teh elements and isotopes            */

        ADERFillMaterialStreamCompMatrixSection(mat,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
    	           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Copy isotopics from the source stream                              */

        ADERGetMaterialShadowStreamIsoFracs(ader_mat_stream);

        /* Re-do the streams element and isotopic fractions in the matrix. Not*/
        /* only does this update the isotopics but it updates the material    */
        /* density correction factor for teh elements and isotopes            */

        ADERFillMaterialStreamCompMatrixSection(mat,
                                                ader_mat_matrix_data,
                                                ader_mat_stream);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialshadowstreams.c             */
/*                                                                           */
/* Created:       2015/03/05 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's streams. If these streams are     */
/*              connected with another actual material this material and     */
/*              its matching stream ( the shadow stream ) are searched for   */
/*              by ADERFindShadowStream.                                     */
/*              The shadow stream and the 'host' stream are given pointers   */
/*              to eachother. Destination streams have pointers with positive*/
/*              values while source streams have their pointer ( to the dest)*/
/*              multiplied by negative one.                                  */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialShadowStreams:"

void ADERProcessMaterialShadowStreams(long mat)
{

    char *ader_mat_stream_dest_id = NULL, *ader_mat_stream_src_id = NULL, *mat_id = NULL;
    long ader_mat_stream = 0, mat_ader_data = 0, shadow_stream = 0;

    mat_id = GetText(mat + MATERIAL_PTR_NAME);

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Go through the four types of steams */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ader_mat_stream_dest_id = GetText(ader_mat_stream + ADER_MAT_STREAM_DEST);

        /* If this material is the destination for this stream, proceed */

        if(strcmp(ader_mat_stream_dest_id, mat_id) == 0)
        {

            ader_mat_stream_src_id = GetText(ader_mat_stream + ADER_MAT_STREAM_SRC);

            /* If the source is an actual material, proceed */

            if(strcmp(ader_mat_stream_src_id, "NULL") != 0)
            {

                /* Find the matching stream in another material */

                shadow_stream = ADERFindShadowStream(ader_mat_stream, mat);

                /* Store that pointer */

                WDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)shadow_stream;

            }

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ader_mat_stream_dest_id = GetText(ader_mat_stream + ADER_MAT_STREAM_DEST);

        if(strcmp(ader_mat_stream_dest_id, mat_id) == 0)
        {

            ader_mat_stream_src_id = GetText(ader_mat_stream + ADER_MAT_STREAM_SRC);

            if(strcmp(ader_mat_stream_src_id, "NULL") != 0)
            {

                shadow_stream = ADERFindShadowStream(ader_mat_stream, mat);

                WDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)shadow_stream;

            }

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ader_mat_stream_dest_id = GetText(ader_mat_stream + ADER_MAT_STREAM_DEST);

        if(strcmp(ader_mat_stream_dest_id, mat_id) == 0)
        {

            ader_mat_stream_src_id = GetText(ader_mat_stream + ADER_MAT_STREAM_SRC);

            if(strcmp(ader_mat_stream_src_id, "NULL") != 0)
            {

                shadow_stream = ADERFindShadowStream(ader_mat_stream, mat);

                WDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)shadow_stream;

            }

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        ader_mat_stream_dest_id = GetText(ader_mat_stream + ADER_MAT_STREAM_DEST);

        if(strcmp(ader_mat_stream_dest_id, mat_id) == 0)
        {

            ader_mat_stream_src_id = GetText(ader_mat_stream + ADER_MAT_STREAM_SRC);

            if(strcmp(ader_mat_stream_src_id, "NULL") != 0)
            {

                shadow_stream = ADERFindShadowStream(ader_mat_stream, mat);

                WDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] = (double)shadow_stream;

            }

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialstreamdata.c                */
/*                                                                           */
/* Created:       2016/1/4   (DDW)                                           */
/* Last modified: 2016/1/4   (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Actually links ader stream data to material stream data      */
/*              also calls functions to populate group data                  */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialStreams          */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialStreamData:"

void ADERProcessMaterialStreamData(long ader_mat_strm, long ader_strm, long mat)
{

    char *ader_grp_id = NULL, *ader_strm_grp_id = NULL;
    long ader_data = 0, ader_grp = 0;
    long ele_iso_fix_check = 0, found = 0;

    /* Copy information over to the material */

    WDB[ader_mat_strm + ADER_MAT_STREAM_PTR] = (double)ader_strm;

    WDB[ader_mat_strm + ADER_MAT_STREAM_MAT_PTR] = (double)mat;

    WDB[ader_mat_strm + ADER_MAT_STREAM_SRC] = RDB[ader_strm + ADER_STREAM_SRC];

    WDB[ader_mat_strm + ADER_MAT_STREAM_DEST] = RDB[ader_strm + ADER_STREAM_DEST];

    WDB[ader_mat_strm + ADER_MAT_STREAM_FORM] = RDB[ader_strm + ADER_STREAM_FORM];

    WDB[ader_mat_strm + ADER_MAT_STREAM_TYPE] = RDB[ader_strm + ADER_STREAM_GRP_TYPE];

    /* We need to determine if this stream has a destination material and no  */
    /* source material                                                        */

    if((strncmp("NULL", GetText(ader_mat_strm + ADER_MAT_STREAM_DEST), 4) != 0) &&
       (strncmp("NULL", GetText(ader_mat_strm + ADER_MAT_STREAM_SRC), 4) == 0))
    {

        /* This is needed by ADERProcessMaterialStreamGroupData which needs to*/
        /* pass it off to ADERProcessMaterialGroupComposition                 */

        ele_iso_fix_check = 1;

    }

    ader_strm_grp_id = GetText(ader_strm + ADER_STREAM_GRP_ID);

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_grp = (long)RDB[ader_data + ADER_GROUPS_PTR];

    while(ader_grp > VALID_PTR)
    {

        ader_grp_id = GetText(ader_grp + ADER_GRP_ID);

        if(strcmp(ader_strm_grp_id, ader_grp_id) == 0)
        {

            /* find the matching group definition for the group this stream is */
            /* trying to move. Process this group information */

            found = 1;

            ADERProcessMaterialStreamGroupData(ader_grp, ader_mat_strm,
                                               ele_iso_fix_check, mat);

            break;

        }

        ader_grp = NextItem(ader_grp);

    }

    if(found == 0)
    {

        Error(0, "No matching group definition for ADER stream entry involving group %s.\n \
WARNING: This may be a recursive call and the named group may be a nested \n \
summation group of another group.\n",
              ader_strm_grp_id);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialstreamgroupdata.c           */
/*                                                                           */
/* Created:       2016/1/4   (DDW)                                           */
/* Last modified: 2016/1/4   (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates element and iso lists for streams from group comp    */
/*              data and handles sum groups.                                 */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialStreamData       */
/*          and by itself                                                    */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialStreamGroupData:"

void ADERProcessMaterialStreamGroupData(long ader_grp, long ader_mat_strm,
                                        long ele_iso_fix_check, long mat)
{

    long ader_grp_sum_grp = 0, ader_grp_sum_grp_data = 0, ader_mat_strm_ele_ptr = 0;
    long ader_mat_strm_iso_ptr = 0, ader_mat_strm_sum_grp_data = 0;
    long ader_mat_strm_sum_grp_strm = 0, dep = 0, i = 0;
    long total_steps = 0;

    /* store the name of the group being moved as the stream name             */

    WDB[ader_mat_strm + ADER_MAT_STREAM_ID] = RDB[ader_grp + ADER_GRP_ID];

    /* Create the burn data storage space                                     */

    /* Count the number of steps                                              */

    dep = (long)RDB[DATA_BURN_PTR_DEP];

    while(dep > VALID_PTR)
    {

    	total_steps = total_steps + (long)RDB[dep + DEP_HIS_N_STEPS];

    	dep = NextItem(dep);

    }

    /* Add a step for the final burn interval                                 */

    total_steps++;

    /* Now actually create the burn value data holders                        */

    for(i = 0; i < total_steps; i++)
    {

    	NewItem(ader_mat_strm + ADER_MAT_STREAM_BURN_STEPS_PTR,
    			ADER_MAT_GRP_BURN_STEP_BLOCK_SIZE);

    }

    /* grab some necessary indices                                            */

    ader_mat_strm_ele_ptr = (long)(ader_mat_strm + ADER_MAT_STREAM_ELES_PTR);

    ader_mat_strm_iso_ptr = (long)(ader_mat_strm + ADER_MAT_STREAM_ISOS_PTR);

    ADERProcessMaterialGroupComposition(ader_grp, ader_mat_strm_ele_ptr,
                                        ader_mat_strm_iso_ptr,
                                        ele_iso_fix_check, mat, 1);

    ader_grp_sum_grp_data = (long)RDB[ader_grp + ADER_GRP_SUM_GRPS_PTR];

    /* Summation streams may not be proportional streams                      */

    if((ader_grp_sum_grp_data > VALID_PTR) && (strcmp("prop", GetText(ader_mat_strm + ADER_MAT_STREAM_FORM)) == 0))
    {

    	Error(0, "Ader stream %s in material %s \n is a 'proportional' form\
stream composed of a 'sum-group'. This structure is not allowed.\n",
              GetText(ader_mat_strm + ADER_MAT_STREAM_ID),
			  GetText(mat + MATERIAL_PTR_NAME));

    }

    /* Handle a groups summation groups if it is a sum group                  */

    while(ader_grp_sum_grp_data > VALID_PTR)
    {

        /* Store sum groups ( which are now sum streams ) inside the parent stream */
        /* This is different from cmp groups which simply link to one another if   */
        /* they are part of a sum group                                       */

        /* So this is the handle for a sum stream                             */

        ader_mat_strm_sum_grp_data = NewItem(ader_mat_strm + ADER_MAT_STREAM_SUM_GRPS_PTR,
                                             ADER_MAT_GRP_SUM_GRP_BLOCK_SIZE);

        WDB[ader_mat_strm_sum_grp_data + ADER_MAT_GRP_SUM_GRP_ID] = RDB[ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_ID];

        WDB[ader_mat_strm_sum_grp_data + ADER_MAT_GRP_SUM_GRP_WEIGHT] = RDB[ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_WEIGHT];

        /* And this is the actual sum stream being stored inside the handle   */

        ader_mat_strm_sum_grp_strm = NewItem(ader_mat_strm_sum_grp_data + ADER_MAT_GRP_SUM_GRP_PTR,
                                             ADER_MAT_STREAM_BLOCK_SIZE);

        /* Populate the sum stream's stream data fields with the relevant     */
        /* parent stream information                                          */

        /* Give the sum stream a ptr back to its parent                       */

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_PTR] = (double)ader_mat_strm;

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_MAT_PTR] = (double)mat;

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_SRC] = RDB[ader_mat_strm + ADER_MAT_STREAM_SRC];

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_DEST] = RDB[ader_mat_strm + ADER_MAT_STREAM_DEST];

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_FORM] = RDB[ader_mat_strm + ADER_MAT_STREAM_FORM];

        WDB[ader_mat_strm_sum_grp_strm + ADER_MAT_STREAM_TYPE] = RDB[ader_mat_strm + ADER_MAT_STREAM_TYPE];

        ader_grp_sum_grp = (long)RDB[ader_grp_sum_grp_data + ADER_GRP_SUM_GRP_PTR];

        /* Process this sum stream just like any other stream. This is recursive */

        ADERProcessMaterialStreamGroupData(ader_grp_sum_grp,
                                           ader_mat_strm_sum_grp_strm,
                                           ele_iso_fix_check, mat);

        ader_grp_sum_grp_data = NextItem(ader_grp_sum_grp_data);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialstreams.c                   */
/*                                                                           */
/* Created:       2016/1/2   (DDW)                                           */
/* Last modified: 2016/1/2   (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to link ader streams data with the           */
/*              appropriate material and to the appropriate material hook    */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialAderData         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialStreams:"

void ADERProcessMaterialStreams(long mat)
{

    char *ader_strm_dest = NULL, *ader_strm_grp_type = NULL;
    char *ader_strm_src = NULL, *ader_strm_type = NULL;
    char *mat_id = NULL;
    long ader_data = 0, ader_mat_strm = 0, ader_strm = 0, host = 0, mat_ader_data = 0;

    mat_id = GetText(mat + MATERIAL_PTR_NAME);

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_strm = (long)RDB[ader_data + ADER_STREAMS_PTR];

    while(ader_strm > VALID_PTR)
    {

        /* Right now, the current stream does not have the current mat as a */
        /* Source or dest */

    	host = 0;

        /* Grab the necessary information */

        ader_strm_dest = GetText(ader_strm + ADER_STREAM_DEST);

        ader_strm_grp_type = GetText(ader_strm + ADER_STREAM_GRP_TYPE);

        ader_strm_src = GetText(ader_strm + ADER_STREAM_SRC);

        ader_strm_type = GetText(ader_strm + ADER_STREAM_TYPE);

        /* If the stream does have the mat, mark it as a source or dest */

        if(strcmp(mat_id, ader_strm_dest) == 0)
        {

            host = 1;

        }

        if(strcmp(mat_id, ader_strm_src) == 0)
        {

            host = 1;

        }

        /* Sort by criteria */

        if((host == 1) && ((strcmp("feed", ader_strm_type) == 0)))
        {

            ader_mat_strm = NewItem(mat_ader_data + ADER_MAT_FEED_STREAMS_PTR,
                                    ADER_MAT_STREAM_BLOCK_SIZE);

            if(strcmp("rem", ader_strm_grp_type) == 0)
            {

                ADERProcessMaterialRemovalData(ader_mat_strm, ader_strm, mat);

            }
            else
            {

                ADERProcessMaterialStreamData(ader_mat_strm, ader_strm, mat);

            }


        }
        else if((host == 1) && ((strcmp("remv", ader_strm_type) == 0)))
        {

            ader_mat_strm = NewItem(mat_ader_data + ADER_MAT_REMV_STREAMS_PTR,
                                                ADER_MAT_STREAM_BLOCK_SIZE);

            if(strcmp("rem", ader_strm_grp_type) == 0)
            {

            	ADERProcessMaterialRemovalData(ader_mat_strm, ader_strm, mat);

            }
            else
            {

                ADERProcessMaterialStreamData(ader_mat_strm, ader_strm, mat);

            }

        }
        else if((host == 1) && (strcmp("reac", ader_strm_type) == 0))
        {

            ader_mat_strm = NewItem(mat_ader_data + ADER_MAT_REAC_STREAMS_PTR,
                                                            ADER_MAT_STREAM_BLOCK_SIZE);

            if(strcmp("rem", ader_strm_grp_type) == 0)
            {

            	ADERProcessMaterialRemovalData(ader_mat_strm, ader_strm, mat);

            }
            else
            {

                ADERProcessMaterialStreamData(ader_mat_strm, ader_strm, mat);

            }

        }
        else if((host == 1) && (strcmp("redox", ader_strm_type) == 0))
        {

            ader_mat_strm = NewItem(mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR,
                                                            ADER_MAT_STREAM_BLOCK_SIZE);

            if(strcmp("rem", ader_strm_grp_type) == 0)
            {

            	ADERProcessMaterialRemovalData(ader_mat_strm, ader_strm, mat);

            }
            else
            {

                ADERProcessMaterialStreamData(ader_mat_strm, ader_strm, mat);

            }

        }

        ader_strm = NextItem(ader_strm);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialstreamunfixedele.c          */
/*                                                                           */
/* Created:       2016/04/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Creates isotope entries for unfixed elements                 */
/*                                                                           */
/* Comments:This function is called from ADERProcessMaterialGroupComposition */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialStreamUnFixedEle:"

void ADERProcessMaterialStreamUnFixedEle(long ader_mat_stream_ele,
                                         long ader_mat_stream_iso_ptr,
                                         long mat)
{

    long ader_mat_stream_ele_iso = 0, ader_mat_stream_iso = 0, mat_iso = 0, nuc = 0;
    long found = 0;

    /* loop through the material's isotopes to find all possible isotopes for */
    /* this element                                                           */

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        /* if this isotope belongs to this element, go ahead and process it   */

        if((long)RDB[nuc + NUCLIDE_Z] == (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z])
        {

            found += 1;

            /* Create the isotope entry                                       */

            ader_mat_stream_iso = NewItem(ader_mat_stream_iso_ptr,
                                       ADER_MAT_GRP_ISO_BLOCK_SIZE);

            /* Create the element's isotope entry                             */

            ader_mat_stream_ele_iso = NewItem(ader_mat_stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR,
                                           ADER_MAT_GRP_ELE_ISO_BLOCK_SIZE);

            /* Give the element a pointer to its new isotope                  */

            WDB[ader_mat_stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] = (double)ader_mat_stream_iso;

            /* Populate the isotope's data                                    */

            WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] = RDB[nuc + NUCLIDE_ZAI];

        }

        mat_iso = NextItem(mat_iso);

    }

    if(found < 1)
    {

        Error(0, "No isotopes were found for element with Z value of %ld in \n \
material %s. This error originated from ADERProcessMaterialStreamUnFixedEle \n \
which indicates that an element in a stream assigned to the named material has \n \
no isotopes in this material. Please place at least one isotope belonging to \n \
this element into the named material's composition at, at least, 0 material \n \
fraction. This will fix the error and preserve the simulation integrity.\n",
              (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z],
              GetText(mat + MATERIAL_PTR_NAME));
    }

}

/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderprocessmaterialstreamunfixedeleisofracs.c  */
/*                                                                           */
/* Created:       2016/04/05 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's streams falling functions to fill */
/*              the isotopic fractions for un fixed elements in a stream     */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERProcessMaterialStreamUnFixedEleIsoFracs:"

void ADERProcessMaterialStreamUnFixedEleIsoFracs(long mat)
{

    long ader_mat_cluster_parent = 0, ader_mat_matrix_data = 0;
    long ader_mat_stream = 0, cluster_parent_ader_data = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* We need the cluster parent to be able to update the comp matrix info  */

    ader_mat_cluster_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    cluster_parent_ader_data = (long)RDB[ader_mat_cluster_parent + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[cluster_parent_ader_data + ADER_MAT_MATRIX_PTR];

    /* Loop through the material's streams. Pass over rem type streams as     */
    /* these are handled in a special manner, same for dest ends of linked    */
    /* streams                                                                */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Update the isotopic fractions                                      */

        ADERGetMaterialStreamUnFixedEleIsoFracs(ader_mat_matrix_data,
        		                                ader_mat_stream, mat);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Update the isotopic fractions                                      */

        ADERGetMaterialStreamUnFixedEleIsoFracs(ader_mat_matrix_data,
        		                                ader_mat_stream, mat);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Update the isotopic fractions                                      */

        ADERGetMaterialStreamUnFixedEleIsoFracs(ader_mat_matrix_data,
        		                                ader_mat_stream, mat);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) ||
           ((long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR] > VALID_PTR ))
        {

            ader_mat_stream = NextItem(ader_mat_stream);

            continue;

        }

        /* Update the isotopic fractions                                      */

        ADERGetMaterialStreamUnFixedEleIsoFracs(ader_mat_matrix_data,
        		                                ader_mat_stream, mat);

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndcntdata.c                       */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: If a 'cnt' flag is found in a cnd block this function is     */
/*              is called by aderreadadercnddata to store the id of the      */
/*              desired cnt table                                            */
/*                                                                           */
/* Comments: Called by AderReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndCntData:"

long ADERReadAderCndCntData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    long cnd_cnt_entry = 0;

    /* Create new conditions controlled items entry */

    cnd_cnt_entry = NewItem(cnd_ptr + ADER_CND_CNT_PTR, ADER_CND_CNT_BLOCK_SIZE);

    /* Store the desired table's id */

    WDB[cnd_cnt_entry + ADER_CND_CNT_ID] = (double)PutText(params[j]);

    j++;

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercnddata.c                          */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through the entries in an ADER conditions ( tag 'cnd') */
/*              table. Calls auxiliary function to deal with each tag type   */
/*              which themselves return the new parameter to be checked      */
/*                                                                           */
/* Comments: Called by ADERCreateAderCndEntry                                */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndData:"

void ADERReadAderCndData(char* fname, long cnd_ptr, long j, long line,
                         char** params, char* pname, long np)
{

    /* track the number of entries for error reporting */

    int entry_counter = 0;

    /* Check the parameter. Call the appropriate function or error out. */

    while(j < np)
    {

        if(strncmp("cnt", params[j], 3) == 0)
        {

            j++;

            j = ADERReadAderCndCntData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;

        }
        else if(strncmp("rng", params[j], 3) == 0)
        {

            j++;

            j = ADERReadAderCndRngData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;

        }
        else if(strncmp("rto", params[j], 3) == 0)
        {

            j++;

            j = ADERReadAderCndRtoData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;

        }
        else if(strncmp("opt", params[j], 3) == 0)
        {

            j++;

            j = ADERReadAderCndOptData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;

        }
        else if(strncmp("oxi", params[j], 3) == 0)
        {

            j++;

            j = ADERReadAderCndOxiData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;

        }
        else if(strncmp("preserve", params[j], 8) == 0)
        {

            j++;

            j = ADERReadAderCndPresData(fname, cnd_ptr, j, line, params, pname);

            entry_counter++;
        }
        else
        {

            Error(0, "Entry %d for cnd table %s, on line %ld in file %s, \n \
does not have valid ID type of, either,\n \
cnt, opt, pres, rng, rto or val.\n",
                  entry_counter, GetText(cnd_ptr + ADER_CND_ID), line, fname);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndoptdata.c                       */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in opt tagged data ( linear solver optimization params)*/
/*              from ADER conditions tables. Returns the index of the next   */
/*              parameter to be checked by ADERReadAderCndData               */
/*                                                                           */
/* Comments: Called by ADERReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndOptData:"

long ADERReadAderCndOptData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    long cnd_opt_entry = 0, max_j = 0;
    int found_dir = 0, found_type = 0;

    if((long)RDB[cnd_ptr + ADER_CND_OPT_PTR] > VALID_PTR)
    {

        Error(0, "Attempting to attach an 'opt' entry to cnd table \n \
%s. Cnd table %s already has an 'opt' entry. Only one 'opt' entry is allowed \n \
per cnd table and only one opt entry per material as well. Found on line %ld of \n \
file %s.\n", GetText(cnd_ptr + ADER_CND_ID), GetText(cnd_ptr + ADER_CND_ID),
              line, fname);

    }

    /* Create new optimization entry */

    cnd_opt_entry = NewItem(cnd_ptr + ADER_CND_OPT_PTR, ADER_CND_OPT_BLOCK_SIZE);

    /* An optimization entry may have up to 5 components past the id */

    max_j = j + 5;

    /* Store data according to its tag. Remember with the found tags */
    /* which data was found. If all necessary data items found, break the loop */

    while(j < max_j)
    {

        if(strncmp("dir", params[j], 3) == 0)
        {

            j++;

            if(strncmp("max", params[j], 3) == 0)
            {

                j++;

                /* We store an optimization direction of "maximize" as a number */
                /* less than zero and a direction of "minimize" as greater than 0 */

                WDB[cnd_opt_entry + ADER_CND_OPT_DIR] = -1.0;

            }
            else if(strncmp("min", params[j], 3) == 0)
            {

                j++;

                WDB[cnd_opt_entry + ADER_CND_OPT_DIR] = 1.0;

            }
            else
            {

                Error(0, "Keyword 'max' or 'min' not found after 'dir' entry\n \
for opt entry in cnd group %s found on line %ld in file %s.\n",
                      GetText(cnd_ptr + ADER_CND_ID), line, fname);
            }

            found_dir = 1;

        }
        else if(strncmp("type", params[j], 4) == 0)
        {

            j++;

            WDB[cnd_opt_entry + ADER_CND_OPT_TYPE] = (double)PutText(params[j]);

            j++;

            WDB[cnd_opt_entry + ADER_CND_OPT_TYPE_TARGET] = (double)PutText(params[j]);

            j++;

            found_type = 1;

        }
        else
        {

            Error(0, "Bad entry, '%s', for opt entry \n \
in cnd group %s on line %ld in file %s.\n \
This is not of type 'dir' or 'type'.\n \
These keywords may have insufficient data in your input or may be missing.\n",
                  params[j], GetText(cnd_ptr + ADER_CND_ID), line, fname);

        }

        if((found_dir == 1) && (found_type == 1))
        {

            break;

        }

    }

    /* It is possible to have looped into another entry in the cnd table */
    /* or even another part of the input. Check to make sure all */
    /* required data items are present for this entry */

    if((found_dir != 1) && (found_type != 1))
    {

        Error(0, "Either 'dir' or 'type', or both, entry(ies) not given for opt entry,\n \
in cnd group %s found on line %ld in file %s.\n",
              GetText(cnd_ptr + ADER_CND_ID), line, fname);

    }

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndoxidata.c                       */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in oxidation table id names, tagged by 'oxi' in the cnd*/
/*              ADER conditions tables. Returns the index of the next        */
/*              parameter to be checked by ADERReadAderCndData               */
/*                                                                           */
/* Comments: Called by ADERReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndOxiData:"

long ADERReadAderCndOxiData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    char *ader_cnd_id = NULL, *ader_cnd_oxi_id = NULL;
    long cnd_oxi_entry = 0, start_j = 0;
    long found = 0, found_max = 0, found_min = 0, found_val = 0;

    /* Catch bad user input */

    if((long)RDB[cnd_ptr + ADER_CND_OXI_PTR] > VALID_PTR)
    {

        ader_cnd_id = GetText(cnd_ptr + ADER_CND_ID);

        cnd_oxi_entry = (long)RDB[cnd_ptr + ADER_CND_OXI_PTR];

        ader_cnd_oxi_id = GetText(cnd_oxi_entry + ADER_OXI_TBL_ID);

        Error(0, "On line %ld in file %s,\n \
trying to add oxidation table %s to conditions block %s \n \
which already has oxidation table %s. Only one oxidation table per conditions block. \n \
Only one oxidation table per material as well.\n", line, fname, params[j],
              ader_cnd_id, ader_cnd_oxi_id);

    }

    /* Create new oxidation items table entry entry for this conditions block */

    cnd_oxi_entry = NewItem(cnd_ptr + ADER_CND_OXI_PTR, ADER_CND_OXI_BLOCK_SIZE);

    /*Store the name */

    WDB[cnd_oxi_entry + ADER_CND_OXI_ID] = (double)PutText(params[j]);

    j++;

    /* If it has oxi targets, store them */

    if((strncmp("max", params[j], 3) == 0) ||
       (strncmp("min", params[j], 3) == 0) ||
       (strncmp("val", params[j], 3) == 0))
    {

        start_j = j;

        while((found < 1) && (j < (start_j + 3)))
        {

            if(strncmp("max", params[j], 3) == 0)
            {

                j++;

                WDB[cnd_oxi_entry + ADER_CND_OXI_MAX] = TestParam(pname, fname, line,
                                                                  params[j], PTYPE_REAL,
                                                                  -1E+08, 1E+08);

                j++;

                found_max = 1;

            }
            else if(strncmp("min", params[j], 3) == 0)
            {

                j++;

                WDB[cnd_oxi_entry + ADER_CND_OXI_MIN] = TestParam(pname, fname, line,
                                                                  params[j], PTYPE_REAL,
                                                                  -1E+08, 1E+08);

                j++;

                found_min = 1;

            }
            else if(strncmp("val", params[j], 3) == 0)
            {

                j++;

                WDB[cnd_oxi_entry + ADER_CND_OXI_MAX] = TestParam(pname, fname, line,
                                                                  params[j], PTYPE_REAL,
                                                                  -1E+08, 1E+08);

                WDB[cnd_oxi_entry + ADER_CND_OXI_MIN] = TestParam(pname, fname, line,
                                                                  params[j], PTYPE_REAL,
                                                                  -1E+08, 1E+08);

                j++;

                found_val = 1;

            }
            else
            {

                Error(0, "Input on line %ld in file %s \n \
for cnd group %s has input word, %s, that is not either 'val', 'min', or 'max'.\n",
                      line, fname, GetText(cnd_ptr + ADER_CND_ID), params[j]);

            }

            if((found_val > 0) || ((found_max > 0) && (found_min > 0)))
            {

                found = 1;

            }

        }

        /* It is possible to have looped into another entry in the cnd table */
        /* or even another part of the input. Check to make sure all */
        /* required data items are present for this entry */
        if((found_val < 1) && ((found_max < 1) || (found_min < 1)))
        {

            Error(0, "Either val or min/max pair not given for oxi entry, %s,\n \
in cnd group %s found on line %ld in file %s.\n",
                  GetText(cnd_oxi_entry + ADER_CND_OXI_ID),
                  GetText(cnd_ptr + ADER_CND_ID), line, fname);

        }

    }
    else
    {

        /* Set a default value of 0.0 */

        WDB[cnd_oxi_entry + ADER_CND_OXI_MAX] = 0.0;

        WDB[cnd_oxi_entry + ADER_CND_OXI_MIN] = 0.0;

    }

    return(j);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndpresdata.c                      */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in 'preservation' tag in the cnd                       */
/*              ADER conditions tables. Returns the index of the next        */
/*              parameter to be checked by ADERReadAderCndData               */
/*                                                                           */
/* Comments: Called by ADERReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndPresData:"

long ADERReadAderCndPresData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    char *ader_cnd_id = NULL, *ader_cnd_pres_ent = NULL;
    long ader_cnd_pres = 0;

    /* Catch bad user input */

    if((long)RDB[cnd_ptr + ADER_CND_PRES_PTR] > VALID_PTR)
    {

        ader_cnd_id = GetText(cnd_ptr + ADER_CND_ID);

        ader_cnd_pres = (long)RDB[cnd_ptr + ADER_CND_PRES_PTR];

        ader_cnd_pres_ent = GetText(ader_cnd_pres + ADER_CND_PRES_ENT);

        Error(0, "On line %ld in file %s,\n \
trying to add preservation entry %s to conditions block %s \n \
which already has preservation entry %s. Only one preservation entry per conditions block. \n \
Only one preservation entry per material as well.\n", line, fname, params[j],
              ader_cnd_id, ader_cnd_pres_ent);

    }

    /* Create new preservation entry  for this conditions block               */

    ader_cnd_pres = NewItem(cnd_ptr + ADER_CND_PRES_PTR, ADER_CND_PRES_BLOCK_SIZE);

    /*Store the name */

    WDB[ader_cnd_pres + ADER_CND_PRES_ENT] = (double)PutText(params[j]);

    j++;

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndrngdata.c                       */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in rng tagged data ( material group composition ranges)*/
/*              from ADER conditions tables. Returns the index of the next   */
/*              parameter to be checked by ADERReadAderCndData               */
/*                                                                           */
/* Comments: Called by ADERReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndRngData:"

long ADERReadAderCndRngData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    long cnd_rng_entry = 0, max_j = 0;
    int found_max = 0, found_min = 0, found_val = 0;

    /* Create new range entry */

    cnd_rng_entry = NewItem(cnd_ptr + ADER_CND_RNGS_PTR, ADER_CND_RNG_BLOCK_SIZE);

    /* Store the id which is the parameter the index is currently on */

    WDB[cnd_rng_entry + ADER_CND_RNG_GRP_ID] = (double)PutText(params[j]);

    j++;

    /* A rng entry may have up to 4 components past the id name */

    max_j = j + 3;

    /* Store data according to its tag. Remember with the found tags */
    /* which data was found. If all necessary data items found, break the loop */

    while(j < max_j)
    {

        if(strncmp("min", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rng_entry + ADER_CND_RNG_MIN] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+18);
            j++;

            found_min = 1;

        }
        else if(strncmp("max", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rng_entry + ADER_CND_RNG_MAX] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+18);

            j++;

            found_max = 1;

        }
        else if(strncmp("val", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rng_entry + ADER_CND_RNG_MIN] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+18);

            WDB[cnd_rng_entry + ADER_CND_RNG_MAX] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+18);

            j++;

            found_val = 1;

        }
        else
        {

            Error(0, "No val or min/max pair given for rng entry, %s,\n \
in cnd group %s found on line %ld in file %s.\n",
                  GetText(cnd_rng_entry + ADER_CND_RNG_GRP_ID),
                  GetText(cnd_ptr + ADER_CND_ID), line, fname);

        }

        if((found_val == 1) || ((found_max == 1) && (found_min ==1)))
        {

            break;

        }
    }

    /* It is possible to have looped into another entry in the cnd table */
    /* or even another part of the input. Check to make sure all */
    /* required data items are present for this entry */
    if((found_val != 1) && ((found_max != 1) || (found_min != 1)))
    {

        Error(0, "Either val or min/max pair not given for rng entry, %s,\n \
in cnd group %s found on line %ld in file %s.\n",
              GetText(cnd_rng_entry + ADER_CND_RNG_GRP_ID),
              GetText(cnd_ptr + ADER_CND_ID), line, fname);

    }

    return(j);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercndrtodata.c                       */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in rto tagged data ( material group composition ratios)*/
/*              from ADER conditions tables. Returns the index of the next   */
/*              parameter to be checked by ADERReadAderCndData               */
/*                                                                           */
/* Comments: Called by ADERReadAderCndData                                   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderCndRtoData:"

long ADERReadAderCndRtoData(char* fname, long cnd_ptr, long j, long line,
                            char** params, char* pname)
{
    long cnd_rto_entry = 0, max_j = 0;
    int found_grp2 = 0, found_max = 0, found_min = 0, found_val = 0;

    /* A ratio may have at most 6 more data items past the first group */

    max_j = j + 6;

    /* Create new conditions controlled items entry */

    cnd_rto_entry = NewItem(cnd_ptr + ADER_CND_RTOS_PTR, ADER_CND_RTO_BLOCK_SIZE);

    WDB[cnd_rto_entry + ADER_CND_RTO_GRP1_ID] = (double)PutText(params[j]);

    j++;

    /*Go ahead and set the rto values to negative 1. This will be used as a */
    /* as a check later                                                     */

    WDB[cnd_rto_entry + ADER_CND_RTO_MAX] = -1.0;

    WDB[cnd_rto_entry + ADER_CND_RTO_MIN] = -1.0;

    /* loops through the entry storing items according to their tag */
    /* Exit the loop if you've grabbed all items or hit the max item count */

    while(j < max_j)
    {

        if(strncmp("min", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rto_entry + ADER_CND_RTO_MIN] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+08);
            j++;

            found_min = 1;

        }
        else if(strncmp("max", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rto_entry + ADER_CND_RTO_MAX] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+08);

            j++;

            found_max = 1;

        }
        else if(strncmp("val", params[j], 3) == 0)
        {

            j++;

            WDB[cnd_rto_entry + ADER_CND_RTO_MIN] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+08);

            WDB[cnd_rto_entry + ADER_CND_RTO_MAX] = TestParam(pname, fname, line,
                                                              params[j], PTYPE_REAL,
                                                              0.0, 1E+08);

            /* We make the max entry negative for checks later on             */

            WDB[cnd_rto_entry + ADER_CND_RTO_MAX] = -RDB[cnd_rto_entry + ADER_CND_RTO_MAX];

            j++;

            found_val = 1;
        }
        else if(strncmp("grp2", params[j], 4) == 0)
        {

            j++;

            WDB[cnd_rto_entry + ADER_CND_RTO_GRP2_ID] = (double)PutText(params[j]);

            j++;

            found_grp2 = 1;
        }
        else
        {

            Error(0, "No val, min/max pair or grp2 given for rto entry %s \n \
in cnd group %s found on line %ld in file %s.\n",
                  GetText(cnd_rto_entry + ADER_CND_RTO_GRP1_ID),
                  GetText(cnd_ptr + ADER_CND_ID), line, fname);

        }

        if((found_grp2 == 1) && ((found_val == 1) || ((found_max == 1) && found_min == 1)))
        {

            break;

        }

    }

    /* Check to make sure all required input is present */

    if((found_grp2 != 1) || !((found_val == 1) || ((found_max == 1) && found_min == 1)))
        {

            Error(0, "Either no grp2 or no val or no min/max pair found for \n \
rto group %s in cnd group %s,\n \
found on line %ld in file %s.\n",
                  GetText(cnd_rto_entry + ADER_CND_RTO_GRP1_ID),
                  GetText(cnd_ptr + ADER_CND_RNG_GRP_ID), line, fname);
        }

    /* Check to make sure max is not smaller than min, but MAX must not be    */
    /* negative as this is a purposeful action by the code                    */

    if((WDB[cnd_rto_entry + ADER_CND_RTO_MAX] > 0.0) &&
       (WDB[cnd_rto_entry + ADER_CND_RTO_MAX] < ( WDB[cnd_rto_entry + ADER_CND_RTO_MIN] - 0.000000001)))
    {

        Error(0, "Max ratio value of, %f, not greater than min ratio value of %f \n \
for rto group %s in cnd group %s,\n \
found on line %ld in file %s.\n",
              WDB[cnd_rto_entry + ADER_CND_RTO_MAX],
              WDB[cnd_rto_entry + ADER_CND_RTO_MIN],
              GetText(cnd_rto_entry + ADER_CND_RTO_GRP1_ID),
              GetText(cnd_ptr + ADER_CND_RNG_GRP_ID), line, fname);

    }

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadercontroldata.c                      */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in controlled elements and isotopes from an ADER       */
/*              control table denoted with the tag 'control'                 */
/*                                                                           */
/* Comments: Called by ADERCreateAderControlEntry                            */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderControlData:"

void ADERReadAderControlData(char* fname, long control_ptr, long j, long line,
                             char** params, char* pname, long np)
{
    long item_counter = 0;
    long id = 0, control_item = 0;

    while(j < np)
    {

        /* Create new control table entry */

        control_item = NewItem(control_ptr + ADER_CONTROL_ENT_PTR,
                               ADER_CONTROL_ENT_BLOCK_SIZE);

        /*Keep track of which entry in the table we are on for error reporting */

        item_counter++;

        /* The first entry in a control table is an element or isotope */
        /* alphanumeric indicator. Convert this string to either a Z or a ZAI */
        /* number with IsotoZAI function which will return -1 if it can't */

        id =  (long)IsotoZAI(params[j]);

        /* Kill if IsotoZAI coulnd't convert the string */

        if(id <= 0)
        {
            Error(0, "Entry %ld in removal group %s, \n \
on line %ld in file %s, is not valid.\n", item_counter,
                      GetText(control_ptr + ADER_CONTROL_TBL_ID),
                      line, fname);
        }
        /* Store in the Z spot if an element */

        else if(id < NUMBER_OF_ELEMENTS)
        {
            WDB[control_item + ADER_CONTROL_ENT_Z] = (double)id;

            j++;
        }
        /* Store in the ZAI spot if an isotope */

        else
        {
            WDB[control_item + ADER_CONTROL_ENT_ZAI] = (double)id;

            j++;

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadergroupdata.c                        */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Called by ADERCreateAderGroupEntry to process group data     */
/*              Calls auxiliary functions to either store a groups density   */
/*              and then process it's contents. If the group is a sum group  */
/*              a special routine is called                                  */
/*                                                                           */
/* Comments: Called by ADERCreateAderGroupEntry. The auxiliary functions     */
/*           should return the next index to be checked                      */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderGroupData:"

void ADERReadAderGroupData(char* fname, long group_ptr, long j, long line,
                           char** params, char* pname, long np)
{
    /* Loop through the group entry's contents */

    while(j < np)
    {

        if(strncmp("sum", params[j], 3) == 0)
        {

            /* If the group type is sum, call the routine to deal with those */
            /* group types */

            j++;

            j = ADERReadAderGroupSumData(fname, group_ptr, j, line, params, pname,
                                         np);

        }
        else
        {
            /* Otherwise, it's a normal group, read in a normal group */

            j = ADERReadAderGroupItemData(fname, group_ptr, j, line, params, pname,
                                          np);
        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadergroupisosdata.c                    */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Given the number of isotopes by ADERReadAderGroupItemData    */
/*              loop through the isotope entries storing their information   */
/*              Returns the index of the next parameter to be checked        */
/*                                                                           */
/* Comments: Called by ADERReadAderGroupItemData                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderGroupIsosData:"

long ADERReadAderGroupIsosData(long comp_ptr, char* fname, long group_ptr,
                               long j, long line, char** params, char* pname,
                               int num_isos)
{
    long iso_ptr = 0;
    int i = 0;

    for(i = 0; i < num_isos; i++)
    {
        /* Create a new isotope entry in the composition entry for the parent */
        /* group */

        iso_ptr = NewItem(comp_ptr + ADER_GRP_COMP_ISOS_PTR,
                          ADER_GRP_ISO_BLOCK_SIZE);

        WDB[iso_ptr + ADER_GRP_ISO_ZAI] = (double)IsotoZAI(params[j]);

        /*If it's not an isotope ZAI, die */

        if(RDB[iso_ptr + ADER_GRP_ISO_ZAI] < NUMBER_OF_ELEMENTS)
        {
            Error(0, "Iso in group %s, found on line %ld \n \
in file %s, is either not recognizable by \n \
IsotoZai or is not an isotope. \n \
IsotoZai output is %ld.\n",
                  GetText(group_ptr + ADER_GRP_ID), line, fname,
                  RDB[iso_ptr + ADER_GRP_ISO_ZAI]);
        }

        j++;

        /* Store it's fraction of the element who is it's parent */

        WDB[iso_ptr + ADER_GRP_ISO_FRAC] = TestParam(pname, fname, line,
                                                     params[j], PTYPE_REAL,
                                                     0.0, 1E+6);

        j++;
    }

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadergroupitemdata.c                    */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Processes the items in a group. If just an element with no   */
/*              isos, simply stores it's information. Otherwise, call the    */
/*              isotope function to store the isos                           */
/*                                                                           */
/* Comments:Called by ADERReadAderGroupData                                  */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderGroupItemData:"

long ADERReadAderGroupItemData(char* fname, long group_ptr, long j, long line,
                              char** params, char* pname, long np)
{
    long composition = 0;
    int num_isos = 0;

    while(j < np )
    {

        /* Create a new group composition entry */

        composition = NewItem(group_ptr + ADER_GRP_COMP_PTR,
                              ADER_GRP_COMP_BLOCK_SIZE);

        /* Store the element Z for this piece of the composition */

        WDB[composition + ADER_GRP_COMP_Z] = (double)IsotoZAI(params[j]);

        /* If it isn't a Z value, it's an incorrect value */

        if(RDB[composition + ADER_GRP_COMP_Z] < 0 ||
           RDB[composition + ADER_GRP_COMP_Z] > 111)
        {
            Error(0, "Item in group %s, found on line %ld in file \n \
%s is either not recognizable by \n \
IsotoZai or is a non-element without an element parent. \n \
IsotoZai output is %ld.\n",
                  GetText(group_ptr + ADER_GRP_ID), line, fname,
                  RDB[composition + ADER_GRP_COMP_Z]);
        }

        j++;

        /* Store the element's fraction of that group */

        WDB[composition + ADER_GRP_COMP_FRAC] = TestParam(pname, fname, line,
                                                         params[j], PTYPE_REAL,
                                                         0.0, 1E+6);

        j++;

        if(strncmp("isos", params[j], 4) == 0)
        {
            /* If there are isotopes, get the number of isotopes and call the */
            /* isotopes reader routine */

            j++;

            num_isos = atoi(params[j]);

            j++;

            j = ADERReadAderGroupIsosData(composition, fname, group_ptr, j,
                                          line, params, pname, num_isos);
        }

    }

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadergroupsumdata.c                     */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Processes data for groups which are summation groups. Stores */
/*              the IDs of all the groups involved. Returns the next params  */
/*              index to be checked                                          */
/*                                                                           */
/* Comments:Called by ADERReadAderGroupData                                  */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderGroupSumData:"

long ADERReadAderGroupSumData(char* fname, long group_ptr, long j, long line,
                              char** params, char* pname, long np)
{
    long sum_group = 0;

    while(j < np )
    {

        /* Create a new sum group entry in the parent group */

        sum_group = NewItem(group_ptr + ADER_GRP_SUM_GRPS_PTR,
                            ADER_GRP_SUM_GRP_BLOCK_SIZE);

        /* Store the group id which is a part of the sum */

        WDB[sum_group + ADER_GRP_SUM_GRP_ID] = (double)PutText(params[j]);

        j++;

        /* Store the weight of this group in the sum */

        WDB[sum_group + ADER_GRP_SUM_GRP_WEIGHT] = TestParam(pname, fname, line,
                                                         params[j], PTYPE_REAL,
                                                         0.0, 1E+6);

        j++;

    }

    return(j);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadaderkmaxdata.c                         */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Stores maximum k value criteria for ADER mod                 */
/*                                                                           */
/* Comments: Called by ReadInput                                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderKMaxData:"

void ADERReadAderKMaxData(char* fname, long line, char** params,
                          char* pname, long np)
{
    long ader_data_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /*Store the maximum k value */

    WDB[ader_data_ptr + ADER_K_MAX] = TestParam(pname, fname, line,
                                                params[j], PTYPE_REAL,
                                                0.0, 1E+08);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadaderkmindata.c                         */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Stores minimum k value criteria for ADER mod                 */
/*                                                                           */
/* Comments: Called by ReadInput                                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderKMinData:"

void ADERReadAderKMinData(char* fname, long line, char** params,
                          char* pname, long np)
{
    long ader_data_ptr = 0;
    long j = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /* Store the minimum k value */

    WDB[ader_data_ptr + ADER_K_MIN] = TestParam(pname, fname, line,
                                                params[j], PTYPE_REAL,
                                                0.0, 1E+08);
}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadernegadens.c                         */
/*                                                                           */
/* Created:       2016/09/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sets negative isotopic density handling flag*/
/*                                                                           */
/* Comments: Called by ReadInput                                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderNegAdens:"

void ADERReadAderNegAdens(char* fname, long line, char** params,
                               char* pname, long np)
{
    long ader_data_ptr = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /*Store the maximum transport calculation iteration */

    WDB[ader_data_ptr + ADER_NEG_ADENS_OPT] = 1.0;

    return;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadaderoxidationdata.c                    */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in oxidation data items                                */
/*                                                                           */
/* Comments: Called by ADERCreateAderOxidationEntry                          */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderOxidationData:"

void ADERReadAderOxidationData(char* fname, long oxidation_ptr, long j,
                               long line, char** params, char* pname, long np)
{
    /* Track the processed item number for error reporting */

    long element_counter = 0;
    long oxidation_item = 0;

    while(j < np)
    {

        /* Each entry can have, at most, 4 components */
		/* Create new oxidation table entry */

		oxidation_item = NewItem(oxidation_ptr + ADER_OXI_ELES_PTR,
							   ADER_OXI_ELE_BLOCK_SIZE);

		/*Store the element Z value given from the string by IsotoZAI */

		WDB[oxidation_item + ADER_OXI_ELE_Z] = (double)IsotoZAI(params[j]);

		element_counter++;

		j++;

		/* If it's not an element or its not an input IsotoZAI can handle, die */

		if((long)WDB[oxidation_item + ADER_OXI_ELE_Z] <= 0 ||
		   (long)WDB[oxidation_item + ADER_OXI_ELE_Z] > NUMBER_OF_ELEMENTS)
		{

			Error(0, "Entry %ld in oxidation group %s, \n \
on line %ld in file %s, is not an element, \n \
given by an element symbol.\n", element_counter,
					  GetText(oxidation_ptr + ADER_OXI_TBL_ID),
					  line, fname);

		}

		/* Store the items oxidation value */

		WDB[oxidation_item + ADER_OXI_ELE_VAL] = TestParam(pname, fname,
															   line, params[j],
															   PTYPE_REAL,
															   -(double)NUMBER_OF_ELEMENTS,
															   1E+18);

		j++;

		/* If the item has a weight, store that. Otherwise, break the i */
		/* loop and go to the next entry */

		if(strncmp("weight", params[j], 6) == 0)
		{

			j++;

			WDB[oxidation_item + ADER_OXI_ELE_WEIGHT] = TestParam(pname,
																	  fname,
																	  line,
																	  params[j],
																	  PTYPE_REAL,
																	  -1E+18,
																	   1E+18);

			j++;

		}
		else
		{

			/* Set the weight to 1, because that's what it is             */

			WDB[oxidation_item + ADER_OXI_ELE_WEIGHT] = 1.0;

		}

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadaderremovaldata.c                        */
/*                                                                           */
/* Created:       2015/11/30 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Reads in items in an ADER 'removal' table which has the name */
/*              'repro' table inside the code.                               */
/*                                                                           */
/* Comments: Called by ADERCreateAderRemovalEntry                              */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderRemovalData:"

void ADERReadAderRemovalData(char* fname, long repro_ptr, long j, long line,
                           char** params, char* pname, long np)
{
    /* Count the items processed for error reporting */

    long item_counter = 0;
    long id = 0, repro_item = 0;

    while(j < np)
    {

        /* Create new repro table entry */

        repro_item = NewItem(repro_ptr + ADER_REPRO_ENT_PTR,
                             ADER_REPRO_ENT_BLOCK_SIZE);

        item_counter++;

        /* The first entry in a repro table is an element or isotope */
        /* alphanumeric indicator. Convert this string to either a Z or a ZAI */
        /* number with IsotoZAI function which will return -1 if it can't */

        id =  (long)IsotoZAI(params[j]);

        /* Die if IsotoZAI can't convert the stirng */

        if(id <= 0)
        {
            Error(0, "Entry %ld in removal group %s, \n \
on line %ld in file %s, is not valid.\n", item_counter,
                      GetText(repro_ptr + ADER_REPRO_TBL_ID),
                      line, fname);
        }
        /* If it's an element, store it in the Z spot */

        else if(id <= NUMBER_OF_ELEMENTS)
        {

            WDB[repro_item + ADER_REPRO_ENT_Z] = (double)id;

        }
        /*If it's an isotope store it in the ZAI spot */

        else
        {

            WDB[repro_item + ADER_REPRO_ENT_ZAI] = (double)id;

        }

        j++;

        /* Store it's fractional ( of itself ) removal efficiency */

        WDB[repro_item + ADER_REPRO_ENT_VAL] = TestParam(pname, fname,
                                                         line, params[j],
                                                         PTYPE_REAL,
                                                         0.0, 1E+18);

        j++;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadaderstreamdata.c                       */
/*                                                                           */
/* Created:       2015/11/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Process the various parts of an ADER stream input.           */
/*                                                                           */
/* Comments: Called by ADERCreateAderStreamEntry                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderStreamData:"

void ADERReadAderStreamData(char* fname, long stream_ptr, long j, long line,
                            char** params, char* pname, long np)
{
    /* Track the inputs found for error checking */

    int found_form = 0, found_from = 0, found_frac = 0, found_group = 0;
    int found_rem = 0, found_to = 0, found_type = 0;

    /* Loop through all the inputs of the stream, store them appropriately */
    /* according to their tag */

    while(j < np)
    {

        if(strncmp("form", params[j], 4) == 0)
        {

            j++;

            WDB[stream_ptr + ADER_STREAM_FORM] = (double)PutText(params[j]);

            if(strncmp("cont", GetText(stream_ptr + ADER_STREAM_FORM), 4) != 0 &&
               strncmp("disc", GetText(stream_ptr + ADER_STREAM_FORM), 4) != 0 &&
			   strncmp("prop", GetText(stream_ptr + ADER_STREAM_FORM), 4) != 0)
            {

                Error(0, "Invalid entry for 'form' field in ADER stream on line %ld \n \
in file %s. Acceptable entries are 'cont', 'disc', and 'prop'.\n",
                      line, fname);

            }

            found_form = 1;

            j++;

        }
        else if(strncmp("frac", params[j], 4) == 0)
        {

            j++;

            WDB[stream_ptr + ADER_STREAM_OPT1] = TestParam(pname, fname, line,
                                                        params[j], PTYPE_REAL,
                                                        0.0, 1E+18);

            found_frac = 1;

            j++;

        }
        else if(strncmp("from", params[j], 4) == 0)
        {

            j++;

            WDB[stream_ptr + ADER_STREAM_SRC] = (double)PutText(params[j]);

            found_from = 1;

            j++;

        }
        else if(strncmp("group", params[j], 3) == 0)
        {

            WDB[stream_ptr + ADER_STREAM_GRP_TYPE] = (double)PutText(params[j]);

            j++;

            WDB[stream_ptr + ADER_STREAM_GRP_ID] = (double)PutText(params[j]);

            found_group = 1;

            j++;

        }
        else if(strncmp("rem", params[j], 3) == 0)
        {

            WDB[stream_ptr + ADER_STREAM_GRP_TYPE] = (double)PutText(params[j]);

            j++;

            WDB[stream_ptr + ADER_STREAM_GRP_ID] = (double)PutText(params[j]);

            found_rem = 1;

            j++;

        }
        else if(strncmp("to", params[j], 2) == 0)
        {

            j++;

            WDB[stream_ptr + ADER_STREAM_DEST] = (double)PutText(params[j]);

            found_to = 1;

            j++;

        }
        else if(strncmp("type", params[j], 4) == 0)
        {

            j++;

            WDB[stream_ptr + ADER_STREAM_TYPE] = (double)PutText(params[j]);

            j++;

            found_type = 1;

        }
        else
        {

            Error(0, "Invalid entry tag in ADER stream on line %ld in file %s.\n",
                  line, fname);

        }

    }

    /* If the correct combinations of pieces are not in the input, error out */

    if((!found_group && !found_rem) ||
       (!found_from && !found_to) ||
       (found_rem && !found_frac) ||
       (!found_type) ||
       (!found_form))
    {

        Error(0, "Incomplete entry for ADER stream on line %ld in file %s.\n",
              line, fname);

    }

    /* Group-class streams of proportional type with no source are not        */
    /* permitted. Edge cases are too numerous.                                */

    if((strcmp("prop", GetText(stream_ptr + ADER_STREAM_FORM)) == 0) &&
       found_group &&
	   !found_from)
    {

        Error(0, "Group-class streams of proportional type with no source material are not\n\
permitted. Found on line %ld in file %s.\n",
              line, fname);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderreadadertransiterdata.c                    */
/*                                                                           */
/* Created:       2016/04/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Stores maximum transport calculation iterations              */
/*                                                                           */
/* Comments: Called by ReadInput                                             */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERReadAderTransIterData:"

long ADERReadAderTransIterData(char* fname, long line, char** params,
                               char* pname, long np, long k)
{
    long ader_data_ptr = 0;

    /*Get ADER data block address */

    ader_data_ptr = (long)RDB[DATA_PTR_ADER];

    /*Store the maximum transport calculation iteration */

    WDB[ader_data_ptr + ADER_TRANS_ITER] = TestParam(pname, fname, line,
                                                    params[k], PTYPE_INT,
                                                    0, 100000);

    /* Increment k to indicate successful assignment */

    k = k + 1;

    return k;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderscorecrosssection.c                        */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: If a material is under ADER control, and if it has reactivity*/
/*              control, this function will gather the cross section data    */
/*              from CalculateTransmuXS                                      */
/*                                                                           */
/* Comments:This function is called from CalculateTransmuXS                  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERScoreCrossSection:"

void ADERScoreCrossSection(long abs, double E, long id, long mat, long nuc,
		                   long rea, double value)
{

    long ader_mat_iso = 0, mat_ader_data = 0, mat_iso = 0, mat_nuc = 0;

    /* If this material isn't under ADER control OR if it isn't involved in   */
    /* reactivity calculations, don't bother with this function               */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(mat_ader_data < VALID_PTR)
    {

        return;

    }

    if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] <= 0.0)
    {

        return;

    }

    /* Find the ader mat isotope that matches the nuclide                     */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

        mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

        mat_nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[mat_nuc + NUCLIDE_ZAI] == (long)RDB[nuc + NUCLIDE_ZAI])
        {

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* If we didn't find a matching isotope, error out                        */

    if((long)RDB[mat_nuc + NUCLIDE_ZAI] != (long)RDB[nuc + NUCLIDE_ZAI])
    {

        Die(FUNCTION_NAME, "Error in function ADERScoreCrossSection. \n \
Please report this error to the SERPENT dev team. The easiest way is most \n \
likely the SERPENT users forums. Please include as much information about your\n \
simulation as possible. The following information will be most helpful. \n\n \
Material Name: %s \n\n \
ZAI of nuclide not found in ADER_MAT_ISO_PTR list: %ld \n\n \
OMP THREAD NUM: %ld \n\n", GetText(mat + MATERIAL_PTR_NAME),
            (long)RDB[nuc + NUCLIDE_ZAI], id);

    }

    /* Now, determine if the reaction should be scored and if so how          */
    /* Here the reaction is scored as fission because it has a fission yield  */
    /* and is not spontaneous fission                                         */

    if(abs == 0)
    {

        WDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_CUR] +
        		                                                value;

    }
    else if(abs > 0)
		{

        	if(((long)RDB[rea + REACTION_MT] == 18)||
        	   ((long)RDB[rea + REACTION_MT] == 19)||
        	   ((long)RDB[rea + REACTION_MT] == 20)||
        	   ((long)RDB[rea + REACTION_MT] == 21)||
        	   ((long)RDB[rea + REACTION_MT] == 38))
			{

				WDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] +
																  value;

				WDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_FIS_MIC_XS_CUR] +
																		value;

			}
			else
			{

				WDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] = RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_CUR] +
																  value;

			}

		}
    else
    {

    	return;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : setmatadermem                                  */
/*                                                                           */
/* Created:       2015/10/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Called from readinput if keyword "ader" is found in a "mat"  */
/*              definition. Creates ADER data blocks and populates an ADER   */
/*              element list with the Z values of all elements.              */
/*                                                                           */
/* Comments:Called by ReadInput in the 'mat' section                         */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"

/*****************************************************************************/

void ADERSetMatAderMem(long loc0, char** params, long np, char* pname,
                       char* fname, long line)
{
    int i = 0;
    int k = 0;
    long mat_ader_data_ptr = 0, mat_ader_ele = 0, ader_mat_cnd = 0;

    /* Create ADER memory for the mat*/

    mat_ader_data_ptr = NewItem(loc0 + MATERIAL_ADER_DATA, ADER_MAT_BLOCK_SIZE);

    /*Loop to create element in Z_LIST for each element for current mat */

    for(i = 0; i < NUMBER_OF_ELEMENTS; i++)
    {

        mat_ader_ele = NewItem(mat_ader_data_ptr + ADER_MAT_ELES_PTR,
                               ADER_MAT_ELE_BLOCK_SIZE);

        WDB[mat_ader_ele + ADER_MAT_ELE_Z] = (double)(i + 1);

    }

    /*Loop over parameters to see if material has a reactivity weight */

    while(k < np)
    {

        if (strncmp(params[k], "rhow", 4) == 0)
        {

            k++;

            WDB[mat_ader_data_ptr + ADER_MAT_RHO_WEIGHT] = TestParam(pname,
                                                                     fname, line,
                                                                     params[k],
                                                                     PTYPE_REAL,
                                                                     0.0, 1.0);

        }

        /* check for cnd entry flags and if so add a tag to the material */

        if (strncmp(params[k], "cnd", 3) == 0)
        {

            k++;

            ader_mat_cnd = NewItem(mat_ader_data_ptr + ADER_MAT_CNDS_PTR,
                                   ADER_MAT_CND_ENT_BLOCK_SIZE);

            WDB[ader_mat_cnd + ADER_MAT_CND_ID] = (double)PutText(params[k]);

        }

        k++;

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixclustermemcolbounds.c */
/*                                                                           */
/* Created:       2017/11/29 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Adjusts column bounds in the comp matrix to account for      */
/*              removal due to removal tables and material present           */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixClusterMemColBounds:"

void ADERSetMaterialCompMatrixClusterMemColBounds(long mat)
{

    long ader_mat_cluster_parent = 0, ader_mat_ele = 0, ader_mat_iso = 0;
    long ader_mat_stream = 0;
    long ader_parent_ader_data = 0, ader_parent_matrix_data = 0;
    long mat_ader_data = 0, mat_iso = 0;

    /* Get the comp matrix                                                    */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cluster_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    ader_parent_ader_data = (long)RDB[ader_mat_cluster_parent + MATERIAL_ADER_DATA];

    ader_parent_matrix_data = (long)RDB[ader_parent_ader_data + ADER_MAT_MATRIX_PTR];

    /* First, clear all the element and isotope future columns of previous    */
    /* data                                                                   */

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	/* Clear the future column                                            */

    	ADERSetMaterialCompMatrixColBounds(1, 0,
    			                           (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
										   ader_parent_matrix_data,
										   0.0);

    	ADERSetMaterialCompMatrixColBounds(2, 0,
    			                           (long)RDB[ader_mat_ele + ADER_MAT_ELE_FUT_COL_ID],
										   ader_parent_matrix_data,
										   1E+18);

    	ader_mat_ele = NextItem(ader_mat_ele);

    }

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	/* Clear the future column                                            */

    	ADERSetMaterialCompMatrixColBounds(1, 0,
    			                           (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
										   ader_parent_matrix_data,
										   0.0);

    	ADERSetMaterialCompMatrixColBounds(2, 0,
    			                           (long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
										   ader_parent_matrix_data,
										   1E+18);

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Loop through all the material's streams, check for rem type streams    */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableColBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
        															 mat);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableColBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
        															 mat);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableColBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
        															 mat);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if(strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0)
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableColBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
        															 mat);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixclustermempresrowbounds.c */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Calls functions to adjust row bounds in the comp matrix to   */
/*              account for material removal due to removal tables if        */
/*              preservation rows are in use                                 */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds         */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixClusterMemPresRowBounds:"

void ADERSetMaterialCompMatrixClusterMemPresRowBounds(long ader_mat_matrix_data,
		                                              long mat, double value)
{

	long ader_mat_pres = 0, mat_ader_data = 0;

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Loop through any preservation entries                                  */

	ader_mat_pres = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

	while(ader_mat_pres > VALID_PTR)
	{

		/* If its a mols preserve, adjust the value                           */

		if(strcmp("mols", GetText(ader_mat_pres + ADER_MAT_PRESERVE_ENT)) == 0)
		{

			/* We multiply by -1 so that the "preserve mols" row is aware that*/
			/*, if material is leaving say, it needs to have a positive value */
			/* to balance out that material that has left. The inverse is true*/
			/* for material coming into the system                            */

	    	ADERSetMaterialCompMatrixRowBounds(0, 1, ader_mat_matrix_data,
	    			                           (long)RDB[ader_mat_pres + ADER_MAT_PRESERVE_ROW_ID],
											   -1.0 * value);

		}

		ader_mat_pres = NextItem(ader_mat_pres);

	}

}
 /*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixclustermemremovaltablerowbounds.c */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Adjusts row bounds in the comp matrix to account for material*/
/*              removal due to removal tables                                */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRowBounds                     */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds:"

void ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds(long ader_mat_matrix_data,
		                                                      long ader_mat_stream,
															  long dep,
															  long mat,
															  double t1,
															  double t2)
{

	double sign = 0;
	long ader_mat_ele = 0, ader_mat_iso = 0, ader_mat_stream_ele = 0;
	long ader_mat_stream_iso = 0, mat_ader_data = 0, mat_iso = 0, nuc = 0;

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Determine if this material is the stream's source or sink, set sign    */

	if(strcmp(GetText(ader_mat_stream + ADER_MAT_STREAM_SRC),
			  GetText(mat + MATERIAL_PTR_NAME)) == 0)
	{

		sign = -1.0;

	}
	else
	{

		sign = 1.0;

	}

	/* Loop through the stream's elements                                     */

	ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

	while(ader_mat_stream_ele > VALID_PTR)
	{

		/* Loop through the material elements to get the row information      */

		ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

		while(ader_mat_ele > VALID_PTR)
		{

			if((long)RDB[ader_mat_ele + ADER_MAT_ELE_Z] ==
		       (long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z])
			{

				break;

			}

			ader_mat_ele = NextItem(ader_mat_ele);

		}

		/* Add the calculated removal amount, stored in ADER_MAT_GRP_ELE_FRAC */
		/* to the appropriate rows                                            */

    	ADERSetMaterialCompMatrixRowBounds(0, 1, ader_mat_matrix_data,
    			                           (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID],
										   (sign *
										    RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC]));

		ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

	}

	/* Loop through the stream's isotopes                                     */

	ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

	while(ader_mat_stream_iso > VALID_PTR)
	{

		ader_mat_iso = (long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

		/* Add the calculated removal amount, stored in                       */
		/* ADER_GRP_ISO_ELE_FRAC to the appropriate rows                      */

    	ADERSetMaterialCompMatrixRowBounds(0, 1, ader_mat_matrix_data,
    			                           (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID],
										   (sign *
										    RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC]));

    	/* Deal with any pres row                                             */

    	ADERSetMaterialCompMatrixClusterMemPresRowBounds(ader_mat_matrix_data, mat,
    			                                         (sign *
    			                                          RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC]));

		ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixclustermemrhorowentries.c*/
/*                                                                           */
/* Created:       2016/04/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's isotopes filling in reactivity    */
/*              information if it is needed                                  */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixClusterMemRhoRowEntries:"

void ADERSetMaterialCompMatrixClusterMemRhoRowEntries(long dep, long mat,
													  double t1, double t2)
{

	double ader_mat_iso_k_max_value = 0, ader_mat_iso_k_min_value = 0, bias = 0;
	long ader_data = 0, ader_mat_iso = 0;
	long ader_parent_mat = 0, ader_parent_mat_ader_data = 0;
	long ader_parent_mat_matrix_data = 0, mat_ader_data = 0;

	/* If this material is not under reactivity control, exit                 */

	mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	if(mat_ader_data > VALID_PTR)
	{

		if(RDB[mat_ader_data + ADER_MAT_RHO_WEIGHT] > 0.0)
		{

			/* Get the parent material here for matrix data */

			ader_parent_mat = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

			ader_parent_mat_ader_data = (long)RDB[ader_parent_mat + MATERIAL_ADER_DATA];

			ader_parent_mat_matrix_data = (long)RDB[ader_parent_mat_ader_data + ADER_MAT_MATRIX_PTR];

		}
		else
		{

			return;

		}

	}

	/* First we need the ader data for k_max and k_min values                 */

	ader_data = (long)RDB[DATA_PTR_ADER];

	/* Get the biasing factor between ADER and SERPENT                        */

	bias = ADERGetEigenBias(dep, mat, t1, t2);

	/* loop through the isotopes to fill their reacitivty information         */

	ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

	while(ader_mat_iso > VALID_PTR)
	{

		/* Get the value to put in the k max row and iso fut col              */
        /* This value should be equal to....                         */
        /* ( ( ( K_max / ( ( 1 - p_l ) * bias ) * sigma_abs ) - ( nu_bar * sigma_fis ) ) */

		ader_mat_iso_k_max_value = (((RDB[ader_data + ADER_K_MAX] /
				                      ((1.0 - ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
				                    		                   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
															   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
															   t1, t2, dep)) *
				                         bias)) *
				                      ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
				                    		           RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
											           RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
													   t1, t2, dep)) -
				                    ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
				                    		         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
											         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
													 t1, t2, dep));

		/* Get the value to put in the k min row and iso fut col              */
        /* This value should be equal to....                                  */
        /* ( ( ( K_min / ( 1 - p_l ) ) * sigma_abs ) - ( nu_bar * sigma_fis ) ) */

		ader_mat_iso_k_min_value = (((RDB[ader_data + ADER_K_MIN] /
				                      ((1.0 - ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
				                    		                   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
											                   RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
															   t1, t2, dep)) *
				                        bias)) *
				                      ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
				                    		           RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
											           RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
													   t1, t2, dep)) -
				                    ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
				                    		         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
											         RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
													 t1, t2, dep));

		ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
				                         (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID],
										 ader_parent_mat_matrix_data,
										 ader_mat_iso_k_max_value);

		ADERSetMaterialCompMatrixElement((long)RDB[ader_mat_iso + ADER_MAT_ISO_FUT_COL_ID],
				                         (long)RDB[mat_ader_data + ADER_MAT_RHO_MIN_ROW_ID],
										 ader_parent_mat_matrix_data,
										 ader_mat_iso_k_min_value);

		ader_mat_iso = NextItem(ader_mat_iso);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixclustermemrowbounds.c */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Adjusts row bounds in the comp matrix to account for material*/
/*              removal due to removal tables and material present           */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixClusterMemRowBounds:"

void ADERSetMaterialCompMatrixClusterMemRowBounds(long dep, long i, long mat,
		                                          double t1, double t2)
{

    long ader_mat_cluster_parent = 0, ader_mat_ele = 0, ader_mat_iso = 0, ader_mat_oxi = 0;
    long ader_mat_stream = 0;
    long ader_parent_ader_data = 0, ader_parent_matrix_data = 0;
    long mat_ader_data = 0, mat_iso = 0;

    /* Get the comp matrix                                                    */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cluster_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    ader_parent_ader_data = (long)RDB[ader_mat_cluster_parent + MATERIAL_ADER_DATA];

    ader_parent_matrix_data = (long)RDB[ader_parent_ader_data + ADER_MAT_MATRIX_PTR];

    /* Grab any oxidation information                                         */

    ader_mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    /* First, clear all the element and isotope balance  and future rows of   */
    /* previous data                                                          */

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	/* Clear the balance row                                              */

    	ADERSetMaterialCompMatrixRowBounds(0, 0, ader_parent_matrix_data,
    			                           (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID],
										   0.0);

    	ader_mat_ele = NextItem(ader_mat_ele);

    }

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	/* Clear the balance row                                              */

    	ADERSetMaterialCompMatrixRowBounds(0, 0, ader_parent_matrix_data,
    			                           (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID],
										   0.0);

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Clear the bounds of any preservation rows this material may have       */

    ADERClearMaterialCompMatrixClusterMemPresRowBounds(ader_parent_matrix_data,
    		                                           mat);

    /* Now loop through all the elements and add their current amount to the  */
    /* balance row                                                            */

	ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	ADERSetMaterialCompMatrixRowBounds(0, 0, ader_parent_matrix_data,
    			                           (long)RDB[ader_mat_ele + ADER_MAT_ELE_BAL_ROW_ID],
										   RDB[ader_mat_ele + ADER_MAT_ELE_FRAC]);

    	ader_mat_ele = NextItem(ader_mat_ele);

    }

    /* Do the same for the isotopes                                           */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	/* Get the actual isotope to get its ADENS                            */

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	ADERSetMaterialCompMatrixRowBounds(0, 0, ader_parent_matrix_data,
    			                           (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID],
										   (RDB[mat_iso + COMPOSITION_ADENS] /
										    RDB[mat + MATERIAL_ADENS]));

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Loop through all the material's streams, check for rem type streams    */
    /* DO NOT incorporate bounds changes from discrete rem type streams after */
    /* the zeroth criticality iteration - these changes have already been     */
    /* applied                                                                */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
																	 dep,
        															 mat, t1,
																	 t2);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
																	 dep,
        															 mat, t1,
																	 t2);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
																	 dep,
        															 mat, t1,
																	 t2);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        if((strcmp("rem", GetText(ader_mat_stream + ADER_MAT_STREAM_TYPE)) == 0) &&
           ((i == 0) || (strcmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM)) != 0)))
        {

            /* Now call the below function to deal with removal table effects */

            ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds(ader_parent_matrix_data,
            		                                                 ader_mat_stream,
																	 dep,
        															 mat, t1,
																	 t2);

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixcolbounds.c           */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sets a specific row's bounds, either lower or upper as       */
/*              indicated by a bound variable value of 2 or 3 respectively   */
/*              or both bounds if 0 is passed in.                            */
/*              If 'increment' is greater than zero it will add this value to*/
/*              the current bound. If less than zero, the passed in value    */
/*              overwrites the current bound.                                */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds         */
/*          ADERSetMaterialCompMatrixClusterMemRowBounds                     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixColBounds:"

void ADERSetMaterialCompMatrixColBounds(long bound,
										long increment,
										long mat_matrix_col_id,
		                                long mat_matrix_data,
										double value)
{

	long i = 0, mat_matrix_column = 0;

	/* Get the column in question                                             */

	mat_matrix_column = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

	for(i = 0; i < mat_matrix_col_id; i++)
	{

		mat_matrix_column = NextItem(mat_matrix_column);

	}

	/* If increment is greater than 0, add value to the column bound          */

	if(increment > 0)
	{

		if(bound == 0)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] = RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] +
					                                                      value;

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] = RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] +
					                                                      value;

		}
		else if(bound == 1)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] = RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] +
					                                                      value;

		}
		else if(bound == 2)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] = RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] +
					                                                      value;

		}
		else
		{

			Die(FUNCTION_NAME, "Function ADERSetMaterialCompMatrixColBounds received bad value for variable\n\
'bound' of %ld but should have received a value of 0, 1, or 2.\n", bound);

		}

	}
	else
	{

		if(bound == 0)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] = value;

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] = value;

		}
		else if(bound == 1)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] = value;

		}
		else if(bound == 2)
		{

			WDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] = value;

		}
		else
		{

			Die(FUNCTION_NAME, "Function ADERSetMaterialCompMatrixColBounds received bad value for variable\n\
'bound' of %ld but should have received a value of 0, 1, or 2.\n", bound);

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixelement.c             */
/*                                                                           */
/* Created:       2016/03/23 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: For the passed in material comp matrix, sets the value       */
/*              specified by the function arguments at the given indices     */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERFillMaterialCmpRtoCompMatrixSection                          */
/*          ADERFillMAterialCmpSumCompMatrixSection                          */
/*          ADERFillMaterialCompMatrixEleData                                */
/*          ADERFillMaterialCompMatrixIsoData                                */
/*          ADERFillMaterialEleCompMatrixSection                             */
/*          ADERFillMaterialIsoCompMatrixSection                             */
/*          ADERFillMaterialObjActFeedAndRemvCompMatrix                      */
/*          ADERFillMaterialObjActFeedCompMatrix                             */
/*          ADERFillMaterialObjActReacCompMatrix                             */
/*          ADERFillMaterialObjActRedoxCompMatrix                            */
/*          ADERFillMaterialObjActRemvCompMatrix                             */
/*          ADERFillMaterialObjActStreamsCompMatrix                          */
/*          ADERFillMaterialObjActTransfersCompMatrix                        */
/*          ADERFillMaterialObjActStreamCompMatrix                           */
/*          ADERFillMaterialObjActGrpCompMatrix                              */
/*          ADERFillMaterialOxiCompMatrixSection                             */
/*          ADERFillMaterialPresMolsCompMatrixSection                        */
/*          ADERFillMaterialStreamCompMatrixSection                          */
/*          ADERSetMaterialCompMatrixClusterMemRhoRowEntries                 */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixElement:"

void ADERSetMaterialCompMatrixElement(long index_col,
                                      long index_row,
                                      long ader_mat_matrix_data,
                                      double value)
{

    long ader_mat_matrix_col = 0, ader_mat_matrix_col_row = 0, i = 0;

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    /* Cycle through to the desired column                                    */

    for(i = 0; i < index_col; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    /* Cycle through to the desired row                                       */

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < index_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    /* Set the value                                                          */

    WDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = value;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetmaterialcompmatrixrowbounds.c           */
/*                                                                           */
/* Created:       2016/04/20 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Sets a specific row's bounds, either lower or upper as       */
/*              indicated by a bound variable value of 2 or 3 respectively   */
/*              or both bounds if 0 is passed in.                            */
/*              If 'increment' is greater than zero it will add this value to*/
/*              the current bound. If less than zero, the passed in value    */
/*              overwrites the current bound.                                */
/*                                                                           */
/* Comments:This function is called from                                     */
/*          ADERSetMaterialCompMatrixClusterMemRemovalTableRowBounds         */
/*          ADERSetMaterialCompMatrixClusterMemRowBounds                     */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetMaterialCompMatrixRowBounds:"

void ADERSetMaterialCompMatrixRowBounds(long bound,
										long increment,
		                                long mat_matrix_data,
		                                long mat_matrix_row_id,
										double value)
{

	long i = 0, mat_matrix_row_bound = 0;

	/* Get the row bound in question                                          */

	mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

	for(i = 0; i < mat_matrix_row_id; i++)
	{

		mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

	}

	/* If increment is greater than 0, add value to the row bound             */

	if(increment > 0)
	{

		if(bound == 0)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] +
					                                                      value;

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] +
					                                                      value;

		}
		else if(bound == 1)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] +
					                                                      value;

		}
		else if(bound == 2)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] +
					                                                      value;

		}
		else
		{

			Die(FUNCTION_NAME, "Function ADERSetMaterialCompMatrixRowBounds received bad value for variable\n\
'bound' of %ld but should have received a value of 0, 1, or 2.\n", bound);

		}

	}
	else
	{

		if(bound == 0)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] = value;

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] = value;

		}
		else if(bound == 1)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] = value;

		}
		else if(bound == 2)
		{

			WDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] = value;

		}
		else
		{

			Die(FUNCTION_NAME, "Function ADERSetMaterialCompMatrixRowBounds received bad value for variable\n\
'bound' of %ld but should have received a value of 0, 1, or 2.\n", bound);

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersetshadowstreamremovalamount.c            */
/*                                                                           */
/* Created:       2016/04/25 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Searches shadow stream's elemental or isotopic lists to store*/
/*              the passed in value                                          */
/*                                                                           */
/* Comments:This function is called from ADERGetStreamRemovalAmounts         */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSetShadowStreamRemovalAmount:"

void ADERSetShadowStreamRemovalAmount(long ader_mat_stream, long ele_id,
                                      long iso_id, double value)
{

	long ader_mat_stream_ele = 0, ader_mat_stream_iso = 0;

	if(ele_id > 0)
	{

		ader_mat_stream_ele = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ELES_PTR];

		while(ader_mat_stream_ele > VALID_PTR)
		{

			if((long)RDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_Z] == ele_id)
			{

				WDB[ader_mat_stream_ele + ADER_MAT_GRP_ELE_FRAC] = value;

				break;
			}

			ader_mat_stream_ele = NextItem(ader_mat_stream_ele);

		}

	}
	else
	{

		ader_mat_stream_iso = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_ISOS_PTR];

		while(ader_mat_stream_iso > VALID_PTR)
		{

			if((long)RDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ZAI] == iso_id)
			{

				WDB[ader_mat_stream_iso + ADER_MAT_GRP_ISO_ELE_FRAC] = value;

			}

			ader_mat_stream_iso = NextItem(ader_mat_stream_iso);

		}

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : adersolveclpmodel.c                            */
/*                                                                           */
/* Created:       2016/04/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Passes the clp model to the clp simplex solver which returns */
/*              a double array with the solution and the objective value     */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                       TESTADERSolveClpModel               */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "Clp_C_Interface.h"
#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERSolveClpModel"

void ADERSolveClpModel(double *column_lower_bounds, double *column_upper_bounds,
                       double *index_column_starts, long num_cols, long num_ent,
					   long num_rows, double *objective_row, long opt_dir,
                       double *row_lower_bounds,    double *row_indices,
		               double *row_upper_bounds,    double *solution,
					   double *values, long mat)
{

	/* This is the Clp model "object", yes, this isn't C++ but think of this  */
	/* as an object because it is, it's a port from a C++ code into a C code  */

	Clp_Simplex *clp_model = NULL;

	/* This is for the solution returned by the Clp library. This will be     */
	/* copied into the given solution array                                   */

	double *clp_solution = NULL;

	/* Clp requires that the index_column_starts array and the row_indices    */
	/* array be of type int ( or a custom type but that's irrelevant ),       */
	/* we create arrays for these here                                        */

	int *int_index_column_starts = NULL, *int_row_indices = NULL;

	/* Optimality check, set initial value to failure state                   */

	long optimality = 1;

	long secondary_status = 0;

	/* Loop variable                                                          */

	long i = 0;

	/* Calloc memory for the two int arrays, and the solution                 */

	clp_solution = calloc(num_cols, sizeof(double));

	int_index_column_starts = calloc((num_cols + 1), sizeof(int));

	int_row_indices = calloc(num_ent, sizeof(int));

	/* Now, populate the int versions of the two arrays with their values   */

	for(i = 0; i < (num_cols + 1); i++)
	{

		int_index_column_starts[i] = (int)index_column_starts[i];

	}

	for(i = 0; i < num_ent; i++)
	{

		int_row_indices[i] = (int)row_indices[i];

	}

	/* Instantiate the model                                                  */

	clp_model = Clp_newModel();

	/* Suppress the model output                                              */

	Clp_setLogLevel(clp_model, 0);

	/* Have Clp build the model                                               */

	Clp_loadProblem(clp_model, num_cols, num_rows, int_index_column_starts,
			        int_row_indices, values, column_lower_bounds,
					column_upper_bounds, objective_row, row_lower_bounds,
					row_upper_bounds);

#ifdef ADER_INT_TEST

	if(mat > VALID_PTR)
	{

		TESTADERClpModel(clp_model, mat);

	}

#endif

	/* Set the optimization direction                                         */

	Clp_setObjSense(clp_model, (double)opt_dir);

	/* Solve the matrix                                                       */

	Clp_initialSolve(clp_model);

	/* Check the optimality of the solve                                      */

	optimality = Clp_status(clp_model);

	/* BEGIN ADER TEST MOD */

#ifdef ADER_TEST

    if((long)RDB[DATA_TEST_MODE] == YES)
    {

        optimality = 0;

    }

#endif

    /* END ADER TEST MOD */

	if(optimality > 0)
	{

		/* if the solution was not good, error out and give a consolation     */
		/* message                                                            */

		secondary_status = Clp_secondaryStatus(clp_model);

		Error(0, "Attempted solution of the material composition matrix failed.\n\
Clp status value of %ld. Clp secondary status value of %ld.\n\
No other information is available.\n\
Suggestions:\n \
- Check material constraints. Ensure a possible material composition exists.\n \
- Use smaller time steps for burnup calculation.\n \
\n\
Clp Status Error Codes\n \
0 - ( not an error ) optimal solution\n \
1 - primal infeasible\n \
2 - dual infeasible\n \
3 - stopped on iterations, etc ( literally the error code from Clp )\n \
4 - stopped due to errors ( again, literally the error code from Clp )\n \
\n\
Clp Secondary Status Error Codes\n \
0 - none\n \
1 - primal infeasible because dual limit reached \n \
2 - scaled problem optimal; unscaled has primal infeasibilities\n \
3 - scaled problem optimal; unscaled has dual infeasibilities\n \
4 - scaled problem optimal; unscaled has dual and primal infeasibilities\n \
\n\
Dies Irae: \n \
Day of wrath, and doom impending,\n \
David's word with Sibyl's blending:\n \
Heaven and earth in ashes ending.\n \
What shall I, frail man, be pleading?\n \
Who for me be interceding,\n \
When the just are mercy needing?\n", optimality, secondary_status);

	}

	/* Get the solution vector from the model                                 */

	clp_solution  = Clp_primalColumnSolution(clp_model);

	/* copy the solution to the allocated solution vector                     */

	for(i = 0; i < num_cols; i++)
	{

		solution[i] = pow(clp_solution[i], 10.0);

	}

	/* Get the objective value and store it to the last entry in the solution */
	/* array                                                                  */

	solution[num_cols] = Clp_objectiveValue(clp_model);

	/* Yes, these arrays are only in this function and would die otherwise    */
	/* but let's be clean and free them manually                              */

	free(clp_solution);

	free(int_index_column_starts);

	free(int_row_indices);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderstoreburnmatrixcolumn.c                    */
/*                                                                           */
/* Created:       2016/29/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Actually places generated values in the burnup matrix struct */
/*                                                                           */
/* Comments: This function is called from ADERMakeBurnMatrix                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERStoreBurnMatrixColumn:"

long ADERStoreBurnMatrixColumn(struct ccsMatrix* burn_matrix, long col_index,
		                       double* col_vector, long entry_number,
							   long num_rows)
{

	long i = 0;
	long *row_indices = NULL, *column_starts = NULL;
	complex *values_array = NULL;

	/* Get the pointers to the relevant burn matrix components                */

	column_starts = burn_matrix -> colptr;

	row_indices = burn_matrix -> rowind;

	values_array = burn_matrix -> values;

	/* Now, loop through the col_vector and store its non-zero entries        */

	for(i = 0; i < num_rows; i++)
	{

		/* Do not store 0 entries. This is a dense, column major matrix format*/

		if(col_vector[i] != 0.0)
		{

			/* Store the row this value is found in                           */

			row_indices[entry_number] = i;

			/* Store the value, real part then imaginary part                 */

			values_array[entry_number].re = col_vector[i];

			values_array[entry_number].im = 0.0;

			/* Increment the counter                                          */

			entry_number++;

		}

	}

	/* Store the next column start index                                      */

	column_starts[col_index + 1] = entry_number;

	return(entry_number);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderupdatematerialdiscstreameffects.c          */
/*                                                                           */
/* Created:       2016/10/19 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Loops through a material's streams updating it's isotopic    */
/*              composition and density due to changes induced by discreet   */
/*              streams                                                      */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "ADERUpdateMaterialDiscStreamEffects:"

void ADERUpdateMaterialDiscStreamEffects(long adj, long i, long mat)
{

    long ader_mat_stream = 0, mat_ader_data = 0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* If this material is not an ader material, exit this function           */

    if(mat_ader_data < VALID_PTR)
    {

    	return;

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    /* These next four while loops are to process the different streams in */
    /* a material */

    while(ader_mat_stream > VALID_PTR)
    {

    	/* If the stream is a disc type, update the material                  */

    	if(strncmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) == 0)
    	{

    		ADERProcessMaterialDiscStreamEffects(ader_mat_stream, adj, i, mat);

    	}

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	/* If the stream is a disc type, update the material                  */

    	if(strncmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) == 0)
    	{

    		ADERProcessMaterialDiscStreamEffects(ader_mat_stream, adj, i, mat);

    	}

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	/* If the stream is a disc type, update the material                  */

    	if(strncmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) == 0)
    	{

    		ADERProcessMaterialDiscStreamEffects(ader_mat_stream, adj, i, mat);

    	}

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	/* If the stream is a disc type, update the material                  */

    	if(strncmp("disc", GetText(ader_mat_stream + ADER_MAT_STREAM_FORM), 4) == 0)
    	{

    		ADERProcessMaterialDiscStreamEffects(ader_mat_stream, adj, i, mat);

    	}

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(RDB[mat + MATERIAL_ADENS] < 0.0)
    {

    	Error(0,"ADER_ERROR: Application of discrete stream changes to material\n\
density in function ADERUpdateMaterialDiscStreamEffects, following the\n\
solution of the material composition optimization problem, have caused the\n\
material density to be negative. This is most likely the result of a\n\
simulation with mixed discrete and non-discrete streams. The affected\n\
material is %s.\n", GetText(mat + MATERIAL_PTR_NAME));

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : runtests.c                                     */
/*                                                                           */
/* Created:       2015/10/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Executes test cases found in testcases.c                     */
/*                                                                           */
/* Comments:                                                                 */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"
#include "serp_tests.h"

#define FUNCTION_NAME "RunTests:"
/*****************************************************************************/

void RunTests()
{
    int foo = 0;
    int (*test)();
    int test_num_passed = 0;
    int test_num_failed = 0;
    long ader_data, ader_test_block;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    WDB[ader_test_block + ADER_TEST_NUM_CASES] = (double)test_num_cases;

    fprintf(outp, "Running tests. \n");

    for (foo = 0; foo < test_num_cases; foo++)
    {
        test = test_foo_array[foo];
        if (test() > 0)
        {
            test_num_passed += 1;
        }
        else
        {
            test_num_failed += 1;
        }
    }

    if ((test_num_passed + test_num_failed) != test_num_cases)
    {
        Die(FUNCTION_NAME, "Tests passed and failed not equal to number of tests");
    }

    WDB[ader_test_block + ADER_TEST_NUM_PASSED] = (double)test_num_passed;

    WDB[ader_test_block + ADER_TEST_NUM_FAILED] = (double)test_num_failed;

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : serp_tests.h                                   */
/*                                                                           */
/* Created:       2015/10/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Holds test definitions and test pointer list.                */
/*                                                                           */
/* Comments:                                                                 */
/*                                                                           */
/*****************************************************************************/

#ifndef SRC_SERP_TESTS_H_
#define SRC_SERP_TESTS_H_

extern int test_num_cases;
extern int (*test_foo_array[172])();

#endif /* SRC_SERP_TESTS_H_ */
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderallocateclpmemory.c                    */
/*                                                                           */
/* Created:       2016/04/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the allocation of clp memory.                          */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERAllocateClpMemory:"

void TESTADERAllocateClpMemory(long step)
{

    char *const test_name = "ADERAllocateClpMemory";
    char status[5];
    char print_data[256];
    char *mat_name;
    double **clp_arrays;
    double *column_lower_bounds, *column_upper_bounds, *index_column_starts;
    double *objective_row, *row_lower_bounds, *row_indices, *row_upper_bounds;
    double *solution, *values;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_mat_matrix_data, ader_mat_matrix_column;
    long ader_mat_matrix_column_row, ader_test_block;
    long mat, mat_ader_data;
    long counter = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERAllocateClpMemory.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Get the number of non-zero elements in the material composition matrix */

    ader_mat_matrix_column = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(ader_mat_matrix_column > VALID_PTR)
    {

    	ader_mat_matrix_column_row = (long)RDB[ader_mat_matrix_column + ADER_MAT_MATRIX_COL_ROWS_PTR];

    	while(ader_mat_matrix_column_row > VALID_PTR)
    	{

    		if(fabs(RDB[ader_mat_matrix_column_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]) > 1E-33)
    		{

    			counter++;

    		}

    		ader_mat_matrix_column_row = NextItem(ader_mat_matrix_column_row);

    	}

    	ader_mat_matrix_column = NextItem(ader_mat_matrix_column);

    }

    clp_arrays = ADERAllocateClpMemory(ader_mat_matrix_data);

    /* Get the array pointers given by ADERAllocateClpMemory                  */

    column_lower_bounds = clp_arrays[0];

    column_upper_bounds = clp_arrays[1];

    index_column_starts = clp_arrays[2];

    objective_row = clp_arrays[3];

    row_lower_bounds = clp_arrays[4];

    row_indices = clp_arrays[5];

    row_upper_bounds = clp_arrays[6];

    solution = clp_arrays[7];

    values = clp_arrays[8];

    /* Test their length by attempting to assign into them                    */

    column_lower_bounds[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] - 1] = 1.0;

    column_upper_bounds[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] - 1] = 1.0;

    /* the ommisison of the -1 for this array is on purpose                   */
    /* clp requires it to be one additional unit long to hold the objective   */
    /* value                                                                  */

    index_column_starts[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]] = 1.0;

    objective_row[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] - 1] = 1.0;

    row_lower_bounds[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1] = 1.0;

    row_indices[counter - 1] = 1.0;

    row_upper_bounds[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1] = 1.0;

    /* the ommisison of the -1 for the solution index is on purpose           */
    /* it is supposed to be one additional unit long to hold the objective    */
    /* value                                                                  */

    solution[(long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]] = 1.0;

    values[counter - 1] = 1.0;

    /* Deallocate the memory, it isn't needed anymore                         */

    ADERDeallocateTarget(clp_arrays, 9);

    boolean = 1;

    memset(print_data, 0, strlen(print_data));

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderaveragevalue.c                         */
/*                                                                           */
/* Created:       2016/04/17 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the value of the system leakage in the avg spot to     */
/*              test the efficacy of ADERAveageValue                         */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERAverageValue:"

void TESTADERAverageValue(long dep, long step)
{

    char *const test_name = "ADERAverageValue";
    char status[5];
    char print_data[256];
    char *mat_name;
    double expected_leakage, percent_diff, t1, t2, test_value, wBOS, wEOS, wPS1;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERAverageValue.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Calculate the average leakage. Compare to the provided value           */

    t1 = 0.0;

    t2 = 10.0 * 24.0 * 60.0 * 60.0;

    wPS1 = RDB[DATA_BURN_FIT_C2W1]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3
      + RDB[DATA_BURN_FIT_C1W1]*(t2*t2-t1*t1)/(t2-t1)/2
      + RDB[DATA_BURN_FIT_C0W1];

    wBOS = RDB[DATA_BURN_FIT_C2W2]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3
      + RDB[DATA_BURN_FIT_C1W2]*(t2*t2-t1*t1)/(t2-t1)/2
      + RDB[DATA_BURN_FIT_C0W2];

    wEOS = RDB[DATA_BURN_FIT_C2W3]*(t2*t2*t2-t1*t1*t1)/(t2-t1)/3
      + RDB[DATA_BURN_FIT_C1W3]*(t2*t2-t1*t1)/(t2-t1)/2
      + RDB[DATA_BURN_FIT_C0W3];

    expected_leakage = wBOS * RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS] +
                       wEOS * RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS] +
                       wPS1 * RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1];

    test_value = ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
							      RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
								  RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
								  t1, t2, dep);

    sprintf(print_data, "Material FLiBeFuel has AVG leakage of %f.\n \
Needs AVG leakage of %f.\n", test_value,
            expected_leakage);

    percent_diff = fabs((test_value - expected_leakage) / expected_leakage);

    if(percent_diff < 0.0001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderbuildclpmodel.c                        */
/*                                                                           */
/* Created:       2016/04/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the creation of the clp model, stored in arrays        */
/*              provided by ADERAllocateClpMemory                            */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERBuildClpModel:"

void TESTADERBuildClpModel(long step)
{

    char *const test_name = "ADERBuildClpModel";
    char status[5];
    char print_data[256];
    char *mat_name;
    double **clp_arrays;
    double *column_lower_bounds, *column_upper_bounds, *index_column_starts;
    double *objective_row, *row_lower_bounds, *row_indices, *row_upper_bounds;
    double *values;
    int append = 0;
    int boolean = 0, boolean_clb = 0, boolean_cub = 0, boolean_ics = 0;
    int boolean_or = 0, boolean_rlb = 0, boolean_ri = 0, boolean_rub = 0;
    int boolean_v = 0;
    long ader_data, ader_mat_iso, ader_mat_matrix_data, ader_mat_stream;
	long ader_test_block;
    long beryllium_stream_col_id, flibefuel_u233_row_id, mat, mat_ader_data;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERBuildClpModel.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    clp_arrays = ADERAllocateClpMemory(ader_mat_matrix_data);

    /* Get the array pointers given by ADERAllocateClpMemory                  */

    column_lower_bounds = clp_arrays[0];

    column_upper_bounds = clp_arrays[1];

    index_column_starts = clp_arrays[2];

    objective_row = clp_arrays[3];

    row_lower_bounds = clp_arrays[4];

    row_indices = clp_arrays[5];

    row_upper_bounds = clp_arrays[6];

    /* the solution array isn't needed so don't get it                        */

    values = clp_arrays[8];

    /* Pass these arrays to build for value filling                           */

    ADERBuildClpModel(ader_mat_matrix_data, column_lower_bounds,
    		          column_upper_bounds, index_column_starts,
					  objective_row, row_lower_bounds,
					  row_indices, row_upper_bounds, values);

    /* Fist test the column_lower_bounds                                      */

    if(column_lower_bounds[0] < 0.2000001 &&
       column_lower_bounds[0] > 0.1999999)
    {

    	boolean_clb = 1;

    }

    /* Fist test the column_upper_bounds                                      */

    if(column_upper_bounds[0] < 1.0000001 &&
       column_upper_bounds[0] > 0.9999999)
    {

    	boolean_cub = 1;

    }

    /* Test index_column_starts                                               */

    if((long)index_column_starts[1] == 11)
    {

    	boolean_ics = 1;

    }

    /* Test objective row                                                     */

    /* Get Beryllium redox stream column id                                   */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Beryllium", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		beryllium_stream_col_id = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID];

    		break;

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if((long)objective_row[beryllium_stream_col_id] == 1)
    {

    	boolean_or = 1;

    }

    /* Test row_lower_bound                                                   */

    /* Get U-233 iso bal row                                                  */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
    	{

    		flibefuel_u233_row_id = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BAL_ROW_ID];

    		break;

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* This number coming from the amount of U233 in FLiBeFuel should decrease*/

    if(row_lower_bounds[flibefuel_u233_row_id] < 0.000137 &&
       row_lower_bounds[flibefuel_u233_row_id] > 0.000135)
    {

    	boolean_rlb = 1;

    }

    /* Test row_indices, first value should be zero for ActF rto row with     */
    /* FLiBe group in FLiBeFuel                                               */

    if((long)row_indices[0] == 0)
    {

    	boolean_ri = 1;

    }

    /* Test row_upper_bounds                                                  */

    if(row_upper_bounds[flibefuel_u233_row_id] < 0.000137 &&
       row_upper_bounds[flibefuel_u233_row_id] > 0.000135)
    {

    	boolean_rub = 1;

    }

    /* Test values                                                            */

    if(values[0] < -0.999999 &&
       values[0] > -1.000001)
    {

    	boolean_v = 1;

    }

    /* Deallocate the memory, it isn't needed anymore                         */

    ADERDeallocateTarget(clp_arrays, 9);

    if(boolean_clb == 1 &&
       boolean_cub == 1 &&
	   boolean_ics == 1 &&
       boolean_or ==  1 &&
	   boolean_rlb == 1 &&
	   boolean_ri ==  1 &&
	   boolean_rub == 1 &&
	   boolean_v ==   1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        sprintf(print_data, "See following data for a breakdown of sub unit tests.\n");

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_clb == 0)
        {

        	sprintf(print_data, "Test: column_lower_bound: FAIL - First value has as value %f\n \
but needs value 0.2.\n",
        			column_lower_bounds[0]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: column_lower_bound: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_cub == 0)
        {

        	sprintf(print_data, "Test: column_upper_bound: FAIL - First value has value %f\n \
but needs value 1.0.\n",
        			column_upper_bounds[0]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: column_upper_bound: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    	if(boolean_ics == 0)
    	{

        	sprintf(print_data, "Test: index_column_starts: FAIL - Second value has value %f\n \
but needs value 11.\n",
        			index_column_starts[1]);

        	PrintTest(test_name, status, print_data, 1);

    	}
        else
        {

        	sprintf(print_data, "Test: index_column_starts: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_or == 0)
        {

        	sprintf(print_data, "Test: objective_row : FAIL - Index %ld has value %f but needs value 1.\n",
        			beryllium_stream_col_id, objective_row[beryllium_stream_col_id]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: objective_row: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    	if(boolean_rlb == 0)
    	{

        	sprintf(print_data, "Test: row_lower_bounds : FAIL - Index %ld has value %f\n \
but needs value 0.0085033.\n",
        			flibefuel_u233_row_id,
					row_lower_bounds[flibefuel_u233_row_id]);

        	PrintTest(test_name, status, print_data, 1);

    	}
        else
        {

        	sprintf(print_data, "Test: row_lower_bounds: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    	if(boolean_ri == 0)
    	{

        	sprintf(print_data, "Test: row_indices: FAIL - First value has value %f but needs value 0.\n",
        			row_indices[0]);

        	PrintTest(test_name, status, print_data, 1);

    	}
        else
        {

        	sprintf(print_data, "Test: row_indices: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    	if(boolean_rub == 0)
    	{

        	sprintf(print_data, "Test: row_upper_bounds : FAIL - Index %ld has value %f\n \
but needs value 0.0085033.\n",
        			flibefuel_u233_row_id,
					row_upper_bounds[flibefuel_u233_row_id]);

        	PrintTest(test_name, status, print_data, 1);

    	}
        else
        {

        	sprintf(print_data, "Test: row_upper_bounds: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_v == 0)
        {

        	sprintf(print_data, "Test: values : FAIL - First entry has value %f\n \
but needs value 1.\n",
        			values[0]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: values: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderclearpropstreamamts.c                  */
/*                                                                           */
/* Created:       2017/01/13 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that ADERClearPropStreamAmts does indeed set the       */
/*              CUR_AMT and ADJ_AMT to 0 for all prop streams                */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERClearPropStreamAmts:"

void TESTADERClearPropStreamAmts(long mat)
{

    char *const test_name = "ADERClearPropStreamAmts";
    char status[5];
    char print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data;
    long ader_mat_stream;
    long ader_test_block, mat_ader_data, test_value;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERClearPropStreamAmts.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel has no remv streams. \n");

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has remv streams but no reproc stream.\n");

        if(strcmp("reproc", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Set the cur_amt and adj_amt to some number                             */

    WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 5.0;

    WDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] = 3.0;

    ADERClearPropStreamAmts(0, mat);

    sprintf(print_data, "Material FLiBeFuel has reproc stream with CUR_AMT of \n \
%f and ADJ_AMT of %f.\n", RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT],
            RDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT]);

    if((RDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] == 0.0) &&
       (RDB[ader_mat_stream + ADER_MAT_STREAM_ADJ_AMT] == 0.0))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : aderoutputmaterialcompmatrixdata.c             */
/*                                                                           */
/* Created:       2017/08/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Compares the Clp matrix model generated from the material    */
/*              composition optimization matrix with said matrix             */
/*                                                                           */
/* Comments:This function is called from ADERSolveClpModel                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"
#include "Clp_C_Interface.h"

#define FUNCTION_NAME "TESTADERClpModel:"

void TESTADERClpModel(Clp_Simplex* clp_model, long mat)
{

    char print_data[256];
    FILE *fp;
	const CoinBigIndex *clp_col_starts;
	double *clp_col_lower_bounds, *clp_col_upper_bounds;
	const double *clp_matrix_elements;
	double *clp_objective_row, *clp_row_lower_bounds, *clp_row_upper_bounds;
	double percent_diff;
	int clp_num_elements = 0;
	const int *clp_row_indices, *clp_col_lengths;
	long clp_num_cols = 0, clp_num_rows = 0, num_errors = 0;
	long ader_mat_data, ader_mat_matrix_col, ader_mat_matrix_col_row;
	long ader_mat_matrix_data, ader_mat_matrix_row_bound, found;
	int i, j, k;

	/* Create the file name                                                   */

	sprintf(print_data, "ADER_Clp_Model_Material_%s_Conformity.test",
			GetText(mat + MATERIAL_PTR_NAME));

	if ((fp = fopen(print_data, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open file for writing Clp matrix conformity results.\n");

	}

	fprintf(outp, "Beginning Clp matrix conformity check for material %s.\n\n",
			GetText(mat + MATERIAL_PTR_NAME));

	/* Grab the clp data                                                      */

	clp_col_lengths = Clp_getVectorLengths(clp_model);

	clp_col_lower_bounds = Clp_columnLower(clp_model);

	clp_col_starts = Clp_getVectorStarts(clp_model);

	clp_col_upper_bounds = Clp_columnUpper(clp_model);

	clp_matrix_elements = Clp_getElements(clp_model);

	clp_num_cols = Clp_numberColumns(clp_model);

	clp_num_elements = Clp_getNumElements(clp_model);

	clp_num_rows = Clp_numberRows(clp_model);

	clp_objective_row = Clp_objective(clp_model);

	clp_row_indices = Clp_getIndices(clp_model);

	clp_row_lower_bounds = Clp_rowLower(clp_model);

	clp_row_upper_bounds = Clp_rowUpper(clp_model);

	fprintf(fp, "Clp number of matrix elements is %i \n", clp_num_elements);

	/* Grab the material matrix data                                          */

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

	/* Loop through the clp data checking it against the material matrix data */

	for(i = 0; i < clp_num_cols; i++)
	{

		if(clp_col_lengths[i] != (clp_col_starts[i + 1] - clp_col_starts[i]))
		{

			fprintf(fp, "Clp column vector length is %i but Clp column starts difference is %i for\n\
column %i.\n",     clp_col_lengths[i],
(clp_col_starts[i + 1] - clp_col_starts[i]), i);

		}

		/* Retrieve the material matrix column                                */

		ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

		for(j = 0; j < i; j++)
		{

			ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

		}

		/* Check the bounds                                                   */

		percent_diff = (RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND] - clp_col_lower_bounds[i])/
				       clp_col_lower_bounds[i];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Clp column %i has lower bound %1.16E while matrix column has\n\
lower bound of %1.16E.\n\
Material matrix column RDB address: %ld\n", i, clp_col_lower_bounds[i],
	                RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND],
					ader_mat_matrix_col);

			num_errors++;

		}

		percent_diff = (RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND] - clp_col_upper_bounds[i])/
				       clp_col_upper_bounds[i];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Clp column %i has upper bound %1.16E while matrix column has\n\
upper bound of %1.16E.\n\
Material matrix column RDB address: %ld\n", i, clp_col_lower_bounds[i],
	                RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND],
					ader_mat_matrix_col);

			num_errors++;

		}

		/* Check the entries                                                  */

		for(j = clp_col_starts[i]; j < clp_col_starts[i + 1]; j++)
		{

			/* Get the appropriate row from the material matrix               */

			ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

			for(k = 0; k < clp_row_indices[j]; k++)
			{

				ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

			}

			percent_diff = (RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] - clp_matrix_elements[j])/
					       clp_matrix_elements[j];

			if(fabs(percent_diff) > 0.001)
			{

				fprintf(fp, "Clp matrix has value %1.15E at matrix location [ %i , %i ]\n\
while material matrix has value %1.15E.\n\
Material matrix column RDB address: %ld\n\
Material matrix column row RDB address: %ld\n", clp_matrix_elements[j],
						clp_row_indices[j], i,
                        RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
						ader_mat_matrix_col, ader_mat_matrix_col_row);

				num_errors++;

			}

		}

		/* Check the objective row                                            */

		/* Get the objective row from the material matrix                     */

		ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

		for(k = 0; k < clp_num_rows - 1; k++)
		{

			ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

		}

		percent_diff = (RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] - clp_objective_row[i])/
				       clp_objective_row[i];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Clp objective row has value %1.15E while material matrix objective\n\
	has value %1.15E.\n\
	Material matrix column RDB address: %ld\n\
	Material matrix column row RDB address: %ld\n", clp_objective_row[i],
	                RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
					ader_mat_matrix_col, ader_mat_matrix_col_row);

			num_errors++;

		}

	}

	/* Now check the row bounds                                               */

	ader_mat_matrix_row_bound = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

	for(i = 0; i < clp_num_rows; i++)
	{

		percent_diff = (RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] - clp_row_lower_bounds[i])/
                       clp_row_lower_bounds[i];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Clp row %i has lower bound %1.16E while matrix row has\n\
lower bound of %1.16E.\n\
Material matrix row bound RDB address: %ld\n", i, clp_row_lower_bounds[i],
	                RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
					ader_mat_matrix_row_bound);

			num_errors++;

		}

		percent_diff = (RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] - clp_row_upper_bounds[i])/
                       clp_row_upper_bounds[i];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Clp row %i has upper bound %1.16E while matrix row has\n\
upper bound of %1.16E.\n\
Material matrix row bound RDB address: %ld\n", i, clp_row_upper_bounds[i],
	                RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND],
					ader_mat_matrix_row_bound);

			num_errors++;

		}

		ader_mat_matrix_row_bound = NextItem(ader_mat_matrix_row_bound);

	}

	/* Now do the reverse check. Loop through the material matrix data and    */
	/* check it against the clp data                                          */

	ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

	for(i = 0; i < (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS]; i++)
	{

		/* Check the column bounds                                            */

		percent_diff = (clp_col_lower_bounds[i] - RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND])/
				       RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Matrix column %i has lower bound %1.16E while clp column has\n\
lower bound of %1.16E.\n\
Material matrix column RDB address: %ld\n", i, RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND],
                    clp_col_lower_bounds[i],
					ader_mat_matrix_col);

			num_errors++;

		}

		percent_diff = (clp_col_upper_bounds[i] - RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND])/
				       RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Matrix column %i has upper bound %1.16E while clp column has\n\
upper bound of %1.16E.\n\
Material matrix column RDB address: %ld\n", i, RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND],
                    clp_col_upper_bounds[i],
					ader_mat_matrix_col);

			num_errors++;

		}

		/* Now check the matrix entries                                       */

		ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

		for(j = 0; j < (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1; j++)
		{

			if(RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] != 0.0)
			{

				found = 0;

				for(k = clp_col_starts[i]; k < clp_col_starts[i + 1]; k++)
				{

					if(clp_row_indices[k] == j)
					{

						found = 1;

						break;

					}

				}

				if(found < 1)
				{

					fprintf(fp, "No matching clp matrix entry was found for material matrix entry located at\n\
[ %i , %i ].\n\
Material matrix column RDB address: %ld\n\
MAterial matrix column row address: %ld\n", j, i, ader_mat_matrix_col,
                            ader_mat_matrix_col_row);

					num_errors++;

				}
				else
				{

					percent_diff = (clp_matrix_elements[k] - RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY])/
							       RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

					if(fabs(percent_diff) > 0.001)
					{

						fprintf(fp, "Material matrix has value %1.15E at matrix location [ %i , %i ]\n\
while clp matrix has value %1.15E.\n\
Material matrix column RDB address: %ld\n\
Material matrix column row RDB address: %ld\n", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
								j , i,
		                        clp_matrix_elements[k],
								ader_mat_matrix_col, ader_mat_matrix_col_row);

						num_errors++;

					}

				}

			}

			ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

		}

		/* Now check the objective row                                        */

		percent_diff = (clp_objective_row[i] - RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY])/
				       RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Material objective row has value %1.15E while clp matrix objective\n\
has value %1.15E.\n\
Material matrix column RDB address: %ld\n\
Material matrix column row RDB address: %ld\n", RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
					clp_objective_row[i],
					ader_mat_matrix_col, ader_mat_matrix_col_row);

			num_errors++;

		}

		ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

	}

	/* Now check the row bounds                                               */

	ader_mat_matrix_row_bound = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

	for(i = 0; i < (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1; i++)
	{

		percent_diff = (clp_row_lower_bounds[i] - RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND])/
				       RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Material matrix row %i has lower bound %1.16E while clp row has\n\
lower bound of %1.16E.\n\
Material matrix row bound RDB address: %ld\n", i,
                    RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
                    clp_row_lower_bounds[i],
					ader_mat_matrix_row_bound);

			num_errors++;

		}

		percent_diff = (clp_row_upper_bounds[i] - RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND])/
				       RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

		if(fabs(percent_diff) > 0.001)
		{

			fprintf(fp, "Material matrix row %i has upper bound %1.16E while clp row has\n\
upper bound of %1.16E.\n\
Material matrix row bound RDB address: %ld\n", i,
	                RDB[ader_mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND],
					clp_row_upper_bounds[i],
					ader_mat_matrix_row_bound);

			num_errors++;

		}

		ader_mat_matrix_row_bound = NextItem(ader_mat_matrix_row_bound);

	}

	if(num_errors == 0)
	{

		fprintf(fp, "No discrepancies were found between the Clp matrix and the material composition\n\
matrix.\n");

	}
	else
	{

		fprintf(fp, "%ld total discrepancies were found between the Clp matrix\n\
and the material composition matrix.\n", num_errors);

	}

	/* Close the file                                                         */

	fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadercompareburnmatrices.c                  */
/*                                                                           */
/* Created:       2018/03/08 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: This test takes in a burn matrix as made by ADER. It then    */
/*              generates a burn matrix for each cluster member and          */
/*              compares the entries for all isotope entries, it ignores     */
/*              stream entries. This function outputs to file.                */
/*                                                                           */
/* Comments: This function is called from ADERBurnMaterials                  */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERCompareBurnMatrices:"

void TESTADERCompareBurnMatrices(struct ccsMatrix *ader_burn_matrix, long mat,
		                         long step, long sub_step)
{
    char file_out[256];
    long isos_index[10000];
    long ader_mat_cluster_ent, ader_mat_cluster_mem;
    long ader_mat_cluster_mem_ader_iso_1, ader_mat_cluster_mem_ader_iso_2;
    long ader_mat_cluster_mem_data;
    long ader_mat_cluster_mem_mat_iso, ader_mat_data, found_1, found_2;
    long i, nuc, serp_index_1, serp_index_2, zai_1, zai_2;
    double ader_matrix_value, percent_diff, serp_matrix_value;
    FILE *fp;
    struct ccsMatrix *serp_burn_matrix;

    /* Go ahead and create the file name                                      */

	if((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP)
	{

	    sprintf(file_out, "Cluster_Parent_%s_Pred_Step_%ld_Sub_Step_%ld_Matrix_Comparison.test",
	    		GetText(mat + MATERIAL_PTR_NAME), step, sub_step);

	}
	else
	{

	    sprintf(file_out, "Cluster_Parent_%s_Corr_Step_%ld_Corr_Sub_Step_%ld_Matrix_Comparison.test",
	    		GetText(mat + MATERIAL_PTR_NAME), step, sub_step);

	}



	if ((fp = fopen(file_out, "w")) == NULL)
	{

		Die(FUNCTION_NAME, "Unable to open cluster csv file for writing");

	}

	ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Loop through the cluster members to check the components of each of    */
	/* their burnup matrices                                                  */

	ader_mat_cluster_ent = (long)RDB[ader_mat_data + ADER_MAT_CLUSTER_MEMS_PTR];

	while(ader_mat_cluster_ent > VALID_PTR)
	{

		ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

		ader_mat_cluster_mem_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

		fprintf(fp, "Begin cluster member %s burnup matrix comparison:\n",
				GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME));

		/* Get the serpent created burnup matrix to compare with              */

		serp_burn_matrix = MakeBurnMatrix(ader_mat_cluster_mem, 0);

		/* Loop through the material's serpent isotopes to get their burn     */
		/* indices, this method is taken from MakeBurnMatrix                  */

		i = 0;

		ader_mat_cluster_mem_mat_iso = (long)RDB[ader_mat_cluster_mem + MATERIAL_PTR_COMP];

		while(ader_mat_cluster_mem_mat_iso > VALID_PTR)
		{

			nuc = (long)RDB[ader_mat_cluster_mem_mat_iso + COMPOSITION_PTR_NUCLIDE];

			isos_index[i] = (long)RDB[nuc + NUCLIDE_ZAI];

			i++;

			ader_mat_cluster_mem_mat_iso = NextItem(ader_mat_cluster_mem_mat_iso);

		}

		/* Now, loop through the ader isotopes, and compare the burnup matrix */
		/* information                                                        */

		ader_mat_cluster_mem_ader_iso_1 = (long)RDB[ader_mat_cluster_mem_data + ADER_MAT_ISOS_PTR];

		while(ader_mat_cluster_mem_ader_iso_1 > VALID_PTR)
		{

			ader_mat_cluster_mem_mat_iso = (long)RDB[ader_mat_cluster_mem_ader_iso_1 + ADER_MAT_ISO_PTR];

			nuc = (long)RDB[ader_mat_cluster_mem_mat_iso + COMPOSITION_PTR_NUCLIDE];

			zai_1 = (long)RDB[nuc + NUCLIDE_ZAI];

			found_1 = 0;

			/* Get the isotope index corresponding to this zai                */

			for(i = 0; i < 10000; i++)
			{

				if(isos_index[i] == zai_1)
				{

					serp_index_1 = i;

					found_1 = 1;

					break;

				}

			}

			if(found_1 < 1)
			{

				Die(FUNCTION_NAME, "TESTADERCompareBurnMatrices could not find a matching isotope\n\
	for ADER isotope %ld found at WDB:%ld in the SERPENT isotope index list.\n",
	                zai_1, ader_mat_cluster_mem_ader_iso_1);

			}

			/* Loop through the ader isotopes again, this is how we check the */
			/* information given to each isotope                              */

			ader_mat_cluster_mem_ader_iso_2 = (long)RDB[ader_mat_cluster_mem_data + ADER_MAT_ISOS_PTR];

			while(ader_mat_cluster_mem_ader_iso_2 > VALID_PTR)
			{

				percent_diff = 0.0;

				ader_mat_cluster_mem_mat_iso = (long)RDB[ader_mat_cluster_mem_ader_iso_2 + ADER_MAT_ISO_PTR];

				nuc = (long)RDB[ader_mat_cluster_mem_mat_iso + COMPOSITION_PTR_NUCLIDE];

				zai_2 = (long)RDB[nuc + NUCLIDE_ZAI];

				found_2 = 0;

				/* Get the isotope index corresponding to this zai            */

				for(i = 0; i < 10000; i++)
				{

					if(isos_index[i] == zai_2)
					{

						serp_index_2 = i;

						found_2 = 1;

						break;

					}

				}

				if(found_2 < 1)
				{

					Die(FUNCTION_NAME, "TESTADERCompareBurnMatrices could not find a matching isotope\n\
		for ADER isotope %ld found at WDB:%ld in the SERPENT isotope index list.\n",
		                zai_2, ader_mat_cluster_mem_ader_iso_2);

				}

				/* Now, retreive both values from their respective matrices   */
				/* and compare them.                                          */

				ader_matrix_value = ADERGetBurnMatrixValue((long)RDB[ader_mat_cluster_mem_ader_iso_2 + ADER_MAT_ISO_BURN_INDEX],
						                                   ader_burn_matrix,
														   (long)RDB[ader_mat_cluster_mem_ader_iso_1 + ADER_MAT_ISO_BURN_INDEX]);

				serp_matrix_value = ADERGetBurnMatrixValue(serp_index_2,
						                                   serp_burn_matrix,
														   serp_index_1);

				if(serp_matrix_value == 0.0)
				{

					if(ader_matrix_value == 0.0)
					{

						percent_diff = 0.0;

					}
					else
					{

						percent_diff = 100.00;
					}

				}
				else
				{

					percent_diff = ((ader_matrix_value - serp_matrix_value) / serp_matrix_value) * 100.0;

				}

				if(percent_diff > 1.0)
				{

					fprintf(fp, "    Percent Diff: %.2f\n\
                                         Row Iso:  %ld\n\
                                         Col Iso:  %ld\n\
                                         ADER Ind: [%ld, %ld]\n\
                                         Serp Ind: [%ld, %ld]\n\
                                         ADER Val: %.32f\n\
                                         SERP Val: %.32f\n",
	                       percent_diff, zai_1, zai_2,
						   (long)RDB[ader_mat_cluster_mem_ader_iso_1 + ADER_MAT_ISO_BURN_INDEX],
						   (long)RDB[ader_mat_cluster_mem_ader_iso_2 + ADER_MAT_ISO_BURN_INDEX],
						   serp_index_1, serp_index_2, ader_matrix_value,
						   serp_matrix_value);

				}

				ader_mat_cluster_mem_ader_iso_2 = NextItem(ader_mat_cluster_mem_ader_iso_2);

			}

			ader_mat_cluster_mem_ader_iso_1 = NextItem(ader_mat_cluster_mem_ader_iso_1);

		}

		fprintf(fp, "********************************************************************************\n");

		/* Free the memory for this cluster member's serpent burnup matrix    */

	    ccsMatrixFree(serp_burn_matrix);

		ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

	}

	/* Close the file                                                         */

	fclose(fp);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadercopymaterialflux.c                     */
/*                                                                           */
/* Created:       2016/04/18 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that ADERCopyMaterialFlux is working (kind of, this is */
/*              not a rigerous test                                          */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*          It will only pass in the case of not SIE ( single iteration euler*/
/*          set by serpent option 'sie' ) though it designed for SIE. This   */
/*          said, the principle by which it operates, if it operates         */
/*          correctly in PCC mode it will most likely work in SIE            */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERCopyMaterialFlux:"

void TESTADERCopyMaterialFlux(long step)
{

    char *const test_name = "ADERCopyMaterialFlux";
    char status[5];
    char print_data[256];
    char *mat_name;
    double percent_diff;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the second step and a corrector iteration   */

    if((step != 1) && ((long)RDB[DATA_BURN_STEP_PC] == PREDICTOR_STEP))
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERCopyMaterialFlux.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Compare old and new flux, they should be the same                      */



    sprintf(print_data, "Material FLiBeFuel has new flux of %f\n \
and has old flux of %f.\n", RDB[mat_ader_data + ADER_MAT_FLUX_NEW_AVG],
            RDB[mat_ader_data + ADER_MAT_FLUX_OLD_AVG]);

    percent_diff = fabs((RDB[mat_ader_data + ADER_MAT_FLUX_OLD_AVG] -
                        RDB[mat_ader_data + ADER_MAT_FLUX_NEW_AVG]) /
                        RDB[mat_ader_data + ADER_MAT_FLUX_NEW_AVG]);

    if(percent_diff < 0.0001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadercountstream.c                          */
/*                                                                           */
/* Created:       2016/21/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that ADERCountStream returns an appropriate value.     */
/*              WARNING!!! Tests for stream index assignment are done in the */
/*              TESTADERGetBurnMatrixData test for simplicity                */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERCountStream:"

void TESTADERCountStream(long mat)
{

    char *const test_name = "ADERCountStream";
    char status[5];
    char print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data;
    long ader_mat_stream;
    long ader_test_block, mat_ader_data, test_value;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERCountStream.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel has no streams. \n");

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has feed streams but no ActF stream.\n");

        /* Even though this stream would not be processed by count streams    */
        /* we still use it here because it is otherwise equiavlent to a sum   */
        /* stream that would be fed into the function                         */

        if(strcmp("ActF", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* We pass 0 for "num_rows" because it doesn't matter for this test       */

    test_value = ADERCountStream(ader_mat_stream, 0, 0);

    sprintf(print_data, "Material FLiBeFuel feed stream ActF has \n \
bad stream count of %ld and needs 2.\n", test_value);

    if(test_value == 2)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderfillmatcompmatrixpresmolsrow.c     */
/*                                                                           */
/* Created:       2016/13/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that the a "mols" pres row is filled properly with     */
/*              adens weighted streams                                       */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERFillMatCompMatrixPresMolsRow:"

void TESTADERFillMatCompMatrixPresMolsRow(long step)
{

    char *const test_name = "ADERFillMatCompMatrixPresMolsRow";
    char status[5];
    char print_data[256];
    long ader_data, ader_test_block;
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, dest_mat_adens, src_mat_adens, percent_diff;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_preserve_ent, mat_preserve_row, mat_stream, mat_stream_target_col;
    long shadow_stream, src_mat;
    long i;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERFillMatCompMatrixPresMolsRow.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    dest_mat_adens = RDB[mat + MATERIAL_ADENS];

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has redox streams but no Fluorine stream.\n");

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", mat_stream_name, 8) == 0)
        {

            shadow_stream = (long)RDB[mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            src_mat = (long)RDB[shadow_stream + ADER_MAT_STREAM_MAT_PTR];

            src_mat_adens = RDB[src_mat + MATERIAL_ADENS];

            adens_corr_factor = src_mat_adens / dest_mat_adens;

            sprintf(print_data, "FLiBeFuel has Fluorine redox stream but no preserve entries.\n");

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_preserve_ent = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    while(mat_preserve_ent > VALID_PTR)
    {

        if(strncmp("mols", GetText(mat_preserve_ent + ADER_MAT_PRESERVE_ENT), 4) == 0)
        {

            mat_preserve_row = (long)RDB[mat_preserve_ent + ADER_MAT_PRESERVE_ROW_ID];

            break;

        }

        mat_preserve_ent = NextItem(mat_preserve_ent);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_preserve_row; i++)
    {

        mat_matrix_row = NextItem(mat_matrix_row);

    }

    sprintf(print_data, "FLiBeFuel matrix column %ld preserve row, %ld, has value %f and needs value %f.\n",
            mat_preserve_row, mat_stream_target_col,
            RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
            adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] - adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderfixcomposition.c                       */
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Fixed negative material composition adens due to non-physical*/
/*              ADER operations executed for testing.                        */
/*                              THIS IS NOT TESTING AN ACTUAL FUNCTION       */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERFixComposition:"

void TESTADERFixComposition(long step)
{

	long mat, mat_iso;

	/* loop through the mats                                                  */

	mat = (long)RDB[DATA_PTR_M0];

	while(mat > VALID_PTR)
	{

		mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

		while(mat_iso > VALID_PTR)
		{

			if(RDB[mat_iso + COMPOSITION_ADENS] < 0.0)
			{

				WDB[mat_iso + COMPOSITION_ADENS] = 0.0;

			}

			mat_iso = NextItem(mat_iso);

		}

		mat= NextItem(mat);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadergetburnmatrixsizedata.c                */
/*                                                                           */
/* Created:       2016/21/10 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests 7 things:                                              */
/*              Tests that ADERGetBurnMatrixNumRows returns the correct      */
/*              number of rows which is the sum total of all isotopes and    */
/*              streams ( not double counting shadows ) in all materials     */
/*              of a cluster. Also tests total array size allocation and     */
/*              the material boundary breaks. This also tests the            */
/*              ADERAllocateBurnMatrixSizeMemory function. Additionally tests*/
/*              that streams ( not disc ) and sum streams ( not disc ) are   */
/*              given proper vector indices. While testing of the stream     */
/*              index assignment could have gone in the count stream test    */
/*              the necessary row information was already going to be in     */
/*              this test so the testing is done here. Additionally tests    */
/*              that ader isotopes are given the proper index and that the   */
/*              correct number of non-zero burn entries is returned          */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERGetBurnMatrixSizeData:"

void TESTADERGetBurnMatrixSizeData(long mat)
{

    char *const test_name = "ADERGetBurnMatrixSizeData";
    char status[5];
    char print_data[256];
    double **ader_burn_matrix_size_info, *ader_burn_matrix_starts;
    double *ader_burn_matrix_num_ents, *ader_burn_matrix_num_rows;
    double *ader_burn_matrix_N0;
    double *ader_burn_matrix_col_storage;
    int append = 0;
    int boolean = 0, boolean_allocation = 0, boolean_iso_index = 0;
    int boolean_non_zero = 0;
    int boolean_starts = 0, boolean_num_rows = 0, boolean_stream_index = 0;
    int boolean_stream_sum_index = 0;
    long ader_data, ader_mat_cluster_ent, ader_mat_cluster_mem;
    long ader_mat_cluster_mem_ader_data, ader_mat_cluster_mem_stream;
    long ader_mat_stream, ader_mat_stream_index, ader_mat_iso;
    long ader_mat_stream_sum, ader_mat_stream_sum_ent, ader_mat_stream_sum_index;
    long ader_test_block, mat_ader_data, mat_iso, nuc;
    long test_value_iso_index, test_value_num_rows, test_value_starts;
    long test_value_stream_index;
    long test_value_stream_sum_index;
    long expected_non_zero_entries = 0, num_isos = 0, num_rows = 0;
    long num_flibefuel_rows = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERGetBurnMatrixSizeData.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel burn matrix has bad matrix gen. \n");

    /* Count the isotopes in all cluster members and the non-zero burn entries*/

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    while(ader_mat_cluster_ent > VALID_PTR)
    {

    	ader_mat_cluster_mem = (long)RDB[ader_mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

    	ader_mat_cluster_mem_ader_data = (long)RDB[ader_mat_cluster_mem + MATERIAL_ADER_DATA];

    	/* Also collect the SERPENT number of non-zero entries in a burn matrix*/

    	expected_non_zero_entries += BurnMatrixSize(ader_mat_cluster_mem);

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_FEED_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	if((strncmp("cont",
    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					4) == 0) ||
    	        (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
    		     (strncmp("prop",
    			   	      GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
    			          4) == 0)))
	    	{

	    		expected_non_zero_entries = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
		    			                                        expected_non_zero_entries);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REAC_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	if((strncmp("cont",
    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					4) == 0) ||
    	        (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
    		     (strncmp("prop",
    			   	      GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
    			          4) == 0)))
	    	{

	    		expected_non_zero_entries = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
		    			                                        expected_non_zero_entries);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	if((strncmp("cont",
    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					4) == 0) ||
    	        (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
    		     (strncmp("prop",
    			   	      GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
    			          4) == 0)))
	    	{

	    		expected_non_zero_entries = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
		    			                                        expected_non_zero_entries);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

	    ader_mat_cluster_mem_stream = (long)RDB[ader_mat_cluster_mem_ader_data + ADER_MAT_REMV_STREAMS_PTR];

	    while(ader_mat_cluster_mem_stream > VALID_PTR)
	    {

	    	if((strncmp("cont",
    			    GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
					4) == 0) ||
    	        (((long)RDB[ader_mat_cluster_mem_stream + ADER_MAT_STREAM_SHADOW_PTR] < VALID_PTR) &&
    		     (strncmp("prop",
    			   	      GetText(ader_mat_cluster_mem_stream + ADER_MAT_STREAM_FORM),
    			          4) == 0)))
	    	{

	    		expected_non_zero_entries = ADERCountStreamIsos(ader_mat_cluster_mem_stream,
		    			                                        expected_non_zero_entries);

	    	}

	    	ader_mat_cluster_mem_stream = NextItem(ader_mat_cluster_mem_stream);

	    }

    	if(strncmp("FLiBeFuel", GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME), 9) == 0)
    	{

    		num_flibefuel_rows = num_rows;

    	}

    	mat_iso = (long)RDB[ader_mat_cluster_mem + MATERIAL_PTR_COMP];

    	while(mat_iso > VALID_PTR)
    	{

    		num_rows++;

    		mat_iso = NextItem(mat_iso);

    	}

    	if(strncmp("FLiBeFuel", GetText(ader_mat_cluster_mem + MATERIAL_PTR_NAME), 9) == 0)
    	{

    		num_flibefuel_rows = num_rows - num_flibefuel_rows;

    		num_isos = num_flibefuel_rows;

    	}

    	ader_mat_cluster_ent = NextItem(ader_mat_cluster_ent);

    }

    /* The number of streams, as assigned to all members of the FLiBeFuel     */
    /* cluster, minus discreet streams, is 10 including the components of sum */
    /* streams. We add 1 because of 0 indexing                                */

    num_rows = num_rows + 10;

    /* The number of streams, as assigned to FLiBeFuel, minus                 */
    /* discreet streams is 6 including component sum streams                  */

    num_flibefuel_rows = num_flibefuel_rows + 6;

    /* The target index of the Fluorine stream in FLiBeFuel is equal to the   */
    /* number of isotopes x 2 ( the index is assigned when the stream is read */
    /* at its source, in the Fluorine0 material ) + the number of streams in  */
    /* FLiBeFuel ( 6 ) We do not subtract 1 for zero indexing as the way      */
    /* ADERCountStreams assigns indicies                                      */

    test_value_stream_index = num_isos * 2 + 6;

    /* The target index of the Uranium2 stream in the ActF2 stream is equal to*/
    /* the number of isotopes + 5 as it is the 5th stream in FLiBeFuel.       */
    /* -1 for zero indexing                                                   */

    test_value_stream_sum_index = num_isos + 4;

    /* Run the test function and capture its output                           */

    ader_burn_matrix_size_info = ADERGetBurnMatrixSizeData(mat);

    ader_burn_matrix_num_rows = ader_burn_matrix_size_info[0];

    test_value_num_rows = ader_burn_matrix_num_rows[0];

    ader_burn_matrix_num_ents = ader_burn_matrix_size_info[1];

    ader_burn_matrix_starts = ader_burn_matrix_size_info[2];

    test_value_starts = ader_burn_matrix_starts[1];

    ader_burn_matrix_N0 = ader_burn_matrix_size_info[3];

    ader_burn_matrix_col_storage = ader_burn_matrix_size_info[4];

    /* If this does not cause a seg fault then the vector size boolean passes */
    /* We subtract one beacuse we added one to acount for 0 indexing          */

    ader_burn_matrix_N0[num_rows - 1] = 1.0;

    ader_burn_matrix_col_storage[num_rows - 1] = 1.0;

    boolean_allocation = 1;

    if((long)ader_burn_matrix_num_ents[0] == expected_non_zero_entries)
    {

    	boolean_non_zero = 1;

    }

    if(test_value_starts == num_flibefuel_rows)
    {

    	boolean_starts = 1;

    }


    if(test_value_num_rows == num_rows)
    {

    	boolean_num_rows = 1;

    }

    /* Go ahead and free the burn matrix memory                               */

    ADERDeallocateTarget(ader_burn_matrix_size_info, 5);

    /* Loop through FLiBeFuel's ader isotopes to see if Li-7 got the correct  */
    /* index                                                                  */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
        {

            test_value_iso_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

            if(test_value_iso_index == 8)
            {

                boolean_iso_index = 1;

            }

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    sprintf(print_data, "FLiBeFuel burn matrix has no streams. \n");

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Fluorine redox stream.\n");

        if(strncmp("Fluorine", GetText(ader_mat_stream + ADER_MAT_STREAM_ID), 8) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no ActF2 removal stream.\n");

            ader_mat_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

            if(test_value_stream_index == ader_mat_stream_index)
            {

            	boolean_stream_index = 1;

            	break;

            }

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Test the sum streams                                                   */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no ActF2 remv stream.\n");

        if(strncmp("ActF2", GetText(ader_mat_stream + ADER_MAT_STREAM_ID), 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ActF2 remv stream but no sum streams.\n");

            ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_stream_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel ActF2 remv stream has sum streams but no Uranium2.\n");

                if(strncmp("Uranium2", GetText(ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_ID), 8) == 0)
                {

                	ader_mat_stream_sum = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                	ader_mat_stream_sum_index = (long)RDB[ader_mat_stream_sum + ADER_MAT_STREAM_BURN_INDEX];

                	if(test_value_stream_sum_index == ader_mat_stream_sum_index)
                	{

                		boolean_stream_sum_index = 1;

                	}

                    break;

                }

                ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

            }

            break;
        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(boolean_allocation == 1 &&
       boolean_iso_index == 1 &&
       boolean_num_rows == 1 &&
	   boolean_non_zero == 1 &&
       boolean_starts == 1 &&
	   boolean_stream_index == 1 &&
	   boolean_stream_sum_index == 1)
    {

        boolean = 1;

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        memset(print_data, 0, strlen(print_data));

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        /* We do not report out the allocation boolean because the program    */
        /* seg fault if that boolean would not pass                           */

        if(boolean_iso_index == 0)
        {

            sprintf(print_data, "Test: Iso index: FAIL:\n \
Li-7 isotope in FLiBeFuel has index %ld and needs index 8.\n",
                    test_value_iso_index);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "Test: Iso index: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_non_zero == 0)
        {

            sprintf(print_data, "Test: Number non-zero entries: FAIL:\n \
There should be %ld non-zero entries and there are %ld non-zero entries.\n",
                    expected_non_zero_entries,
					(long)ader_burn_matrix_num_ents[0]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Number non-zero entries: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_num_rows == 0)
        {

            sprintf(print_data, "Test: Burn matrix num rows: FAIL:\n \
Burnmatrix has rows %ld but should have rows %ld.\n", test_value_num_rows,
                    num_rows);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "Test: Burn matrix num rows: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_starts == 0)
        {

            sprintf(print_data, "Test: Burn matrix starts: FAIL:\n \
Fluorine0 start is reported as %ld but should be %ld.\n \
Following starts are [ %ld, %ld ].\n", test_value_starts,
                    num_flibefuel_rows, (long)ader_burn_matrix_starts[2],
					(long)ader_burn_matrix_starts[3]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Burn matrix starts: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream_index == 0)
        {

            sprintf(print_data, "Test: Stream index: FAIL:\n \
Redox stream Fluorine in FLiBeFuel has index %ld and needs index %ld.\n",
                    ader_mat_stream_index, test_value_stream_index);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Stream index: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream_sum_index == 0)
        {

            sprintf(print_data, "Test: Sum stream index: FAIL:\n \
Removal stream Uranium2 ( sum of ActF2 ) in FLiBeFuel has index %ld \n\
and needs index %ld.\n",
                    ader_mat_stream_sum_index, test_value_stream_sum_index);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Sum stream index: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadergetburnmatrixvalue.c                   */
/*                                                                           */
/* Created:       2016/17/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that proper value is returned                          */
/*                                                                           */
/* Comments: This function is called from ADERBurnMaterials                  */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERGetBurnMatrixValue:"

void TESTADERGetBurnMatrixValue()
{

    char *const test_name = "ADERGetBurnMatrixValue";
    char status[5];
    char print_data[256];
    double percent_diff, test_value = 0.0;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, j, k;
    long *row, *col;
    complex *val;
    struct ccsMatrix *burn_matrix;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERGetBurnMatrixValue.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Generate the matrix                                                    */

    burn_matrix = ccsMatrixNew(10, 10, 99);

    /* Parse out the pieces we need to search through                         */

    val = burn_matrix->values;
    row = burn_matrix->rowind;
    col = burn_matrix->colptr;

    /* Populate the matrix                                                    */

    col[0] = 0;

    k = 0;

    for(i = 0; i < 10; i++)
    {

    	for(j = 0; j < 10; j++)
    	{

    		if(k != 0)
    		{

        	    val[k - 1].re = (double)k;
        	    val[k - 1].im = 0.0;

        	    row[k - 1] = j;

    		}

    		k++;

    	}

	    col[i + 1] = k;

    }

    /* Get the test value                                                     */

    test_value = ADERGetBurnMatrixValue(4, burn_matrix, 8);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    sprintf(print_data, "Value returned is %f but should be 48.0.\n", test_value);

    percent_diff = (test_value - 48.0) / 48.0;

    if(fabs(percent_diff) < 0.001)
    {

    	boolean = 1;

    }


    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        memset(print_data, 0, strlen(print_data));

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadergeteigenbias.c                         */
/*                                                                           */
/* Created:       2016/04/17 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the value of the eigen bias                            */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERGetEigenBias:"

void TESTADERGetEigenBias(long dep, long mat, double t1, double t2)
{

    char *const test_name = "ADERGetEigenBias";
    char status[5];
    char print_data[256];
    char *mat_name;
    double ader_k_inf = 0;
    double expected_bias = 0, neutron_production = 0, neutron_loss = 0;
    double non_leakage = 0, old_serp_imp_k_eff = 0, percent_diff = 0, test_value = 0;
    int append = 0;
    int boolean = 0;
    long ader_data = 0, ader_mat_iso = 0, ader_test_block = 0;
    long mat_iso = 0, mat_ader_data = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERGetEigenBias.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the infinite multiplication factor for this material              */

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	neutron_loss += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
 		                                 RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
			                             RDB[ader_mat_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
									     t1, t2, dep) *
					    RDB[mat_iso + COMPOSITION_ADENS];

    	neutron_production += ADERAverageValue(RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
 		                                       RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
			                                   RDB[ader_mat_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
											   t1, t2, dep) *
							  RDB[mat_iso + COMPOSITION_ADENS];

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Now set the new, and fake, serpent implicit non-infinite multiplication*/
    /* factor                                                                 */

    ader_k_inf = neutron_production / neutron_loss;

    non_leakage = (Mean((long)RDB[RES_IMP_KEFF], 0) / Mean((long)RDB[RES_IMP_KINF], 0));

    expected_bias = 0.13;

    old_serp_imp_k_eff = RES1[(long)RDB[(long)RDB[RES_IMP_KEFF] + SCORE_PTR_DATA] + STAT_X];

    RES1[(long)RDB[(long)RDB[RES_IMP_KEFF] + SCORE_PTR_DATA] + STAT_X] = expected_bias *
    		                                                             non_leakage *
																		 ader_k_inf *
																		 RES1[(long)RDB[(long)RDB[RES_IMP_KEFF] + SCORE_PTR_DATA] + STAT_N];

    test_value = ADERGetEigenBias(dep, mat, t1, t2);

    sprintf(print_data, "Material FLiBeFuel has a bias of %0.8E.\n \
Needs bias of %0.8E.\n", test_value,
            expected_bias);

    percent_diff = fabs((test_value - expected_bias) / expected_bias);

    /* Reset serp imp k                                                       */

    RES1[(long)RDB[(long)RDB[RES_IMP_KEFF] + SCORE_PTR_DATA] + STAT_X] = old_serp_imp_k_eff;

    if(percent_diff < 0.0001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadergetisoburnmatrixindex.c                */
/*                                                                           */
/* Created:       2016/22/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that ADERGetIsoBurnMatrixIndex returns the correct val */
/*                                                                           */
/* Comments:This function is called from ADERBurnMatreials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERGetIsoBurnMatrixIndex:"

void TESTADERGetIsoBurnMatrixIndex(long mat)
{

    char *const test_name = "ADERGetIsoBurnMatrixIndex";
    char status[5];
    char print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data;
    long ader_mat_iso;
    long ader_test_block, mat_ader_data, mat_iso, nuc, test_value;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERGetIsoBurnMatrixIndex.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel has no ader isotopes. \n");

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no Li-7. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

    		test_value = ADERGetIsoBurnMatrixIndex(FUNCTION_NAME, mat, nuc);

            sprintf(print_data, "Material FLiBeFuel has ader isotopes Li-7 \n\
but bad index of %ld and needs index of 8. \n", test_value);

    		if(test_value == 8)
    		{

    			boolean = 1;

    	        memset(print_data, 0, strlen(print_data));

    		}

    		break;

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadergettargetremovalamount.c               */
/*                                                                           */
/* Created:       2017/03/04 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the returned removal amount is correct */
/*                                                                           */
/* Comments:This function is called from ADEROpperateMaterial                */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERGetTargetRemovalAmount:"

void TESTADERGetTargetRemovalAmount()
{

    char *const test_name = "ADERMatGetRemovalAmount";
    char status[5];
    char print_data[256];
    char *mat_name;
    double ele_rem_amount, iso_rem_amount, percent_diff_ele, percent_diff_iso;
    int append = 0;
    int boolean = 0, boolean_ele = 0, boolean_iso = 0;
    long ader_data, ader_test_block, mat;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMatGetRemovalAmount.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ele_rem_amount = ADERGetTargetRemovalAmount(mat, 3, 0);

    percent_diff_ele = (ele_rem_amount - 0.00121949) / 0.00121949;

    iso_rem_amount = ADERGetTargetRemovalAmount(mat, 0, 30070);

    percent_diff_iso = (iso_rem_amount - 0.00121827) / 0.00121827;

    if(percent_diff_ele < 0.001)
    {

    	boolean_ele = 1;

    }

    if(percent_diff_iso < 0.001)
    {

    	boolean_iso = 1;

    }

    if(boolean_ele == 1 &&
       boolean_iso == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_ele == 0)
        {

            sprintf(print_data, "\nTest: Elemental removal amount: FAIL:\n \
Removal amount for Li is given as %f but should be 0.00121949.\n",
                    ele_rem_amount);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Elemental removal amount: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_iso == 0)
        {

            sprintf(print_data, "\nTest: Isotope removal amount: FAIL:\n \
Removal amount for Li-7 is given as %f but should be 0.00121827.\n",
                    iso_rem_amount);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Isotope removal amount: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermakeburnmatrix.c                       */
/*                                                                           */
/* Created:       2016/17/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests 49 things. boolean variables for each test are given   */
/*                 following the text                                        */
/*              2. That proportional removal table streams in a single       */
/*                 material cluster in a zero flux environment give isotopes */
/*                 the correct lambda value - bl_nf_nc_ps_rt_ti_ro           */
/*              3. That an isotope in a zero flux environment has the correct*/
/*                 decay constant for itself - bl_nf_nc_iso_dy_ti_ro         */
/*              4. That proportional group type source streams in a material */
/*                 cluster in a zero flux environment give isotopes the      */
/*                 correct lambda value - bl_nf_cl_ps_gt_ss_ti_ro            */
/*              5. That proportional group type source streams in a material */
/*                 cluster in a zero flux environment give isotopes the      */
/*                 correct lambda value - bl_nf_cl_ps_gt_sd_ti_ro            */
/*              6. That continuous group type streams do not give themselves */
/*                 any self referential data in a non-cluster material -     */
/*                 bl_fx_nc_cs_gt_ts                                         */
/*              8. That proportional removal table streams do not give       */
/*                 themselves any self referential data in a non-cluster     */
/*                 material - bl_fx_nc_ps_rt_ts                              */
/*              9. That continuous removal table streams do not give         */
/*                 themselves any self referential data in a non-cluster     */
/*                 material - bl_fx_nc_cs_rt_ts                              */
/*             10. That isotopes in a continuous group type stream do not    */
/*                 populate the stream row in a non-cluster material -       */
/*                 bl_fx_nc_iso_ts_cs_gt_ro                                  */
/*             11. That isotopes in a continuous removal table stream do not */
/*                 populate the stream row in a non-cluster material -       */
/*                 bl_fx_nc_iso_ts_cs_rt_ro                                  */
/*             14. That isotopes in a proportional removal table stream do   */
/*                 not receive contributions from the stream column in a     */
/*                 non-cluster material - bl_fx_nc_iso_ts_ps_rt_co           */
/*             15. That isotopes in a proportional removal table stream do   */
/*                 not populate the stream row in a non-cluster material -   */
/*                 bl_fx_nc_iso_ts_ps_rt_ro                                  */
/*             16. That continuous group type streams in a non-cluster       */
/*                 material give their isotopes the proper rate information  */
/*                  - bl_fx_nc_cs_gt_ti_ro                                   */
/*             17. That continuous removal table streams in a non-cluster    */
/*                 material give their isotopes the proper rate information  */
/*                  - bl_fx_nc_cs_rt_ti_ro                                   */
/*             18. That continuous group type summation streams ( stream 1 ) */
/*                  provide the proper rate information to isotopes in a      */
/*                 non-cluster material - bl_fx_nc_cs_gt_sm_s1_ti_ro         */
/*             19. That continuous group type summation streams ( stream 2 ) */
/*                 provide the proper rate information to isotopes in a      */
/*                 non-cluster material - bl_fx_nc_cs_gt_sm_s2_ti_ro         */
/*             20. That isotopes in a non-clustered material do not          */
/*                 populate continuous group type first summation stream     */
/*                 rows - bl_fx_nc_iso_ts_cs_gt_sm_s1_ro                     */
/*             21. That isotopes in a non-clustered material do not          */
/*                 populate continuous group type second summation stream    */
/*                 rows - bl_fx_nc_iso_ts_cs_gt_sm_s2_ro                     */
/*             22. That continuous removal table streams give isotopes in a  */
/*                 cluster material the correct rate data -                  */
/*                 bl_fx_cl_cs_rt_ss_ti_ro                                   */
/*             23. That continuous removal table streams give isotopes in a  */
/*                 cluster material the correct rate data -                  */
/*                 bl_fx_cl_cs_rt_sd_ti_ro                                   */
/*             24. That continuous removal table streams do not give         */
/*                 themselves any self referential data in a clustered       */
/*                 material - bl_fx_cl_cs_rt_ts                              */
/*             25. That isotopes in a continuous removal table source side   */
/*                 stream do not populate the stream row in a clustered      */
/*                 material - bl_fx_cl_iso_ts_cs_rt_ss_ro                    */
/*             26. That isotopes in a continuous removal table destination   */
/*                 side stream do not populate the stream row in a clustered */
/*                 material - bl_fx_cl_iso_ts_cs_rt_sd_ro                    */
/*             27. That isotopes in a proportional group type destination    */
/*                 stream do not receive contributions from the stream column*/
/*                 in a clustered material - bl_fx_cl_iso_ts_ps_gt_sd_co     */
/*             28. That isotopes in a proportional group type source         */
/*                 stream do not receive contributions from the stream column*/
/*                 in a clustered material - bl_fx_cl_iso_ts_ps_gt_ss_co     */
/*             29. That isotopes in a proportional group type destination    */
/*                 side stream do not contribute rate information to the     */
/*                 proportional stream accumulation row in a clustered       */
/*                 material - bl_fx_cl_iso_ts_ps_gt_sd_ro                    */
/*             30. That isotopes in a proportional group type source         */
/*                 side stream do provide contribute rate information to the */
/*                 proportional stream accumulation row in a clustered       */
/*                 material - bl_fx_cl_iso_ts_ps_gt_ss_ro                    */
/*             31. That proportional group type streams do not give          */
/*                 themselves any self referential data in a clustered       */
/*                 material - bl_fx_cl_ps_gt_ts                              */
/*             32. That continuous group type first summation streams in     */
/*                 destination side materials in a material cluster give     */
/*                 isotopes the appropriate rate information -               */
/*                 bl_fx_cl_cs_gt_sm_s1_sd_ti_ro                             */
/*             33. That continuous group type first summation streams in     */
/*                 source side materials in a material cluster give          */
/*                 isotopes the appropriate rate information -               */
/*                 bl_fx_cl_cs_gt_sm_s1_ss_ti_ro                             */
/*             34. That continuous group type second summation streams in    */
/*                 destination side materials in a material cluster give     */
/*                 isotopes the appropriate rate information -               */
/*                 bl_fx_cl_cs_gt_sm_s2_sd_ti_ro                             */
/*             35. That continuous group type second summation streams in    */
/*                 source side materials in a material cluster give          */
/*                 isotopes the appropriate rate information -               */
/*                 bl_fx_cl_cs_gt_sm_s2_ss_ti_ro                             */
/*             36. That isotopes in destination side material in a material  */
/*                 cluster do not give continuous group type first summation */
/*                 streams any rate information -                            */
/*                 bl_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro                         */
/*             37. That isotopes in source side material in a material       */
/*                 cluster do not give continuous group type first summation */
/*                 streams any rate information -                            */
/*                 bl_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro                         */
/*             38. That isotopes in destination side material in a material  */
/*                 cluster do not give continuous group type second summation*/
/*                 streams any rate information -                            */
/*                 bl_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro                         */
/*             39. That isotopes in source side material in a material       */
/*                 cluster do not give continuous group type second summation*/
/*                 streams any rate information -                            */
/*                 bl_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro                         */
/*             40. That continuous group type destination side streams in a  */
/*                 clustered material give their isotopes the proper rate    */
/*                 information - bl_fx_cl_cs_gt_sd_ti_ro                     */
/*             41. That continuous group type source side streams in a       */
/*                 clustered material give their isotopes the proper rate    */
/*                 information - bl_fx_cl_cs_gt_ss_ti_ro                     */
/*             42. That continuous group type streams do not give themselves */
/*                 any self referential data in a clustered material -       */
/*                 bl_fx_cl_cs_gt_ts                                         */
/*             43. That isotopes populate production data for their          */
/*                 decay products - bl_fx_cl_iso_dp_ti_ro                    */
/*             44. That isotopes populate production data for their          */
/*                 fission products - bl_fx_cl_iso_fp_ti_ro                  */
/*             45. That isotopes populate production data for their          */
/*                 transmutation products - bl_fx_cl_iso_nt_ti_ro            */
/*             46. That isotopes in a continuous group type destination side */
/*                 stream do not populate the stream row in a clustered      */
/*                 material - bl_fx_cl_iso_ts_cs_gt_sd_ro                    */
/*             47. That isotopes in a continuous group type source side      */
/*                 stream do not populate the stream row in a clustered      */
/*                 material - bl_fx_cl_iso_ts_cs_gt_ss_ro                    */
/*             48. That isotopes in a proportional removal table destination */
/*                 side stream do not populate the stream column in a        */
/*                 clustered material - bl_fx_cl_iso_ts_ps_rt_sd_co          */
/*             49. That isotopes in a proportional removal table source      */
/*                 side stream do not populate the stream column in a        */
/*                 clustered material - bl_fx_cl_iso_ts_ps_rt_ss_co          */
/*             50. That isotopes in a proportional removal table destination */
/*                 side stream do not populate the stream row in a           */
/*                 clustered material - bl_fx_cl_iso_ts_ps_rt_sd_ro          */
/*             51. That isotopes in a proportional removal table source      */
/*                 side stream populate the stream row with the correct info */
/*                 in a clustered material - bl_fx_cl_iso_ts_ps_rt_ss_ro     */
/*             52. That proportional removal table destination side streams  */
/*                 in a clustered material give isotopes                     */
/*                 the correct lambda value - bl_fx_cl_ps_rt_sd_ti_ro        */
/*             53. That proportional removal table source side streams       */
/*                 in a clustered material give isotopes                     */
/*                 the correct lambda value - bl_fx_cl_ps_rt_ss_ti_ro        */
/*             54. That proportional removal table streams do not give       */
/*                 themselves any self referential data in a clustered       */
/*                 material - bl_fx_cl_ps_rt_ts                              */
/*                                                                           */
/* Comments: This function is called from ADERBurnMaterials                  */
/*           Below is a listing of acronyms used in variable naming          */
/*           bl - boolean                                                    */
/*           cl - part of a cluster                                          */
/*           co - column                                                     */
/*           cs - continuous type stream                                     */
/*           dp - decay product                                              */
/*           ds - discreet type stream                                       */
/*           dy - decay                                                      */
/*           fx - flux in the material                                       */
/*           fp - fission product                                            */
/*           gt - group type stream                                          */
/*           nc - NOT part of a multi-material cluster                       */
/*           nf - no flux in the material                                    */
/*           nt - transmutation reaction                                     */
/*           pd - percent difference                                         */
/*           ps - proportional type stream                                   */
/*           pv - pass value ( value for test to succeed )                   */
/*           ro - row                                                        */
/*           rt - removal table type stream                                  */
/*           s1 - first summation stream in a sum stream                     */
/*           s2 - second summation stream in a sum stream                    */
/*           sd - destination end of a shadow stream                         */
/*           sf - spontaneous fission                                        */
/*           sm - sub componenet of a summation based stream                 */
/*           ss - source end of a shadow stream                              */
/*           ti - to iso                                                     */
/*           ts - to stream                                                  */
/*           tv - test value                                                 */
/*                                                                           */
/*           Most tests will have four key variable associated with them.    */
/*           All tests will have a bl variable that might look something like*/
/*           bl_fx_nc_cs_rt_ti_ro which indicates that it is a boolean       */
/*           variable for a test with material flux for a material that is   */
/*           not part of a multi-material cluster for a continuous removal   */
/*           table based stream sending information to an isotope row. The   */
/*           other three variable will simply change out the bl portion for  */
/*           a tv, pv, and pd. Thus, with the boolean variable names above   */
/*           any of the named tests and their location in this file can be   */
/*           easily searched for.                                            */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMakeBurnMatrix:"

void TESTADERMakeBurnMatrix()
{

    char *const test_name = "ADERMakeBurnMatrix";
    char status[5];
    char print_data[1000];
    double **ader_burn_matrix_size_data;
    double *ader_burn_matrix_col_storage;
    double *ader_burn_matrix_num_ents, *ader_burn_matrix_num_rows;
    double *ader_burn_matrix_N0, *ader_burn_matrix_starts;
    double *ader_optimization_solution_array;
    double t1, t2, total_time;
    double fluorine1_flux, lithium7_flux, testtank_flux;
    long ader_data, ader_mat_data;
	long ader_mat_iso, ader_mat_matrix_data;
	long ader_mat_stream, ader_mat_stream_sum_stream;
	long ader_mat_stream_sum_stream_ent, ader_test_block, li6_lithium7_mat_iso;
	long mat, mat_iso, nuc;
    struct ccsMatrix *burn_matrix;
    double pd_fx_cl_cs_gt_sd_ti_ro = 0.0;
    double pd_fx_cl_cs_gt_sm_s1_sd_ti_ro = 0.0;
    double pd_fx_cl_cs_gt_sm_s1_ss_ti_ro = 0.0;
    double pd_fx_cl_cs_gt_sm_s2_sd_ti_ro = 0.0;
    double pd_fx_cl_cs_gt_sm_s2_ss_ti_ro = 0.0;
    double pd_fx_cl_cs_gt_ss_ti_ro = 0.0;
    double pd_fx_cl_cs_rt_sd_ti_ro = 0.0;
    double pd_fx_cl_cs_rt_ss_ti_ro = 0.0;
    double pd_fx_cl_iso_ts_ps_gt_ss_ro = 0.0;
    double pd_fx_cl_iso_ts_ps_rt_ss_ro = 0.0;
    double pd_fx_cl_ps_rt_sd_ti_ro = 0.0;
    double pd_fx_cl_ps_rt_ss_ti_ro = 0.0;
    double pd_fx_nc_cs_gt_sm_s1_ti_ro = 0.0;
    double pd_fx_nc_cs_gt_sm_s2_ti_ro = 0.0;
    double pd_fx_nc_cs_gt_ti_ro = 0.0, pd_fx_nc_cs_rt_ti_ro = 0.0;
    double pd_fx_nc_iso_ts_ps_rt_ro = 0.0;
    double pd_nf_cl_ps_gt_sd_ti_ro = 0.0, pd_nf_cl_ps_gt_ss_ti_ro = 0.0;
    double pd_nf_nc_iso_dy_ti_ro = 0.0;
    double pd_nf_nc_ps_rt_ti_ro = 0.0;
    double pv_fx_cl_cs_gt_sd_ti_ro = 1.0;
    double pv_fx_cl_cs_gt_sm_s1_sd_ti_ro = 2.0;
    double pv_fx_cl_cs_gt_sm_s1_ss_ti_ro = -1.0;
    double pv_fx_cl_cs_gt_sm_s2_sd_ti_ro = 2.0;
    double pv_fx_cl_cs_gt_sm_s2_ss_ti_ro = -1.0;
    double pv_fx_cl_cs_gt_ss_ti_ro = -1.0;
    double pv_fx_cl_cs_gt_ts = 0.0;
    double pv_fx_cl_cs_rt_sd_ti_ro = (6.4058073E-03 * 2.0);
    double pv_fx_cl_cs_rt_ss_ti_ro = -6.4058073E-03;
    double pv_fx_cl_cs_rt_ts = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_gt_ss_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_rt_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_cs_rt_ss_ro = 0.0;
    double pv_fx_cl_iso_ts_ps_gt_sd_co = 0.0;
    double pv_fx_cl_iso_ts_ps_gt_ss_co = 0.0;
    double pv_fx_cl_iso_ts_ps_gt_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_ps_gt_ss_ro = 0.0000008023;
    double pv_fx_cl_iso_ts_ps_rt_sd_co = 0.0;
    double pv_fx_cl_iso_ts_ps_rt_ss_co = 0.0;
    double pv_fx_cl_iso_ts_ps_rt_sd_ro = 0.0;
    double pv_fx_cl_iso_ts_ps_rt_ss_ro = 1.0E-08;
    double pv_fx_cl_ps_gt_ts = 0.0;
    double pv_fx_cl_ps_rt_sd_ti_ro = 0.000009 * 2.0;
    double pv_fx_cl_ps_rt_ss_ti_ro = -0.000009;
    double pv_fx_cl_ps_rt_ts = 0.0;
    double pv_fx_nc_cs_gt_sm_s1_ti_ro = 1.0;
    double pv_fx_nc_cs_gt_sm_s2_ti_ro = 1.0;
    double pv_fx_nc_cs_gt_ti_ro = 1.0;
    double pv_fx_nc_cs_rt_ti_ro = -0.05;
    double pv_fx_nc_cs_gt_ts = 0.0, pv_fx_nc_cs_rt_ts = 0.0;
    double pv_fx_nc_iso_ts_cs_gt_ro = 0.0;
    double pv_fx_nc_iso_ts_cs_gt_sm_s1_ro = 0.0;
    double pv_fx_nc_iso_ts_cs_gt_sm_s2_ro = 0.0;
    double pv_fx_nc_iso_ts_cs_rt_ro = 0.0;
    double pv_fx_nc_iso_ts_ps_rt_co = 0.0;
    double pv_fx_nc_iso_ts_ps_rt_ro = 0.05;
    double pv_fx_nc_ps_rt_ts = 0.0;
    double pv_nf_cl_ps_gt_sd_ti_ro =  0.0000008023 * 2.0;
    double pv_nf_cl_ps_gt_ss_ti_ro = -0.0000008023;
    double pv_nf_nc_iso_dy_ti_ro = -1.380625E-13;
    double pv_nf_nc_ps_rt_ti_ro = -0.05;
    double tv_fx_cl_cs_gt_sd_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_sm_s1_sd_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_sm_s1_ss_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_sm_s2_sd_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_sm_s2_ss_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_ss_ti_ro = 0.0;
    double tv_fx_cl_cs_gt_ts = 1.0;
    double tv_fx_cl_cs_rt_sd_ti_ro = 0.0;
    double tv_fx_cl_cs_rt_ss_ti_ro = 0.0;
    double tv_fx_cl_cs_rt_ts = 1.0;
    double tv_fx_cl_iso_ts_cs_gt_sd_ro = 1.0;
    double tv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro = 0.0;
    double tv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro = 0.0;
    double tv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro = 0.0;
    double tv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro = 0.0;
    double tv_fx_cl_iso_ts_cs_gt_ss_ro = 1.0;
    double tv_fx_cl_iso_ts_cs_rt_sd_ro = 1.0;
    double tv_fx_cl_iso_ts_cs_rt_ss_ro = 1.0;
    double tv_fx_cl_iso_ts_ps_gt_sd_co = 1.0;
    double tv_fx_cl_iso_ts_ps_gt_ss_co = 1.0;
    double tv_fx_cl_iso_ts_ps_gt_sd_ro = 1.0;
    double tv_fx_cl_iso_ts_ps_gt_ss_ro = 0.0;
    double tv_fx_cl_iso_ts_ps_rt_sd_co = 1.0;
    double tv_fx_cl_iso_ts_ps_rt_ss_co = 1.0;
    double tv_fx_cl_iso_ts_ps_rt_sd_ro = 1.0;
    double tv_fx_cl_iso_ts_ps_rt_ss_ro = 0.0;
    double tv_fx_cl_ps_gt_ts = 1.0;
    double tv_fx_cl_ps_rt_sd_ti_ro = 0.0;
    double tv_fx_cl_ps_rt_ss_ti_ro = 0.0;
    double tv_fx_cl_iso_dp_ti_ro = 0.0;
    double tv_fx_cl_iso_fp_ti_ro = 0.0;
    double tv_fx_cl_iso_nt_ti_ro = 0.0;
    double tv_fx_cl_ps_rt_ts = 1.0;
    double tv_fx_nc_cs_gt_sm_s1_ti_ro = 0.0;
    double tv_fx_nc_cs_gt_sm_s2_ti_ro = 0.0;
    double tv_fx_nc_cs_gt_ti_ro = 0.0, tv_fx_nc_cs_rt_ti_ro = 0.0;
    double tv_fx_nc_cs_gt_ts = 1.0, tv_fx_nc_cs_rt_ts = 1.0;
    double tv_fx_nc_iso_ts_cs_gt_ro = 1.0;
    double tv_fx_nc_iso_ts_cs_gt_sm_s1_ro = 0.0;
    double tv_fx_nc_iso_ts_cs_gt_sm_s2_ro = 0.0;
    double tv_fx_nc_iso_ts_cs_rt_ro = 1.0;
    double tv_fx_nc_iso_ts_ps_rt_co = 1.0, tv_fx_nc_iso_ts_ps_rt_ro = 1.0;
    double tv_fx_nc_ps_rt_ts = 1.0, tv_nf_cl_ps_gt_sd_ti_ro = 0.0;
    double tv_nf_cl_ps_gt_ss_ti_ro = 0.0;
    double tv_nf_nc_iso_dy_ti_ro = 0.0;
    double tv_nf_nc_ps_rt_ti_ro = 0.0;
    double li6_lithium7_hold = 0.0;
    int append = 0;
    int bl_fx_cl_cs_gt_sd_ti_ro = 0;
    int bl_fx_cl_cs_gt_sm_s1_sd_ti_ro = 0;
    int bl_fx_cl_cs_gt_sm_s1_ss_ti_ro = 0;
    int bl_fx_cl_cs_gt_sm_s2_sd_ti_ro = 0;
    int bl_fx_cl_cs_gt_sm_s2_ss_ti_ro = 0;
    int bl_fx_cl_cs_gt_ss_ti_ro = 0;
    int bl_fx_cl_cs_rt_sd_ti_ro = 0;
    int bl_fx_cl_cs_rt_ss_ti_ro = 0;
    int bl_fx_cl_cs_gt_ts = 0;
    int bl_fx_cl_cs_rt_ts = 0;
    int bl_fx_cl_iso_ts_cs_gt_sd_ro = 0;
    int bl_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro = 0;
    int bl_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro = 0;
    int bl_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro = 0;
    int bl_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro = 0;
    int bl_fx_cl_iso_ts_cs_gt_ss_ro = 0;
    int bl_fx_cl_iso_ts_cs_rt_sd_ro = 0;
    int bl_fx_cl_iso_ts_cs_rt_ss_ro = 0;
    int bl_fx_cl_iso_ts_ps_gt_sd_co = 0;
    int bl_fx_cl_iso_ts_ps_gt_ss_co = 0;
    int bl_fx_cl_iso_ts_ps_gt_sd_ro = 0;
    int bl_fx_cl_iso_ts_ps_gt_ss_ro = 0;
    int bl_fx_cl_iso_ts_ps_rt_sd_co = 0;
    int bl_fx_cl_iso_ts_ps_rt_ss_co = 0;
    int bl_fx_cl_iso_ts_ps_rt_sd_ro = 0;
    int bl_fx_cl_iso_ts_ps_rt_ss_ro = 0;
    int bl_fx_cl_iso_dp_ti_ro = 0;
    int bl_fx_cl_iso_fp_ti_ro = 0;
    int bl_fx_cl_iso_nt_ti_ro = 0;
    int bl_fx_cl_ps_gt_ts = 0;
    int bl_fx_cl_ps_rt_sd_ti_ro = 0;
    int bl_fx_cl_ps_rt_ss_ti_ro = 0;
    int bl_fx_cl_ps_rt_ts = 0.0;
    int bl_fx_nc_cs_gt_sm_s1_ti_ro = 0;
    int bl_fx_nc_cs_gt_sm_s2_ti_ro = 0;
    int bl_fx_nc_cs_gt_ti_ro = 0, bl_fx_nc_cs_rt_ti_ro = 0;
    int bl_fx_nc_cs_gt_ts = 0,  bl_fx_nc_cs_rt_ts = 0;
    int bl_fx_nc_iso_ts_cs_gt_ro = 0;
    int bl_fx_nc_iso_ts_cs_gt_sm_s1_ro = 0.0;
    int bl_fx_nc_iso_ts_cs_gt_sm_s2_ro = 0.0;
    int bl_fx_nc_iso_ts_cs_rt_ro = 0;
    int bl_fx_nc_iso_ts_ps_rt_co = 0;
    int bl_fx_nc_iso_ts_ps_rt_ro = 0;
    int bl_fx_nc_ps_rt_ts = 0;
    int bl_nf_cl_ps_gt_sd_ti_ro = 0, bl_nf_cl_ps_gt_ss_ti_ro = 0;
    int bl_nf_nc_iso_dy_ti_ro = 0;
    int bl_nf_nc_ps_rt_ti_ro = 0;
    int boolean = 0;
    long be9_flibefuel_index = -1, beryllium_flibefuel_redox_stream_index = -1;
    long f19_fluorine0_index = -1, f19_uranium233_index = -1;
    long fluorine_fluorine0_redox_stream_index = -1;
    long fluorine_uranium233_redox_stream_index = -1;
    long li6li7_fluorine1_remv_stream_found = -1;
    long li6li7_lithium7_remv_stream_found = -1;
    long li6_flibefuel_index = -1;
    long li6_fluorine1_remv_stream_index = -1;
    long li6_fluorine1_remv_sum_stream_index = -1;
    long li6_fluorine1_index = -1;
    long li6_lithium7_index = -1;
    long li6_lithium7_remv_stream_index = -1;
    long li6_lithium7_remv_sum_stream_index = -1;
    long li7_argon40_index = -1;
    long li7_flibefuel_index = -1;
    long li7_fluorine1_index = -1;
    long li7_fluorine1_remv_sum_stream_index = -1;
    long li7_lithium7_index = -1;
    long li7_lithium7_remv_sum_stream_index = -1;
    long h1_testtank_feed_stream_index = -1;
    long h1_testtank_index = -1, h3_flibefuel_index = -1;
    long he4_argon40_index = -1;
    long he4_flibefuel_index = -1;
    long np239_flibefuel_index = -1;
    long reproc_argon40_remv_stream_index = -1;
    long reproc_flibefuel_remv_stream_index = -1;
    long rli7_fluorine1_remv_stream_index = -1, rli7_lithium7_remv_stream_index = -1;
    long rv51_testtank_remv_stream_index = -1, rw186_testtank_remv_stream_index = -1;
    long step = 0;
    long ta181_testtank_index = -1;
    long ta181_testtank_feed_sum_stream_index = -1;
    long tests_passing = 0, type = 1, u233_flibefuel_index = -1;
    long u239_flibefuel_index = -1;
    long u233_testtank_index = -1, v51_testtank_index = -1;
    long v51ta181_testtank_feed_stream_found = -1;
    long v51_testtank_feed_sum_stream_index = -1, w186_testtank_index = -1;
    long xe135_flibefuel_index = -1;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMakeBurnMatrix.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* FIRST: We do the zero flux tests                                       */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("TestTank", GetText(mat + MATERIAL_PTR_NAME), 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* These following steps are to clear stream CUR_AMT data so as to not    */
    /* Interfere with testing the "+1" seen in the allocation is for the CLP  */
    /* return value and while that does not matter here we stick with         */
    /* convention for clarity                                                 */

    ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

    ader_optimization_solution_array = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] + 1, sizeof(double));

    /* ADERParseClpSolution is called as it is the easiest way to reset all   */
    /* streams                                                                */

    ADERParseClpSolution(0, 0, mat, 0, ader_optimization_solution_array);

    /* Go ahead and free the optimization array                               */

    free(ader_optimization_solution_array);

    /* Gen the data to gen the matrix                                         */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

    /* Set the time interval for data processing                              */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

	/* Map appropriate data                                                   */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 0, total_time);

	/* Get sub step start and end times                                       */

    t1 = 0.0;
    t2 = total_time * 0.50;

    /* Set the material flux to 0, this is for testing                        */

    testtank_flux = RDB[mat + MATERIAL_BURN_FLUX_SSA];

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = 0.0;

    /* Now, get the indices of the matrix that need to be checked             */

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 10010)
    	{

    		h1_testtank_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 230510)
    	{

    		v51_testtank_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 731810)
    	{

    		ta181_testtank_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 741860)
    	{

    		w186_testtank_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
    	{

    		u233_testtank_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(h1_testtank_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for H-1 was not found.\n");

    }

    if(v51_testtank_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for Va-51 was not found.\n");

    }

    if(ta181_testtank_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for Ta-181 was not found.\n");

    }

    if(w186_testtank_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for W-186 was not found.\n");

    }

    if(u233_testtank_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for U-233 was not found.\n");

    }

    /* Collect the stream indices that are needed                             */

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("H1", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		h1_testtank_feed_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    	}

    	if(strcmp("V51Ta181", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		v51ta181_testtank_feed_stream_found = 1;

    		ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    		while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    		{

    			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

    			if(strcmp("Ta181", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				ta181_testtank_feed_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			if(strcmp("V51", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				v51_testtank_feed_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    		}

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(h1_testtank_feed_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for the H1 feed stream\n\
was not found.\n");

    }

    if(v51ta181_testtank_feed_stream_found < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for the V51Ta181 feed stream\n\
was not found.\n");

    }
    else
    {

    	if(ta181_testtank_feed_sum_stream_index < 0 &&
    	   v51_testtank_feed_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the indices for the Ta181 and V51\n\
summation streams were not found though the parent stream, V51Ta181, was found.\n");

    	}
    	else if(ta181_testtank_feed_sum_stream_index > 0 &&
    	        v51_testtank_feed_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material TestTank the index for the V51 summation\n\
stream in parent stream V51Ta181 was not found though the index for the\n\
Ta181 summation stream was found.\n");

    	}
    	else if(ta181_testtank_feed_sum_stream_index < 0 &&
    	        v51_testtank_feed_sum_stream_index > 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material TestTank the index for the Ta181 summation\n\
stream in parent stream V51Ta181 was not found though the index for the\n\
V51 summation stream was found.\n");

    	}

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("rV51", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		rv51_testtank_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}


    	if(strcmp("rW186", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		rw186_testtank_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(rv51_testtank_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for the rV51 remv stream\n\
was not found.\n");

    }

    if(rw186_testtank_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material TestTank the index for the rW186 remv stream\n\
was not found.\n");

    }

    /* Gen the burnup matrix                                                  */

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

    ADERMakeBurnMatrix(burn_matrix,
    		           ader_burn_matrix_col_storage, mat,
					   (long)ader_burn_matrix_num_ents[0],
					   (long)ader_burn_matrix_num_rows[0], step, type, t1, t2);

    /* Now get the values from the burn matrix and compare to the expected    */

    tv_nf_nc_ps_rt_ti_ro = ADERGetBurnMatrixValue(v51_testtank_index,
    		                                      burn_matrix,
												  v51_testtank_index);

    pd_nf_nc_ps_rt_ti_ro = (tv_nf_nc_ps_rt_ti_ro - pv_nf_nc_ps_rt_ti_ro) /
    		                                       pv_nf_nc_ps_rt_ti_ro;

    if(fabs(pd_nf_nc_ps_rt_ti_ro) < 0.001)
    {

    	bl_nf_nc_ps_rt_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_nf_nc_iso_dy_ti_ro = ADERGetBurnMatrixValue(u233_testtank_index,
    		                                       burn_matrix,
												   u233_testtank_index);

    pd_nf_nc_iso_dy_ti_ro = (tv_nf_nc_iso_dy_ti_ro - pv_nf_nc_iso_dy_ti_ro) /
    		                                        pv_nf_nc_iso_dy_ti_ro;

    if(fabs(pd_nf_nc_iso_dy_ti_ro) < 0.01)
    {

    	bl_nf_nc_iso_dy_ti_ro = 1;

    	tests_passing += 1;

    }

    /* Clear the memory associated with the zero flux TestTank burn matrix    */

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    /* Reset the TestTank flux                                                */

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = testtank_flux;

    /* Get the Lithium7 cluster and generate its zero flux burnup matrix      */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Lithium7", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* These following steps are to clear stream CUR_AMT data so as to not    */
    /* Interfere with testing the "+1" seen in the allocation is for the CLP  */
    /* return value and while that does not matter here we stick with         */
    /* convention for clarity                                                 */

    ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

    ader_optimization_solution_array = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] + 1, sizeof(double));

    /* ADERParseClpSolution is called as it is the easiest way to reset all   */
    /* streams                                                                */

    ADERParseClpSolution(0, 0, mat, 0, ader_optimization_solution_array);

    /* Go ahead and free the optimization array                               */

    free(ader_optimization_solution_array);

    /* Gen the data to gen the matrix                                         */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

    /* Set the time interval for data processing                              */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

	/* Map appropriate data                                                   */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 0, total_time);

    /* Set the material flux to 0, this is for testing                        */

    lithium7_flux = RDB[mat + MATERIAL_BURN_FLUX_SSA];

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = 0.0;

    /* Next get the Fluorine1 material to set its flux level                  */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Fluorine1", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Set the material flux to 0, this is for testing                        */

    fluorine1_flux = RDB[mat + MATERIAL_BURN_FLUX_SSA];

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = 0.0;

    /* Now, get the indices of the matrix that need to be checked             */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Lithium7", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
    	{

    		li6_lithium7_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    		li6_lithium7_hold = RDB[mat_iso + COMPOSITION_ADENS];

    		li6_lithium7_mat_iso = mat_iso;

    		WDB[mat_iso + COMPOSITION_ADENS] = RDB[ader_mat_data + ADER_MAT_PRE_STEP_ADENS] / 2.0;

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

    		li7_lithium7_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(li6_lithium7_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the index for Li-6 was not found.\n");

    }

    if(li7_lithium7_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the index for Li-7 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Li6", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		li6_lithium7_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.25;

    	}


    	if(strcmp("rLi7", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		rli7_lithium7_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	if(strcmp("Li6Li7", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		li6li7_lithium7_remv_stream_found = 1;

    		ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    		while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    		{

    			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

    			if(strcmp("Li6", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				li6_lithium7_remv_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			if(strcmp("Li7", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				li7_lithium7_remv_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    		}

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(li6_lithium7_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the index for the Li6 remv stream\n\
was not found.\n");

    }

    if(rli7_lithium7_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the index for the rLi7 remv stream\n\
was not found.\n");

    }

    if(li6li7_lithium7_remv_stream_found < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the index for the Li6Li7 remv stream\n\
was not found.\n");

    }
    else
    {

    	if(li6_lithium7_remv_sum_stream_index < 0 &&
    	   li7_lithium7_remv_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
"In burnup matrix for material Lithium7 the indices for the Li6 and Li7\n\
summation streams were not found though the parent stream, Li6Li7, was found.\n");

    	}
    	else if(li6_lithium7_remv_sum_stream_index > 0 &&
    	    	li7_lithium7_remv_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material Lithium7 the index for the Li7 summation\n\
stream in parent stream Li6Li7 was not found though the index for the\n\
Li6 summation stream was found.\n");

    	}
    	else if(li6_lithium7_remv_sum_stream_index < 0 &&
    	    	li7_lithium7_remv_sum_stream_index > 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material Lithium7 the index for the Li6 summation\n\
stream in parent stream Li6Li7 was not found though the index for the\n\
Li7 summation stream was found.\n");

    	}

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Fluorine1", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
    	{

    		li6_fluorine1_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

    		li7_fluorine1_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(li6_fluorine1_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the index for Li-6 was not found.\n");

    }

    if(li7_fluorine1_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the index for Li-7 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Li6Li7", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		li6li7_fluorine1_remv_stream_found = 1;

    		ader_mat_stream_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    		while(ader_mat_stream_sum_stream_ent > VALID_PTR)
    		{

    			ader_mat_stream_sum_stream = (long)RDB[ader_mat_stream_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

    			if(strcmp("Li6", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				li6_fluorine1_remv_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			if(strcmp("Li7", GetText(ader_mat_stream_sum_stream + ADER_MAT_STREAM_ID)) == 0)
    			{

    				li7_fluorine1_remv_sum_stream_index = (long)RDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_BURN_INDEX];

    				WDB[ader_mat_stream_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    			}

    			ader_mat_stream_sum_stream_ent = NextItem(ader_mat_stream_sum_stream_ent);

    		}

    	}

    	if(strcmp("Li6", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		li6_fluorine1_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.25;

    	}

    	if(strcmp("rLi7", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		rli7_fluorine1_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(li6_fluorine1_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the index for the Li6 remv stream\n\
was not found.\n");

    }

    if(rli7_fluorine1_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the index for the rLi7 remv stream\n\
was not found.\n");

    }

    if(li6li7_fluorine1_remv_stream_found < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the index for the Li6Li7 feed stream\n\
was not found.\n");

    }
    else
    {

    	if(li6_fluorine1_remv_sum_stream_index < 0 &&
    	   li7_fluorine1_remv_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine1 the indices for the Li6 and Li7\n\
summation streams were not found though the parent stream, Li6Li7, was found.\n");

    	}
    	else if(li6_fluorine1_remv_sum_stream_index > 0 &&
    	    	li7_fluorine1_remv_sum_stream_index < 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material Fluorine1 the index for the Li7 summation\n\
stream in parent stream Li6Li7 was not found though the index for the\n\
Li6 summation stream was found.\n");

    	}
    	else if(li6_fluorine1_remv_sum_stream_index < 0 &&
    	    	li7_fluorine1_remv_sum_stream_index > 0)
    	{

        	Die(FUNCTION_NAME,\
    "In burnup matrix for material Fluorine1 the index for the Li6 summation\n\
stream in parent stream Li6Li7 was not found though the index for the\n\
Li7 summation stream was found.\n");

    	}

    }

    /* Gen the burnup matrix                                                  */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Lithium7", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

    ADERMakeBurnMatrix(burn_matrix,
    		           ader_burn_matrix_col_storage, mat,
					   (long)ader_burn_matrix_num_ents[0],
					   (long)ader_burn_matrix_num_rows[0], step, type, t1, t2);

    /* Now get the values from the burn matrix and compare to the expected    */

    tv_nf_cl_ps_gt_ss_ti_ro = ADERGetBurnMatrixValue(li6_lithium7_index,
    		                                         burn_matrix,
												     li6_lithium7_index);

    pd_nf_cl_ps_gt_ss_ti_ro = (tv_nf_cl_ps_gt_ss_ti_ro - pv_nf_cl_ps_gt_ss_ti_ro) /
    		                                             pv_nf_cl_ps_gt_ss_ti_ro;

    if(fabs(pd_nf_cl_ps_gt_ss_ti_ro) < 0.001)
    {

    	bl_nf_cl_ps_gt_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_nf_cl_ps_gt_sd_ti_ro = ADERGetBurnMatrixValue(li6_lithium7_index,
    		                                         burn_matrix,
												     li6_fluorine1_index);

    pd_nf_cl_ps_gt_sd_ti_ro = (tv_nf_cl_ps_gt_sd_ti_ro - pv_nf_cl_ps_gt_sd_ti_ro) /
    		                                             pv_nf_cl_ps_gt_sd_ti_ro;

    if(fabs(pd_nf_cl_ps_gt_sd_ti_ro) < 0.001)
    {

    	bl_nf_cl_ps_gt_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    /* Clear the memory associated with the zero flux TestTank burn matrix    */

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    /* Reset the Fluorine1 flux                                               */

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = fluorine1_flux;

    /* Reset the Lithium7 flux                                                */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strcmp("Lithium7", GetText(mat + MATERIAL_PTR_NAME)) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Reset the Lithium7 flux                                                */

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = lithium7_flux;

    /* SECOND: We do the tests with flux                                      */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("TestTank", GetText(mat + MATERIAL_PTR_NAME), 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Gen the data to gen the matrix                                         */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

    /* Set the time interval for data processing                              */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

	/* Map appropriate data                                                   */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 0, total_time);

    /* Here we set the TestTank flux to a fixed value for testing             */

    WDB[mat + MATERIAL_BURN_FLUX_SSA] = 12.0;

    /* Gen the burnup matrix                                                  */

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

    ADERMakeBurnMatrix(burn_matrix,
    		           ader_burn_matrix_col_storage, mat,
					   (long)ader_burn_matrix_num_ents[0],
					   (long)ader_burn_matrix_num_rows[0], step, type, t1, t2);

    /* Now get the values from the burn matrix and compare to the expected    */

    tv_fx_nc_cs_gt_ts = ADERGetBurnMatrixValue(h1_testtank_feed_stream_index,
    		                                   burn_matrix,
											   h1_testtank_feed_stream_index);

    if(tv_fx_nc_cs_gt_ts == 0.0)
    {

    	bl_fx_nc_cs_gt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_ps_rt_ts = ADERGetBurnMatrixValue(rv51_testtank_remv_stream_index,
    		                                   burn_matrix,
											   rv51_testtank_remv_stream_index);

    if(tv_fx_nc_ps_rt_ts == 0.0)
    {

    	bl_fx_nc_ps_rt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_cs_rt_ts = ADERGetBurnMatrixValue(rw186_testtank_remv_stream_index,
    		                                   burn_matrix,
											   rw186_testtank_remv_stream_index);

    if(tv_fx_nc_cs_rt_ts == 0.0)
    {

    	bl_fx_nc_cs_rt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_cs_gt_ro = ADERGetBurnMatrixValue(h1_testtank_index,
    		                                          burn_matrix,
											          h1_testtank_feed_stream_index);

    if(tv_fx_nc_iso_ts_cs_gt_ro == 0.0)
    {

    	bl_fx_nc_iso_ts_cs_gt_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_cs_rt_ro = ADERGetBurnMatrixValue(w186_testtank_index,
    		                                         burn_matrix,
											         rw186_testtank_remv_stream_index);

    if(tv_fx_nc_iso_ts_cs_rt_ro == 0.0)
    {

    	bl_fx_nc_iso_ts_cs_rt_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_ps_rt_co = ADERGetBurnMatrixValue(rv51_testtank_remv_stream_index,
    		                                          burn_matrix,
													  v51_testtank_index);

    if(tv_fx_nc_iso_ts_ps_rt_co == 0.0)
    {

    	bl_fx_nc_iso_ts_ps_rt_co = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_ps_rt_ro = ADERGetBurnMatrixValue(v51_testtank_index,
    		                                          burn_matrix,
											          rv51_testtank_remv_stream_index);

    pd_fx_nc_iso_ts_ps_rt_ro = (tv_fx_nc_iso_ts_ps_rt_ro - pv_fx_nc_iso_ts_ps_rt_ro) /
    		                                               pv_fx_nc_iso_ts_ps_rt_ro;

    if(fabs(pd_fx_nc_iso_ts_ps_rt_ro) < 0.001)
    {
    	bl_fx_nc_iso_ts_ps_rt_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_cs_gt_ti_ro = ADERGetBurnMatrixValue(h1_testtank_feed_stream_index,
    		                                      burn_matrix,
												  h1_testtank_index);

    pd_fx_nc_cs_gt_ti_ro = (tv_fx_nc_cs_gt_ti_ro - pv_fx_nc_cs_gt_ti_ro) /
    		                                       pv_fx_nc_cs_gt_ti_ro;

    if(fabs(pd_fx_nc_cs_gt_ti_ro) < 0.001)
    {

    	bl_fx_nc_cs_gt_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_cs_rt_ti_ro = ADERGetBurnMatrixValue(rw186_testtank_remv_stream_index,
    		                                      burn_matrix,
												  w186_testtank_index);

    pd_fx_nc_cs_rt_ti_ro = (tv_fx_nc_cs_rt_ti_ro - pv_fx_nc_cs_rt_ti_ro) /
    		                                       pv_fx_nc_cs_rt_ti_ro;

    if(fabs(pd_fx_nc_cs_rt_ti_ro) < 0.001)
    {

    	bl_fx_nc_cs_rt_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_cs_gt_sm_s1_ti_ro = ADERGetBurnMatrixValue(ta181_testtank_feed_sum_stream_index,
    		                                            burn_matrix,
												        ta181_testtank_index);

    pd_fx_nc_cs_gt_sm_s1_ti_ro = (tv_fx_nc_cs_gt_sm_s1_ti_ro - pv_fx_nc_cs_gt_sm_s1_ti_ro) /
    		                                                   pv_fx_nc_cs_gt_sm_s1_ti_ro;

    if(fabs(pd_fx_nc_cs_gt_sm_s1_ti_ro) < 0.001)
    {

    	bl_fx_nc_cs_gt_sm_s1_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_cs_gt_sm_s2_ti_ro = ADERGetBurnMatrixValue(v51_testtank_feed_sum_stream_index,
    		                                            burn_matrix,
												        v51_testtank_index);

    pd_fx_nc_cs_gt_sm_s2_ti_ro = (tv_fx_nc_cs_gt_sm_s2_ti_ro - pv_fx_nc_cs_gt_sm_s2_ti_ro) /
    		                                                   pv_fx_nc_cs_gt_sm_s2_ti_ro;

    if(fabs(pd_fx_nc_cs_gt_sm_s2_ti_ro) < 0.001)
    {

    	bl_fx_nc_cs_gt_sm_s2_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_cs_gt_sm_s1_ro = ADERGetBurnMatrixValue(ta181_testtank_index,
    		                                             burn_matrix,
												         ta181_testtank_feed_sum_stream_index);

    if(tv_fx_nc_iso_ts_cs_gt_sm_s1_ro == 0.0)
    {

    	bl_fx_nc_iso_ts_cs_gt_sm_s1_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_nc_iso_ts_cs_gt_sm_s2_ro = ADERGetBurnMatrixValue(v51_testtank_index,
    		                                             burn_matrix,
												         v51_testtank_feed_sum_stream_index);

    if(tv_fx_nc_iso_ts_cs_gt_sm_s2_ro == 0.0)
    {

    	bl_fx_nc_iso_ts_cs_gt_sm_s2_ro = 1;

    	tests_passing += 1;

    }

    /* Clear the memory associated with the zero flux TestTank burn matrix    */

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    /* Now begin the tests with the Lithium7 cluster                          */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("Lithium7", GetText(mat + MATERIAL_PTR_NAME), 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Gen the data to gen the matrix                                         */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

    /* Set the time interval for data processing                              */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

	/* Map appropriate data                                                   */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 0, total_time);

    /* Gen the burnup matrix                                                  */

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

    ADERMakeBurnMatrix(burn_matrix,
    		           ader_burn_matrix_col_storage, mat,
					   (long)ader_burn_matrix_num_ents[0],
					   (long)ader_burn_matrix_num_rows[0], step, type, t1, t2);

    /* Begin gathering the test information                                   */

    tv_fx_cl_cs_rt_ss_ti_ro = ADERGetBurnMatrixValue(rli7_lithium7_remv_stream_index,
    		                                         burn_matrix,
												     li7_lithium7_index);

    pd_fx_cl_cs_rt_ss_ti_ro = (tv_fx_cl_cs_rt_ss_ti_ro - pv_fx_cl_cs_rt_ss_ti_ro) /
    		                                             pv_fx_cl_cs_rt_ss_ti_ro;

    if(fabs(pd_fx_cl_cs_rt_ss_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_rt_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_rt_sd_ti_ro = ADERGetBurnMatrixValue(rli7_fluorine1_remv_stream_index,
    		                                         burn_matrix,
												     li7_fluorine1_index);

    pd_fx_cl_cs_rt_sd_ti_ro = (tv_fx_cl_cs_rt_sd_ti_ro - pv_fx_cl_cs_rt_sd_ti_ro) /
    		                                             pv_fx_cl_cs_rt_sd_ti_ro;

    if(fabs(pd_fx_cl_cs_rt_sd_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_rt_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_rt_ts = ADERGetBurnMatrixValue(rli7_lithium7_remv_stream_index,
    		                                   burn_matrix,
											   rli7_lithium7_remv_stream_index);

    if(tv_fx_cl_cs_rt_ts == 0.0)
    {

    	bl_fx_cl_cs_rt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_rt_ss_ro = ADERGetBurnMatrixValue(li7_lithium7_index,
    		                                             burn_matrix,
												         rli7_lithium7_remv_stream_index);

    if(tv_fx_cl_iso_ts_cs_rt_ss_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_rt_ss_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_rt_sd_ro = ADERGetBurnMatrixValue(li7_fluorine1_index,
    		                                             burn_matrix,
												         rli7_fluorine1_remv_stream_index);

    if(tv_fx_cl_iso_ts_cs_rt_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_rt_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_gt_sd_co = ADERGetBurnMatrixValue(li6_fluorine1_remv_stream_index,
    		                                             burn_matrix,
												         li6_fluorine1_index);

    if(tv_fx_cl_iso_ts_ps_gt_sd_co == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_gt_sd_co = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_gt_ss_co = ADERGetBurnMatrixValue(li6_lithium7_remv_stream_index,
    		                                             burn_matrix,
												         li6_lithium7_index);

    if(tv_fx_cl_iso_ts_ps_gt_ss_co == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_gt_ss_co = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_gt_sd_ro = ADERGetBurnMatrixValue(li6_fluorine1_index,
    		                                             burn_matrix,
														 li6_fluorine1_remv_stream_index);

    if(tv_fx_cl_iso_ts_ps_gt_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_gt_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_gt_ss_ro = ADERGetBurnMatrixValue(li6_lithium7_index,
    		                                             burn_matrix,
														 li6_lithium7_remv_stream_index);

    pd_fx_cl_iso_ts_ps_gt_ss_ro = (tv_fx_cl_iso_ts_ps_gt_ss_ro - pv_fx_cl_iso_ts_ps_gt_ss_ro) /
    		                                                     pv_fx_cl_iso_ts_ps_gt_ss_ro;

    if(fabs(pd_fx_cl_iso_ts_ps_gt_ss_ro) < 0.001)
    {

    	bl_fx_cl_iso_ts_ps_gt_ss_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_ps_gt_ts = ADERGetBurnMatrixValue(li6_lithium7_remv_stream_index,
    		                                   burn_matrix,
											   li6_lithium7_remv_stream_index);

    if(tv_fx_cl_ps_gt_ts == 0.0)
    {

    	bl_fx_cl_ps_gt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_sm_s1_sd_ti_ro = ADERGetBurnMatrixValue(li6_fluorine1_remv_sum_stream_index,
    		                                               burn_matrix,
												           li6_fluorine1_index);

    pd_fx_cl_cs_gt_sm_s1_sd_ti_ro = (tv_fx_cl_cs_gt_sm_s1_sd_ti_ro - pv_fx_cl_cs_gt_sm_s1_sd_ti_ro) /
    		                                                         pv_fx_cl_cs_gt_sm_s1_sd_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_sm_s1_sd_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_sm_s1_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_sm_s1_ss_ti_ro = ADERGetBurnMatrixValue(li6_lithium7_remv_sum_stream_index,
    		                                               burn_matrix,
												           li6_lithium7_index);

    pd_fx_cl_cs_gt_sm_s1_ss_ti_ro = (tv_fx_cl_cs_gt_sm_s1_ss_ti_ro - pv_fx_cl_cs_gt_sm_s1_ss_ti_ro) /
    		                                                         pv_fx_cl_cs_gt_sm_s1_ss_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_sm_s1_ss_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_sm_s1_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_sm_s2_sd_ti_ro = ADERGetBurnMatrixValue(li7_fluorine1_remv_sum_stream_index,
    		                                               burn_matrix,
												           li7_fluorine1_index);

    pd_fx_cl_cs_gt_sm_s2_sd_ti_ro = (tv_fx_cl_cs_gt_sm_s2_sd_ti_ro - pv_fx_cl_cs_gt_sm_s2_sd_ti_ro) /
    		                                                         pv_fx_cl_cs_gt_sm_s2_sd_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_sm_s2_sd_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_sm_s2_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_sm_s2_ss_ti_ro = ADERGetBurnMatrixValue(li7_lithium7_remv_sum_stream_index,
    		                                               burn_matrix,
												           li7_lithium7_index);

    pd_fx_cl_cs_gt_sm_s2_ss_ti_ro = (tv_fx_cl_cs_gt_sm_s2_ss_ti_ro - pv_fx_cl_cs_gt_sm_s2_ss_ti_ro) /
    		                                                         pv_fx_cl_cs_gt_sm_s2_ss_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_sm_s2_ss_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_sm_s2_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro = ADERGetBurnMatrixValue(li6_fluorine1_index,
    		                                                   burn_matrix,
															   li6_fluorine1_remv_sum_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro = ADERGetBurnMatrixValue(li6_lithium7_index,
    		                                                   burn_matrix,
															   li6_lithium7_remv_sum_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro = ADERGetBurnMatrixValue(li7_fluorine1_index,
    		                                                   burn_matrix,
															   li7_fluorine1_remv_sum_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro = ADERGetBurnMatrixValue(li7_lithium7_index,
    		                                                   burn_matrix,
															   li7_lithium7_remv_sum_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro = 1;

    	tests_passing += 1;

    }

    /* Clear the memory associated with the zero flux TestTank burn matrix    */

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    /* Now begin the tests with the FLiBeFuel cluster                          */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("FLiBeFuel", GetText(mat + MATERIAL_PTR_NAME), 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* These following steps are to clear stream CUR_AMT data so as to not    */
    /* Interfere with testing the "+1" seen in the allocation is for the CLP  */
    /* return value and while that does not matter here we stick with         */
    /* convention for clarity                                                 */

    ader_mat_matrix_data = (long)RDB[ader_mat_data + ADER_MAT_MATRIX_PTR];

    ader_optimization_solution_array = calloc((long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_NUM_COLS] + 1, sizeof(double));

    /* ADERParseClpSolution is called as it is the easiest way to reset all   */
    /* streams                                                                */

    ADERParseClpSolution(0, 0, mat, 0, ader_optimization_solution_array);

    /* Go ahead and free the optimization array                               */

    free(ader_optimization_solution_array);

    /* Gen the data to gen the matrix                                         */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	ader_burn_matrix_num_ents = ader_burn_matrix_size_data[1];

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_col_storage = ader_burn_matrix_size_data[4];

    /* Set the time interval for data processing                              */

	total_time = RDB[DATA_BURN_TIME_INTERVAL];

	/* Map appropriate data                                                   */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 0, total_time);

    /* Now gather the index information that is needed                        */

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 10030)
    	{

    		h3_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 20040)
    	{

    		he4_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
    	{

    		li6_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}


    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

    		li7_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 40090)
    	{

    		be9_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 541350)
    	{

    		xe135_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
    	{

    		u233_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 922390)
    	{

    		u239_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 932390)
    	{

    		np239_flibefuel_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(h3_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for H-3 was not found.\n");

    }

    if(he4_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for He-4 was not found.\n");

    }

    if(li6_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for Li-6 was not found.\n");

    }

    if(li7_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for Li-7 was not found.\n");

    }

    if(be9_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for Be-9 was not found.\n");

    }

    if(xe135_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for Xe-135 was not found.\n");

    }

    if(u233_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for U-233 was not found.\n");

    }

    if(u239_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for U-239 was not found.\n");

    }

    if(np239_flibefuel_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for Np-239 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Beryllium", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		beryllium_flibefuel_redox_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(beryllium_flibefuel_redox_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for the Beryllium redox\n\
stream was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("reproc", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		reproc_flibefuel_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(reproc_flibefuel_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material FLiBeFuel the index for the reproc removal\n\
stream was not found.\n");

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("Argon40", GetText(mat + MATERIAL_PTR_NAME), 7) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 20040)
    	{

    		he4_argon40_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

    		li7_argon40_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(he4_argon40_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Argon40 the index for He-4 was not found.\n");

    }

    if(li7_argon40_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Argon40 the index for Li-7 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("reproc", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		reproc_argon40_remv_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(reproc_argon40_remv_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Argon40 the index for the reproc feed\n\
stream was not found.\n");

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("Fluorine0", GetText(mat + MATERIAL_PTR_NAME), 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 90190)
    	{

    		f19_fluorine0_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(f19_fluorine0_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine0 the index for F-19 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Fluorine", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		fluorine_fluorine0_redox_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    		WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.5;

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(fluorine_fluorine0_redox_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Fluorine0 the index for the Fluorine redox\n\
stream was not found.\n");

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("Uranium233", GetText(mat + MATERIAL_PTR_NAME), 10) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[ader_mat_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 90190)
    	{

    		f19_uranium233_index = (long)RDB[ader_mat_iso + ADER_MAT_ISO_BURN_INDEX];

    	}

    	ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(f19_uranium233_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Uranium233 the index for F-19 was not found.\n");

    }

    ader_mat_stream = (long)RDB[ader_mat_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	if(strcmp("Fluorine", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
    	{

    		fluorine_uranium233_redox_stream_index = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_BURN_INDEX];

    	}

    	ader_mat_stream = NextItem(ader_mat_stream);

    }

    if(fluorine_uranium233_redox_stream_index < 0)
    {

    	Die(FUNCTION_NAME,\
"In burnup matrix for material Uranium233 the index for the Fluorine redox\n\
stream was not found.\n");

    }

    /* Gen the burnup matrix                                                  */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        if(strncmp("FLiBeFuel", GetText(mat + MATERIAL_PTR_NAME), 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ader_mat_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	burn_matrix = ccsMatrixNew((long)ader_burn_matrix_num_rows[0],
			                   (long)ader_burn_matrix_num_rows[0],
							   (long)ader_burn_matrix_num_ents[0]);

    ADERMakeBurnMatrix(burn_matrix,
    		           ader_burn_matrix_col_storage, mat,
					   (long)ader_burn_matrix_num_ents[0],
					   (long)ader_burn_matrix_num_rows[0], step, type, t1, t2);

    /* Begin gathering the test information                                   */

    tv_fx_cl_cs_gt_sd_ti_ro = ADERGetBurnMatrixValue(fluorine_uranium233_redox_stream_index,
    		                                         burn_matrix,
												     f19_uranium233_index);

    pd_fx_cl_cs_gt_sd_ti_ro = (tv_fx_cl_cs_gt_sd_ti_ro - pv_fx_cl_cs_gt_sd_ti_ro) /
    		                                             pv_fx_cl_cs_gt_sd_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_sd_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_ss_ti_ro = ADERGetBurnMatrixValue(fluorine_fluorine0_redox_stream_index,
    		                                         burn_matrix,
												     f19_fluorine0_index);

    pd_fx_cl_cs_gt_ss_ti_ro = (tv_fx_cl_cs_gt_ss_ti_ro - pv_fx_cl_cs_gt_ss_ti_ro) /
    		                                             pv_fx_cl_cs_gt_ss_ti_ro;

    if(fabs(pd_fx_cl_cs_gt_ss_ti_ro) < 0.001)
    {

    	bl_fx_cl_cs_gt_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_cs_gt_ts = ADERGetBurnMatrixValue(fluorine_fluorine0_redox_stream_index,
    		                                   burn_matrix,
											   fluorine_fluorine0_redox_stream_index);

    if(tv_fx_cl_cs_gt_ts == 0.0)
    {

    	bl_fx_cl_cs_gt_ts = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_dp_ti_ro = ADERGetBurnMatrixValue(u239_flibefuel_index,
    		                                       burn_matrix,
												   np239_flibefuel_index);

    if(tv_fx_cl_iso_dp_ti_ro > 0.0)
    {

    	bl_fx_cl_iso_dp_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_fp_ti_ro = ADERGetBurnMatrixValue(u233_flibefuel_index,
    		                                       burn_matrix,
												   xe135_flibefuel_index);

    if(tv_fx_cl_iso_fp_ti_ro > 0.0)
    {

    	bl_fx_cl_iso_fp_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_nt_ti_ro = ADERGetBurnMatrixValue(li6_flibefuel_index,
    		                                       burn_matrix,
												   h3_flibefuel_index);

    if(tv_fx_cl_iso_nt_ti_ro > 0.0)
    {

    	bl_fx_cl_iso_nt_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_sd_ro = ADERGetBurnMatrixValue(f19_uranium233_index,
    		                                             burn_matrix,
												         fluorine_uranium233_redox_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_cs_gt_ss_ro = ADERGetBurnMatrixValue(f19_fluorine0_index,
    		                                             burn_matrix,
												         fluorine_fluorine0_redox_stream_index);

    if(tv_fx_cl_iso_ts_cs_gt_ss_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_cs_gt_ss_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_rt_sd_co = ADERGetBurnMatrixValue(reproc_argon40_remv_stream_index,
    		                                             burn_matrix,
												         li7_argon40_index);

    if(tv_fx_cl_iso_ts_ps_rt_sd_co == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_rt_sd_co = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_rt_ss_co = ADERGetBurnMatrixValue(reproc_flibefuel_remv_stream_index,
    		                                             burn_matrix,
												         li7_flibefuel_index);

    if(tv_fx_cl_iso_ts_ps_rt_ss_co == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_rt_ss_co = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_rt_sd_ro = ADERGetBurnMatrixValue(li7_argon40_index,
    		                                             burn_matrix,
														 reproc_argon40_remv_stream_index);

    if(tv_fx_cl_iso_ts_ps_rt_sd_ro == 0.0)
    {

    	bl_fx_cl_iso_ts_ps_rt_sd_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_iso_ts_ps_rt_ss_ro = ADERGetBurnMatrixValue(li7_flibefuel_index,
    		                                             burn_matrix,
														 reproc_argon40_remv_stream_index);

    pd_fx_cl_iso_ts_ps_rt_ss_ro = (tv_fx_cl_iso_ts_ps_rt_ss_ro - pv_fx_cl_iso_ts_ps_rt_ss_ro) /
    		                                                     pv_fx_cl_iso_ts_ps_rt_ss_ro;

    if(fabs(pd_fx_cl_iso_ts_ps_rt_ss_ro) < 0.001)
    {

    	bl_fx_cl_iso_ts_ps_rt_ss_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_ps_rt_sd_ti_ro = ADERGetBurnMatrixValue(he4_flibefuel_index,
    		                                         burn_matrix,
													 he4_argon40_index);

    pd_fx_cl_ps_rt_sd_ti_ro = (tv_fx_cl_ps_rt_sd_ti_ro - pv_fx_cl_ps_rt_sd_ti_ro) /
    		                                             pv_fx_cl_ps_rt_sd_ti_ro;

    if(fabs(pd_fx_cl_ps_rt_sd_ti_ro) < 0.001)
    {

    	bl_fx_cl_ps_rt_sd_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_ps_rt_ss_ti_ro = ADERGetBurnMatrixValue(he4_flibefuel_index,
    		                                         burn_matrix,
													 he4_flibefuel_index);

    pd_fx_cl_ps_rt_ss_ti_ro = (tv_fx_cl_ps_rt_ss_ti_ro - pv_fx_cl_ps_rt_ss_ti_ro) /
    		                                             pv_fx_cl_ps_rt_ss_ti_ro;

    if(fabs(pd_fx_cl_ps_rt_ss_ti_ro) < 0.001)
    {

    	bl_fx_cl_ps_rt_ss_ti_ro = 1;

    	tests_passing += 1;

    }

    tv_fx_cl_ps_rt_ts = ADERGetBurnMatrixValue(reproc_flibefuel_remv_stream_index,
    		                                   burn_matrix,
										       reproc_flibefuel_remv_stream_index);

    if(tv_fx_cl_ps_rt_ts == 0.0)
    {

    	bl_fx_cl_ps_rt_ts = 1;

    	tests_passing += 1;

    }

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

    /* Free the memory                                                        */

    ccsMatrixFree(burn_matrix);

    /* Reset the Lithium7 Li-6 value and density                              */

	WDB[li6_lithium7_mat_iso + COMPOSITION_ADENS] = li6_lithium7_hold;

    if(bl_nf_nc_ps_rt_ti_ro == 1 &&
       bl_nf_nc_iso_dy_ti_ro == 1 &&
	   bl_nf_cl_ps_gt_ss_ti_ro == 1 &&
	   bl_nf_cl_ps_gt_sd_ti_ro == 1 &&
	   bl_fx_nc_cs_gt_ts == 1 &&
	   bl_fx_nc_ps_rt_ts == 1 &&
	   bl_fx_nc_cs_rt_ts == 1 &&
	   bl_fx_nc_iso_ts_cs_gt_ro == 1 &&
	   bl_fx_nc_iso_ts_cs_rt_ro == 1 &&
	   bl_fx_nc_iso_ts_ps_rt_co == 1 &&
	   bl_fx_nc_iso_ts_ps_rt_ro == 1 &&
	   bl_fx_nc_cs_gt_ti_ro == 1 &&
	   bl_fx_nc_cs_rt_ti_ro == 1 &&
	   bl_fx_nc_cs_gt_sm_s1_ti_ro == 1 &&
	   bl_fx_nc_cs_gt_sm_s2_ti_ro == 1 &&
	   bl_fx_nc_iso_ts_cs_gt_sm_s1_ro == 1 &&
	   bl_fx_nc_iso_ts_cs_gt_sm_s2_ro == 1 &&
	   bl_fx_cl_cs_rt_ss_ti_ro == 1 &&
	   bl_fx_cl_cs_rt_sd_ti_ro == 1 &&
	   bl_fx_cl_cs_rt_ts == 1 &&
	   bl_fx_cl_iso_ts_cs_rt_ss_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_rt_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_ps_gt_sd_co == 1 &&
	   bl_fx_cl_iso_ts_ps_gt_ss_co == 1 &&
	   bl_fx_cl_iso_ts_ps_gt_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_ps_gt_ss_ro == 1 &&
	   bl_fx_cl_ps_gt_ts == 1 &&
	   bl_fx_cl_cs_gt_sm_s1_sd_ti_ro == 1 &&
	   bl_fx_cl_cs_gt_sm_s1_ss_ti_ro == 1 &&
	   bl_fx_cl_cs_gt_sm_s2_sd_ti_ro == 1 &&
	   bl_fx_cl_cs_gt_sm_s2_ss_ti_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro == 1 &&
	   bl_fx_cl_cs_gt_sd_ti_ro == 1 &&
	   bl_fx_cl_cs_gt_ss_ti_ro  == 1 &&
	   bl_fx_cl_cs_gt_ts == 1 &&
	   bl_fx_cl_iso_dp_ti_ro == 1 &&
	   bl_fx_cl_iso_fp_ti_ro == 1 &&
	   bl_fx_cl_iso_nt_ti_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_cs_gt_ss_ro == 1 &&
	   bl_fx_cl_iso_ts_ps_rt_sd_co == 1 &&
	   bl_fx_cl_iso_ts_ps_rt_ss_co == 1 &&
	   bl_fx_cl_iso_ts_ps_rt_sd_ro == 1 &&
	   bl_fx_cl_iso_ts_ps_rt_ss_ro == 1 &&
	   bl_fx_cl_ps_rt_sd_ti_ro == 1 &&
	   bl_fx_cl_ps_rt_ss_ti_ro == 1 &&
	   bl_fx_cl_ps_rt_ts == 1)
    {

        boolean = 1;

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        memset(print_data, 0, strlen(print_data));

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        sprintf(print_data, "\nSub-tests passing: %ld / 50:", tests_passing);

        PrintTest(test_name, status, print_data, 1);

        /* We do not report out the allocation boolean because the program    */
        /* seg fault if that boolean would not pass                           */

        if(bl_nf_nc_ps_rt_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Zero flux non-cluster proportional removal table stream to iso row: FAIL:\n\
  Isotope V-51 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from proportional removal table removal stream rV51 in material TestTank.\n\
  Variable family in test - nf_nc_ps_rt_ti_ro\n",
                    tv_nf_nc_ps_rt_ti_ro, v51_testtank_index,
					v51_testtank_index, pv_nf_nc_ps_rt_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Zero flux non-cluster proportional removal table stream to iso row: PASS\n\
  Variable family in test - nf_nc_ps_rt_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_nf_nc_iso_dy_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Zero flux non-cluster isotope decay rate: FAIL:\n\
  Isotope U-233 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  Variable family in test - nf_nc_iso_dy_ti_ro\n",
                    tv_nf_nc_iso_dy_ti_ro, u233_testtank_index,
					u233_testtank_index, pv_nf_nc_iso_dy_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Zero flux non-cluster isotope decay rate: PASS\n\
  Variable family in test - nf_nc_iso_dy_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_nf_cl_ps_gt_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Zero flux cluster proportional group type source stream to iso row: FAIL:\n\
  Isotope Li-6 in material Lithium7 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from proportional group type feed stream Li6 in material Lithium7.\n\
  Variable family in test - nf_cl_ps_gt_ss_ti_ro\n",
                    tv_nf_cl_ps_gt_ss_ti_ro, li6_lithium7_index,
					li6_lithium7_index, pv_nf_cl_ps_gt_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Zero flux cluster proportional group type source stream to iso row: PASS\n\
  Variable family in test - nf_cl_ps_gt_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_nf_cl_ps_gt_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Zero flux cluster proportional group type destination stream to iso row:\n\
  FAIL:\n\
  Isotope Li-6 in material Fluorine1 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from proportional group type feed stream Li6 in material Fluorine1.\n\
  Variable family in test - nf_cl_ps_gt_sd_ti_ro\n",
                    tv_nf_cl_ps_gt_sd_ti_ro, li6_fluorine1_index,
					li6_lithium7_index, pv_nf_cl_ps_gt_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Zero flux cluster proportional group type destination stream to iso row:\n\
  PASS\n\
  Variable family in test - nf_cl_ps_gt_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_gt_ts == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type stream self value: FAIL:\n\
  Continuous group type stream H1 in material TestTank\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_cs_gt_ts\n",
                    tv_fx_nc_cs_gt_ts, h1_testtank_feed_stream_index,
					h1_testtank_feed_stream_index, pv_fx_nc_cs_gt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type stream self value: PASS\n\
  Variable family in test - fx_nc_cs_gt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_ps_rt_ts == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster proportional removal table stream self value: FAIL:\n\
  Proportional removal table stream rV51 in material TestTank\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_ps_rt_ts\n",
                    tv_fx_nc_ps_rt_ts, rv51_testtank_remv_stream_index,
					rv51_testtank_remv_stream_index, pv_fx_nc_ps_rt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster proportional removal table stream self value: PASS\n\
  Variable family in test - fx_nc_ps_rt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_rt_ts == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous removal table stream self value: FAIL:\n\
  Continuous removal table stream rW186 in material TestTank\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_cs_rt_ts\n",
                    tv_fx_nc_cs_rt_ts, rw186_testtank_remv_stream_index,
					rw186_testtank_remv_stream_index, pv_fx_nc_cs_rt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous removal table stream self value: PASS\n\
  Variable family in test - fx_nc_cs_rt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_cs_gt_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type stream row: FAIL:\n\
  H-1 in material TestTank has given H1 continuous group type feed stream\n\
  a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_ro\n",
                    tv_fx_nc_iso_ts_cs_gt_ro, h1_testtank_feed_stream_index,
					h1_testtank_index, pv_fx_nc_iso_ts_cs_gt_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type stream row: PASS\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_cs_rt_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous removal table stream row: FAIL:\n\
  W-186 in material TestTank has given rW186 continuous removal table removal\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_iso_ts_cs_rt_ro\n",
                    tv_fx_nc_iso_ts_cs_rt_ro, rw186_testtank_remv_stream_index,
					w186_testtank_index, pv_fx_nc_iso_ts_cs_rt_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous removal table stream row: PASS\n\
  Variable family in test - fx_nc_iso_ts_cs_rt_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_ps_rt_co == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to proportional removal table stream column: FAIL:\n\
  V-51 in material TestTank has value of %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E in the\n\
  column corresponding to the rV51 removal table removal stream in TestTank.\n\
  Variable family in test - fx_nc_iso_ts_ps_rt_co\n",
                    tv_fx_nc_iso_ts_ps_rt_co, v51_testtank_index,
					rv51_testtank_remv_stream_index, pv_fx_nc_iso_ts_ps_rt_co);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to proportional removal table stream column: PASS\n\
  Variable family in test - fx_nc_iso_ts_ps_rt_co\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_ps_rt_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to proportional removal table stream row: FAIL:\n\
  V-51 in material TestTank has given rV51 proportional removal table removal\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_nc_iso_ts_ps_rt_ro\n",
                    tv_fx_nc_iso_ts_ps_rt_ro, rv51_testtank_remv_stream_index,
					v51_testtank_index, pv_fx_nc_iso_ts_ps_rt_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to proportional removal table stream row: PASS\n\
  Variable family in test - fx_nc_iso_ts_ps_rt_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_gt_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type stream to iso row: FAIL:\n\
  Isotope H-1 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous group type feed stream H1 in material TestTank.\n\
  Variable family in test - fx_nc_cs_gt_ti_ro\n",
                    tv_fx_nc_cs_gt_ti_ro, h1_testtank_index,
					h1_testtank_feed_stream_index, pv_fx_nc_cs_gt_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type stream to iso row: PASS\n\
  Variable family in test - fx_nc_cs_gt_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_rt_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous removal table stream to iso row: FAIL:\n\
  Isotope W-186 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous removal table removal stream rW186 in material TestTank.\n\
  Variable family in test - fx_nc_cs_rt_ti_ro\n",
                    tv_fx_nc_cs_rt_ti_ro, w186_testtank_index,
					rw186_testtank_remv_stream_index, pv_fx_nc_cs_rt_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous removal table stream to iso row: PASS\n\
  Variable family in test - fx_nc_cs_rt_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_gt_sm_s1_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type first summation stream to iso row: FAIL\n\
  Ta-181 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  Ta181 in feed sum stream V51Ta181 in material TestTank.\n\
  Variable family in test - fx_nc_cs_gt_sm_s1_ti_ro\n",
                    tv_fx_nc_cs_gt_sm_s1_ti_ro, ta181_testtank_index,
					ta181_testtank_feed_sum_stream_index,
					pv_fx_nc_cs_gt_sm_s1_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type first summation stream to iso row: PASS\n\
  Variable family in test - fx_nc_cs_gt_sm_s1_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_cs_gt_sm_s2_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type second summation stream to iso row: FAIL\n\
  V-51 in material TestTank has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  V51 in feed sum stream V51Ta181 in material TestTank.\n\
  Variable family in test - fx_nc_cs_gt_sm_s2_ti_ro\n",
                    tv_fx_nc_cs_gt_sm_s2_ti_ro, v51_testtank_index,
					v51_testtank_feed_sum_stream_index,
					pv_fx_nc_cs_gt_sm_s2_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster continuous group type first summation stream to iso row: PASS\n\
  Variable family in test - fx_nc_cs_gt_sm_s2_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_cs_gt_sm_s1_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type first summation stream row: FAIL\n\
  Ta181 summation stream in parent feed stream V51Ta181 in material TestTank\n\
  has value %1.15E at matrix location [ %ld , %ld ]\n\
  but should have value %1.15E from Ta181 iso in material TestTank.\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_sm_s1\n",
                    tv_fx_nc_iso_ts_cs_gt_sm_s1_ro,
					ta181_testtank_feed_sum_stream_index,
					ta181_testtank_index,
					pv_fx_nc_iso_ts_cs_gt_sm_s1_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type first summation stream row: PASS\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_sm_s1\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_nc_iso_ts_cs_gt_sm_s2_ro == 0)
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type first summation stream row: FAIL\n\
  V51 summation stream in parent feed stream V51Ta181 in material TestTank\n\
  has value %1.15E at matrix location [ %ld , %ld ]\n\
  but should have value %1.15E from V51 iso in material TestTank.\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_sm_s2\n",
                    tv_fx_nc_iso_ts_cs_gt_sm_s2_ro,
					v51_testtank_feed_sum_stream_index,
					v51_testtank_index,
					pv_fx_nc_iso_ts_cs_gt_sm_s2_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Non-cluster iso to continuous group type first summation stream row: PASS\n\
  Variable family in test - fx_nc_iso_ts_cs_gt_sm_s2\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_rt_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous removal table source side stream to iso row: FAIL:\n\
  Isotope Li-7 in material Lithium7 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous removal table removal stream rLi7 in material Lithium7.\n\
  Variable family in test - fx_cl_cs_rt_ss_ti_ro\n",
                    tv_fx_cl_cs_rt_ss_ti_ro, li7_lithium7_index,
					rli7_lithium7_remv_stream_index, pv_fx_cl_cs_rt_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous removal table source side stream to iso row: PASS\n\
  Variable family in test - fx_cl_cs_rt_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_rt_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous removal table destination side stream to iso row: FAIL:\n\
  Isotope Li-7 in material Fluorine1 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous removal table feed stream rLi7 in material Fluorine1.\n\
  Variable family in test - fx_cl_cs_rt_sd_ti_ro\n",
                    tv_fx_cl_cs_rt_sd_ti_ro, li7_fluorine1_index,
					rli7_fluorine1_remv_stream_index, pv_fx_cl_cs_rt_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous removal table destination side stream to iso row: PASS\n\
  Variable family in test - fx_cl_cs_rt_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_rt_ts == 0)
        {

            sprintf(print_data, "\nTest: Continuous removal table stream self value: FAIL:\n\
  Continuous removal table stream rLi7 in material Lithium7\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_cs_rt_ts\n",
                    tv_fx_cl_cs_rt_ts, rli7_lithium7_remv_stream_index,
					rli7_lithium7_remv_stream_index, pv_fx_cl_cs_rt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous removal table stream self value: PASS\n\
  Variable family in test - fx_cl_cs_rt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_rt_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous removal table source side stream row: FAIL:\n\
  Li-7 in material Lithium7 has given rLi7 continuous removal table removal\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_iso_ts_cs_rt_ss_ro\n",
                    tv_fx_cl_iso_ts_cs_rt_ss_ro, rli7_lithium7_remv_stream_index,
					li7_lithium7_index, pv_fx_cl_iso_ts_cs_rt_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous removal table source side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_rt_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_rt_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous removal table destination side stream row: FAIL:\n\
  Li-7 in material Fluorine1 has given rLi7 continuous removal table feed\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_iso_ts_cs_rt_sd_ro\n",
                    tv_fx_cl_iso_ts_cs_rt_sd_ro, rli7_fluorine1_remv_stream_index,
					li7_fluorine1_index, pv_fx_cl_iso_ts_cs_rt_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous removal table destination side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_rt_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_gt_sd_co == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional group type destination side stream column: FAIL:\n\
  Li-6 in material Fluorine1 has value of %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E in the\n\
  column corresponding to the Li6 group type feed stream in Fluorine1.\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_sd_co\n",
                    tv_fx_cl_iso_ts_ps_gt_sd_co, li6_fluorine1_index,
					li6_fluorine1_remv_stream_index, pv_fx_cl_iso_ts_ps_gt_sd_co);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional group type destination side stream column: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_sd_co\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_gt_ss_co == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional group type source side stream column: FAIL:\n\
  Li-6 in material Lithium7 has value of %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E in the\n\
  column corresponding to the Li6 group type remv stream in Lithium7.\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_ss_co\n",
                    tv_fx_cl_iso_ts_ps_gt_ss_co, li6_lithium7_index,
					li6_lithium7_remv_stream_index, pv_fx_cl_iso_ts_ps_gt_ss_co);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional group type source side stream column: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_ss_co\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_gt_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional group type destination side stream row: FAIL:\n\
  The Li6 proportional group type feed stream in material Fluorine1 has\n\
  value of %1.15E at matrix location [ %ld , %ld ] but should have\n\
  value of %1.15E in the column corresponding to the Li6\n\
  isotope in material Fluorine1.\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_sd_ro\n",
                    tv_fx_cl_iso_ts_ps_gt_sd_ro, li6_fluorine1_remv_stream_index,
					li6_fluorine1_index, pv_fx_cl_iso_ts_ps_gt_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional group type destination side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_gt_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional group type source side stream row: FAIL:\n\
  The Li6 proportional group type remv stream in material Lithium7 has\n\
  value of %1.15E at matrix location [ %ld , %ld ] but should have\n\
  value of %1.15E in the column corresponding to the Li6\n\
  isotope in material Lithium7.\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_ss_ro\n",
                    tv_fx_cl_iso_ts_ps_gt_ss_ro, li6_lithium7_remv_stream_index,
					li6_lithium7_index, pv_fx_cl_iso_ts_ps_gt_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional group type source side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_gt_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_ps_gt_ts == 0)
        {

            sprintf(print_data, "\nTest: Proportional group type stream self value: FAIL:\n\
  Proportional group type stream Li6 in material Lithium7\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_ps_gt_ts\n",
                    tv_fx_cl_ps_gt_ts, li6_lithium7_remv_stream_index,
					li6_lithium7_remv_stream_index, pv_fx_cl_ps_gt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Proportional group type stream self value: PASS\n\
  Variable family in test - fx_cl_ps_gt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_sm_s1_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type first summation destination side stream\n\
to iso row: FAIL:\n\
  Li-6 in material Fluorine1 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  Li6 in feed sum stream Li6Li7 in material Fluorine1.\n\
  Variable family in test - fx_cl_cs_gt_sm_s1_sd_ti_ro\n",
                    tv_fx_cl_cs_gt_sm_s1_sd_ti_ro, li6_fluorine1_index,
					li6_fluorine1_remv_sum_stream_index,
					pv_fx_cl_cs_gt_sm_s1_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type first summation destination side stream\n\
to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_sm_s1_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_sm_s1_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type first summation source side stream\n\
to iso row: FAIL:\n\
  Li-6 in material Lithium7 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  Li6 in removal sum stream Li6Li7 in material Lithium7.\n\
  Variable family in test - fx_cl_cs_gt_sm_s1_ss_ti_ro\n",
                    tv_fx_cl_cs_gt_sm_s1_ss_ti_ro, li6_lithium7_index,
					li6_lithium7_remv_sum_stream_index,
					pv_fx_cl_cs_gt_sm_s1_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type first summation source side stream\n\
to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_sm_s1_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_sm_s2_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type second summation destination side stream\n\
to iso row: FAIL:\n\
  Li-7 in material Fluorine1 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  Li7 in feed sum stream Li6Li7 in material Fluorine1.\n\
  Variable family in test - fx_cl_cs_gt_sm_s2_sd_ti_ro\n",
                    tv_fx_cl_cs_gt_sm_s2_sd_ti_ro, li6_fluorine1_index,
					li6_fluorine1_remv_sum_stream_index,
					pv_fx_cl_cs_gt_sm_s2_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type second summation destination side stream\n\
to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_sm_s2_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_sm_s2_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type second summation source side stream\n\
to iso row: FAIL:\n\
  Li-7 in material Lithium7 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value %1.15E from summation stream\n\
  Li7 in removal sum stream Li6Li7 in material Lithium7.\n\
  Variable family in test - fx_cl_cs_gt_sm_s2_ss_ti_ro\n",
                    tv_fx_cl_cs_gt_sm_s2_ss_ti_ro, li7_lithium7_index,
					li7_lithium7_remv_sum_stream_index,
					pv_fx_cl_cs_gt_sm_s2_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type second summation source side stream\n\
to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_sm_s2_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type first summation destination side stream\n\
row: FAIL:\n\
  Li6 summation stream in parent feed stream Li6Li7 in material Fluorine1\n\
  has value %1.15E at matrix location [ %ld , %ld ] but should\n\
  have value %1.15E from Li-6 iso in material Fluorine1.\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s1_sd_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro,
					li6_fluorine1_remv_sum_stream_index,
					li6_fluorine1_index,
					pv_fx_cl_iso_ts_cs_gt_sm_s1_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type first summation destination side stream\n\
row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s1_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type first summation source side stream\n\
row: FAIL:\n\
  Li6 summation stream in parent remv stream Li6Li7 in material Lithium7\n\
  has value %1.15E at matrix location [ %ld , %ld ] but should\n\
  have value %1.15E from Li-6 iso in material Lithium7.\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s1_ss_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro,
					li6_lithium7_remv_sum_stream_index,
					li6_lithium7_index,
					pv_fx_cl_iso_ts_cs_gt_sm_s1_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type first summation source side stream\n\
row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s1_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type second summation destination side stream\n\
row: FAIL:\n\
  Li7 summation stream in parent feed stream Li6Li7 in material Fluorine1\n\
  has value %1.15E at matrix location [ %ld , %ld ] but should\n\
  have value %1.15E from Li-7 iso in material Fluorine1.\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s2_sd_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro,
					li7_fluorine1_remv_sum_stream_index,
					li7_fluorine1_index,
					pv_fx_cl_iso_ts_cs_gt_sm_s2_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type second summation destination side stream\n\
row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s2_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type second summation source side stream\n\
row: FAIL:\n\
  Li7 summation stream in parent remv stream Li6Li7 in material Lithium7\n\
  has value %1.15E at matrix location [ %ld , %ld ] but should\n\
  have value %1.15E from Li-7 iso in material Lithium7.\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s2_ss_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro,
					li7_lithium7_remv_sum_stream_index,
					li7_lithium7_index,
					pv_fx_cl_iso_ts_cs_gt_sm_s2_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type second summation source side stream\n\
row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sm_s2_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type destination side stream to iso row: FAIL:\n\
  Isotope F-19 in material Uranium233 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous group type redox stream Fluorine in material Uranium233.\n\
  Variable family in test - fx_cl_cs_gt_sd_ti_ro\n",
                    tv_fx_cl_cs_gt_sd_ti_ro, f19_uranium233_index,
					fluorine_uranium233_redox_stream_index, pv_fx_cl_cs_gt_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type destination side stream to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type source side stream to iso row: FAIL:\n\
  Isotope F-19 in material Fluorine0 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from continuous group type redox stream Fluorine in material Fluorine0.\n\
  Variable family in test - fx_cl_cs_gt_ss_ti_ro\n",
                    tv_fx_cl_cs_gt_ss_ti_ro, f19_fluorine0_index,
					fluorine_fluorine0_redox_stream_index, pv_fx_cl_cs_gt_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type source side stream to iso row: PASS\n\
  Variable family in test - fx_cl_cs_gt_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_cs_gt_ts == 0)
        {

            sprintf(print_data, "\nTest: Continuous group type stream self value: FAIL:\n\
  Continuous group type stream Fluorine in material Fluorine0\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_cs_gt_ts\n",
                    tv_fx_cl_cs_gt_ts, fluorine_fluorine0_redox_stream_index,
					fluorine_fluorine0_redox_stream_index, pv_fx_cl_cs_gt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Continuous group type stream self value: PASS\n\
  Variable family in test - fx_cl_cs_gt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_dp_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Isotope decay product production: FAIL:\n\
  Np-239 in material FLiBeFuel has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have a value greater than 0 from the\n\
  decay of U-239 in FLiBeFuel\n\
  Variable family in test - fx_cl_iso_dp_ti_ro\n",
                    tv_fx_cl_iso_dp_ti_ro, np239_flibefuel_index,
					u239_flibefuel_index);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Isotope decay product production: PASS\n\
  Variable family in test - fx_cl_iso_dp_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_fp_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Isotope fission product production: FAIL:\n\
  Xe-135 in material FLiBeFuel has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have a value greater than 0 from the\n\
  fission of U-233 in FLiBeFuel\n\
  Variable family in test - fx_cl_iso_fp_ti_ro\n",
                    tv_fx_cl_iso_fp_ti_ro, xe135_flibefuel_index,
					u233_flibefuel_index);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Isotope fission product production: PASS\n\
  Variable family in test - fx_cl_iso_fp_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_nt_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Isotope transmutation product production: FAIL:\n\
  H-3 in material FLiBeFuel has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have a value greater than 0 from the\n\
  transmutation of Li-6 in FLiBeFuel\n\
  Variable family in test - fx_cl_iso_nt_ti_ro\n",
                    tv_fx_cl_iso_nt_ti_ro, h3_flibefuel_index,
					li6_flibefuel_index);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Isotope transmutation product production: PASS\n\
  Variable family in test - fx_cl_iso_nt_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type destination side stream row: FAIL:\n\
  F-19 in material Uranium233 has given Fluorine continuous group type feed\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sd_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_sd_ro, fluorine_uranium233_redox_stream_index,
					f19_uranium233_index, pv_fx_cl_iso_ts_cs_gt_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type destination side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_cs_gt_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to continuous group type source side stream row: FAIL:\n\
  F-19 in material Fluorine0 has given Fluorine continuous group type feed\n\
  stream a value of %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_ss_ro\n",
                    tv_fx_cl_iso_ts_cs_gt_ss_ro, fluorine_fluorine0_redox_stream_index,
					f19_fluorine0_index, pv_fx_cl_iso_ts_cs_gt_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to continuous group type source side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_cs_gt_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_rt_sd_co == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table destination side stream column: FAIL:\n\
  Li-7 in material Argon40 has value of %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E in the\n\
  column corresponding to the reproc removal table feed stream in Argon40.\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_sd_co\n",
                    tv_fx_cl_iso_ts_ps_rt_sd_co, li7_argon40_index,
					reproc_argon40_remv_stream_index, pv_fx_cl_iso_ts_ps_rt_sd_co);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table destination side stream column: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_sd_co\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_rt_sd_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table destination side stream row: FAIL:\n\
  reproc proportional removal table feed stream in material Argon40 has value\n\
  of %1.15E at matrix location [ %ld , %ld ] but should have value\n\
  of %1.15E in the column corresponding to Li-7 in Argon40.\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_sd_ro\n",
                    tv_fx_cl_iso_ts_ps_rt_sd_ro, reproc_argon40_remv_stream_index,
					li7_argon40_index, pv_fx_cl_iso_ts_ps_rt_sd_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table destination side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_sd_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_rt_ss_co == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table source side stream column: FAIL:\n\
  Li-7 in material FLiBeFuel has value of %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E in the\n\
  column corresponding to the reproc removal table remv stream in FLiBeFuel.\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_ss_co\n",
                    tv_fx_cl_iso_ts_ps_rt_ss_co, li7_flibefuel_index,
					reproc_flibefuel_remv_stream_index, pv_fx_cl_iso_ts_ps_rt_ss_co);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table source side stream column: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_ss_co\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_iso_ts_ps_rt_ss_ro == 0)
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table source side stream row: FAIL:\n\
  reproc proportional removal table feed stream in material Argon40 has value\n\
  of %1.15E at matrix location [ %ld , %ld ] but should have value\n\
  of %1.15E in the column corresponding to Li-7 in Argon40.\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_ss_ro\n",
                    tv_fx_cl_iso_ts_ps_rt_ss_ro, reproc_flibefuel_remv_stream_index,
					li7_flibefuel_index, pv_fx_cl_iso_ts_ps_rt_ss_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Iso to proportional removal table source side stream row: PASS\n\
  Variable family in test - fx_cl_iso_ts_ps_rt_ss_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_ps_rt_sd_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Proportional removal table destination stream to iso row: FAIL:\n\
  Isotope He-4 in material Argon40 has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from proportional removal table feed stream reproc in material Argon40.\n\
  Variable family in test - fx_cl_ps_rt_sd_ti_ro\n",
                    tv_fx_cl_ps_rt_sd_ti_ro, he4_argon40_index,
					he4_flibefuel_index, pv_fx_cl_ps_rt_sd_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Proportional removal table destination stream to iso row: PASS\n\
  Variable family in test - fx_cl_ps_rt_sd_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_ps_rt_ss_ti_ro == 0)
        {

            sprintf(print_data, "\nTest: Proportional removal table source stream to iso row: FAIL:\n\
  Isotope He-4 in material FLiBeFuel has value %1.15E at matrix\n\
  location [ %ld , %ld ] but should have value of %1.15E\n\
  from proportional removal table removal stream reproc in material FLiBeFuel.\n\
  Variable family in test - fx_cl_ps_rt_ss_ti_ro\n",
                    tv_fx_cl_ps_rt_ss_ti_ro, he4_flibefuel_index,
					he4_flibefuel_index, pv_fx_cl_ps_rt_ss_ti_ro);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Proportional removal table source stream to iso row: PASS\n\
  Variable family in test - fx_cl_ps_rt_ss_ti_ro\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(bl_fx_cl_ps_rt_ts == 0)
        {

            sprintf(print_data, "\nTest: Proportional removal table stream self value: FAIL:\n\
  Proportional removal table stream reproc in material FLiBeFuel\n\
  has value %1.15E at matrix location [ %ld , %ld ] but\n\
  should have value of %1.15E\n\
  Variable family in test - fx_cl_ps_rt_ts\n",
                    tv_fx_cl_ps_rt_ts, reproc_flibefuel_remv_stream_index,
					reproc_flibefuel_remv_stream_index, pv_fx_cl_ps_rt_ts);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Proportional removal table stream self value: PASS\n\
  Variable family in test - fx_cl_ps_rt_ts\n");

            PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermapdensityvector.c                     */
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests 5 things: 1) That the composition vector is given the  */
/*              correct isotopic densities in the "send" mode. 2) That the   */
/*              material receives the correct isotopic density from the      */
/*              composition vector in "receive" mode. 3) That a continuous   */
/*              ( cont ) stream sends the proper amount                      */
/*              into the composition vector. 4) That a prop type stream      */
/*              receives the correct amount in receive mode.                 */
/*              mode. 5) that 3 happens for sum streams                      */
/*                                                                           */
/* Comments:This function is called from ADERBurnMaterials                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMapDensityVector:"

void TESTADERMapDensityVector()
{

    char *const test_name = "ADERMapDensityVector";
    char status[5];
    char print_data[256];
    char *mat_name;
    double percent_diff_cont_rem_table_send;
    double percent_diff_li7_receive, percent_diff_li7_send;
    double percent_diff_prop_receive, percent_diff_stream_send;
    double percent_diff_stream_sum_send;
    double test_value_prop_receive = 0.0;
    double target_value_cont_rem_table_send;
    double target_value_li7_receive, target_value_li7_send;
    double target_value_prop_receive, target_value_stream_send;
    double target_value_stream_sum_send, total_time;
    double value_cont_rem_table_send, value_li7_receive;
    double value_li7_send, value_stream_send, value_stream_sum_send;
    int append = 0;
    int boolean = 0;
    int boolean_cont_rem_table_send = 0;
    int boolean_li7_receive = 0, boolean_li7_send = 0;
    int boolean_prop_receive = 0, boolean_stream_send = 0;
    int boolean_stream_sum_send = 0;
	double **ader_burn_matrix_size_data;
	double *ader_burn_matrix_N0, *ader_burn_matrix_N_EOS;
	double *ader_burn_matrix_num_rows, *ader_burn_matrix_starts;
	double *initial_state_storage;
    long ader_data;
    long ader_test_block, ader_mat_stream, ader_mat_stream_burn_step;
    long ader_mat_stream_cont_rem, ader_mat_stream_prop;
    long ader_mat_stream_shadow, ader_mat_stream_src_mat;
    long ader_mat_stream_src_mat_ader_data;
    long  ader_mat_stream_sum, ader_mat_stream_sum_ent, cont_stream;
    long cont_stream_sum, mat, mat_ader_data, mat_iso, nuc;
    long li7_index = 0;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMapDensityVector.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the total burn time                                                */

    total_time = RDB[DATA_BURN_TIME_INTERVAL];

    /* Get the first test mat */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Get the burn matrix size data                                          */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_N_EOS = ader_burn_matrix_size_data[4];

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	/* Create a storage vector to save the current state of the material      */
	/* atomic densities and stream values which will be returned to the       */
	/* material at the end of the test                                        */

	initial_state_storage = calloc(*ader_burn_matrix_num_rows, sizeof(double));

	/* Assuming that the map function works, go ahead and graba that data     */

    ADERMapDensityVector(initial_state_storage, ader_burn_matrix_starts, 0, 0,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

	/* Get the Li-7 isotope in FLiBeFuel and store its value for testing      */

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has isotopes but is missing Li-7.\n");

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

    		target_value_li7_send = RDB[mat_iso + COMPOSITION_ADENS];

    		break;

    	}

    	li7_index++;

    	mat_iso = NextItem(mat_iso);

    }

    /* Set the "CUR_AMT" for the Fluorine stream in the Fluorine material     */
    /* which can be accesed from the FLiBeFuel stream                         */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Fluorine redox stream.\n");

        if(strncmp("Fluorine", GetText(ader_mat_stream + ADER_MAT_STREAM_ID), 8) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no ActF2 removal stream.\n");

            cont_stream = ader_mat_stream;

            ader_mat_stream_shadow = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

            /* REMEMBER ADERMapDensityVector uses pre-step adens              */

            ader_mat_stream_src_mat_ader_data = (long)RDB[ader_mat_stream_src_mat + MATERIAL_ADER_DATA];

            target_value_stream_send = 0.3 * RDB[ader_mat_stream_src_mat_ader_data + ADER_MAT_PRE_STEP_ADENS] / total_time;

            WDB[ader_mat_stream_shadow + ADER_MAT_STREAM_CUR_AMT] = 0.3;

            break;
        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Set the "CUR_AMT" for the Uranium2 sum stream in the ActF2 stream in   */
    /* FLiBeFuel, also grab the rem type prop form stream reproc              */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no ActF2 or reproc remv stream.\n");

        if(strcmp("reproc", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

        	ader_mat_stream_prop = ader_mat_stream;

            sprintf(print_data, "FLiBeFuel has no ActF2 stream.\n");

        }

        if(strcmp("ActF2", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ActF2 remv stream but no sum streams.\n");

            ader_mat_stream_sum_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_stream_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel ActF2 remv stream has sum streams but no Uranium2.\n");

                if(strcmp("Uranium2", GetText(ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                	ader_mat_stream_sum = (long)RDB[ader_mat_stream_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                	cont_stream_sum = ader_mat_stream_sum;

                	target_value_stream_sum_send = 0.5 * RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS] / total_time;

                	WDB[ader_mat_stream_sum + ADER_MAT_STREAM_CUR_AMT] = 0.5;

                    break;

                }

                ader_mat_stream_sum_ent = NextItem(ader_mat_stream_sum_ent);

            }

            break;
        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Now call the map function in the send mode                             */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

    /* Test the N0 received the correct Li7 value                             */

    value_li7_send = ader_burn_matrix_N0[li7_index];

    percent_diff_li7_send = (value_li7_send -
    		                 target_value_li7_send) / target_value_li7_send;

    if(fabs(percent_diff_li7_send) < 0.0001)
    {

    	boolean_li7_send = 1;

    }

    /* Test to see if the  stream sent the correct amount                     */

    value_stream_send = ader_burn_matrix_N0[(long)RDB[cont_stream + ADER_MAT_STREAM_BURN_INDEX]];

    percent_diff_stream_send = (value_stream_send -
    		                    target_value_stream_send) / target_value_stream_send;

    if(fabs(percent_diff_stream_send) < 0.001)
    {

    	boolean_stream_send = 1;

    }

    /* Now test to see if the sum stream sent the correct amount              */

    value_stream_sum_send = ader_burn_matrix_N0[(long)RDB[cont_stream_sum + ADER_MAT_STREAM_BURN_INDEX]];

    percent_diff_stream_sum_send = (value_stream_sum_send -
    		                    target_value_stream_sum_send) / target_value_stream_sum_send;

    if(fabs(percent_diff_stream_sum_send) < 0.001)
    {

    	boolean_stream_sum_send = 1;

    }


    /* Assign a value in the burn vector for Li-7 and the prop stream         */

    target_value_prop_receive = 0.7;

    target_value_li7_receive = 0.17;

    ader_burn_matrix_N_EOS[(long)RDB[ader_mat_stream_prop + ADER_MAT_STREAM_BURN_INDEX]] = 0.7;

    ader_burn_matrix_N_EOS[li7_index] = target_value_li7_receive;

    /* Now call the map function in the receive mode                          */

    ADERMapDensityVector(ader_burn_matrix_N_EOS, ader_burn_matrix_starts, 0, 1,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

    /*Now, check that the prop stream received the correct amount             */
    /* We will need to retrieve its burn step value to do so                  */

    ader_mat_stream_burn_step = (long)RDB[ader_mat_stream_prop + ADER_MAT_STREAM_BURN_STEPS_PTR];

    test_value_prop_receive = RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];

    percent_diff_prop_receive = (test_value_prop_receive -
    		                     target_value_prop_receive) /
    		                     target_value_prop_receive;

    if(fabs(percent_diff_prop_receive) < 0.0001)
    {

    	boolean_prop_receive = 1;

    }

    /* Now, cycle through to Li-7 in FLiBeFuel and check its value. Also,     */
    /* reset the old value                                                    */

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has isotopes but is missing Li-7.\n");

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

            sprintf(print_data, "This test failed. See details below.\n");

            value_li7_receive = RDB[mat_iso + COMPOSITION_ADENS];

            percent_diff_li7_receive = (value_li7_receive -
            		                   target_value_li7_receive) /
            		                  target_value_li7_receive;

            WDB[mat_iso + COMPOSITION_ADENS] = target_value_li7_send;

    		break;

    	}

    	mat_iso = NextItem(mat_iso);

    }

    if(fabs(percent_diff_li7_receive) < 0.0001)
    {

    	boolean_li7_receive = 1;

    }

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

	/* reset the mat's data                                                   */

    ADERMapDensityVector(initial_state_storage, ader_burn_matrix_starts, 0, 1,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

	/* Now, repeat the send procedure for the Lithium7 material cluster so    */
	/* that we an test a continuous removal based table                       */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strcmp("Lithium7", mat_name) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

	/* Get the burn matrix size data                                          */

	ader_burn_matrix_size_data = ADERGetBurnMatrixSizeData(mat);

	/* Parse that data out                                                    */

	ader_burn_matrix_starts = ader_burn_matrix_size_data[2];

	ader_burn_matrix_N0 = ader_burn_matrix_size_data[3];

	ader_burn_matrix_N_EOS = ader_burn_matrix_size_data[4];

	ader_burn_matrix_num_rows = ader_burn_matrix_size_data[0];

	/* Get the rLi7 removal stream                                            */

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Lithium7 has no rLi7 remv stream.\n");

        if(strcmp("rLi7", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

        	ader_mat_stream_cont_rem = ader_mat_stream;

            sprintf(print_data, "FLiBeFuel has no ActF2 stream.\n");

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    target_value_cont_rem_table_send = 0.1;

    /* Now call the map function in the send mode                            */

    ADERMapDensityVector(ader_burn_matrix_N0, ader_burn_matrix_starts, 0, 0,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

    /* Now test that the value was sent                                       */

    value_cont_rem_table_send = ader_burn_matrix_N0[(long)RDB[ader_mat_stream_cont_rem + ADER_MAT_STREAM_BURN_INDEX]];

	/* Deallocate the burn matrix size data                                   */

	ADERDeallocateTarget(ader_burn_matrix_size_data, 5);

	percent_diff_cont_rem_table_send = (value_cont_rem_table_send - target_value_cont_rem_table_send) /
			                           target_value_cont_rem_table_send;

    if(fabs(percent_diff_cont_rem_table_send) < 0.001)
    {

    	boolean_cont_rem_table_send = 1;

    }

    if(boolean_li7_receive == 1 &&
       boolean_li7_send == 1 &&
	   boolean_prop_receive == 1 &&
	   boolean_stream_send == 1 &&
	   boolean_stream_sum_send == 1 &&
	   boolean_cont_rem_table_send == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_li7_receive == 0)
        {

            sprintf(print_data, "Test: Isotope fraction send: FAIL:\n \
Li-7 isotope in FLiBeFuel has value %f but N0 vector, at index %ld has \n\
value %f.\n", target_value_li7_send, li7_index, value_li7_send);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Isotope fraction send: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_li7_send == 0)
        {

            sprintf(print_data, "Test: Isotope fraction receive: FAIL:\n \
Li-7 isotope in FLiBeFuel received value %f but needed value %f.\n",
                    value_li7_receive, target_value_li7_receive);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Isotope fraction receive: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_prop_receive == 0)
        {

            sprintf(print_data, "Test: Prop stream receive: FAIL:\n \
Removal stream reproc in FLiBeFuel received value %f but needed value %f.\n",
                   test_value_prop_receive,
				   target_value_prop_receive);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Prop stream receive: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream_send == 0)
        {

            sprintf(print_data, "Test: Cont stream send: FAIL:\n \
Redox stream Fluorine in Fluorine0 sent value\n\
%1.16E but N0 vector has value\n\
%1.16E.\n",
                   target_value_stream_send, value_stream_send);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Cont stream send: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream_sum_send == 0)
        {

            sprintf(print_data, "Test: Cont sum stream send: FAIL:\n \
Removal sum stream Uranium2 in stream ActF2 in FLiBeFuel sent value\n\
%1.16E but N0 vector has value\n\
%1.16E.\n",
                   target_value_stream_sum_send, value_stream_sum_send);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Cont sum stream send: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_cont_rem_table_send == 0)
        {

            sprintf(print_data, "Test: Continuous removal table value send: FAIL:\n \
rLi7 stream in material Lithium7 sent value %1.8E to the burn vector\n\
at index %ld but should have sent %1.8E.\n", value_cont_rem_table_send,
                    (long)RDB[ader_mat_stream_cont_rem + ADER_MAT_STREAM_BURN_INDEX],
					target_value_cont_rem_table_send);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Continuous removal table value send: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

    /* Now reset the material's state                                         */

    ADERMapDensityVector(initial_state_storage, ader_burn_matrix_starts, 0, 1,
    		             mat, 1, RDB[DATA_BURN_TIME_INTERVAL]);

    /* Now free the storage vector                                            */

    free(initial_state_storage);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatelebalbounds.c                      */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the elemental row bounds are properly  */
/*              adjusted to account for removal and material abundance in the*/
/*              ele bal row                                                  */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatEleBalBounds:"

void TESTADERMatEleBalBounds(long step)
{

    char *const test_name = "ADERMatEleBalBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double argon40_adens, flibefuel_adens, percent_lower_diff;
    double percent_upper_diff, target_lower_value, target_upper_value;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data, mat_ader_ele;
    long mat_ader_ele_row, mat_matrix_data, mat_matrix_row_bound;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatEleBalBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    argon40_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ader_ele > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has ader elements but no Li.\n");

        if((long)RDB[mat_ader_ele + ADER_MAT_ELE_Z] == 3)
        {

            sprintf(print_data, "Material FLiBeFuel not found.\n");

            mat_ader_ele_row = (long)RDB[mat_ader_ele + ADER_MAT_ELE_BAL_ROW_ID];

            break;

        }

        mat_ader_ele = NextItem(mat_ader_ele);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no matrix bounds.\n");

            break;

        }

        mat = NextItem(mat);

    }

    flibefuel_adens = RDB[mat + MATERIAL_ADENS];

    /* The 2.0 is for volume effects                                          */

    target_lower_value = 0.00121949 * (flibefuel_adens / argon40_adens) * 2.0;

    target_upper_value = 0.00121949 * (flibefuel_adens / argon40_adens) * 2.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < mat_ader_ele_row; i++)
    {

        mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

    }

    sprintf(print_data, "Material FLiBeFuel has matrix row %ld should have bounds \n \
of %f but has lower bound of %f and upper bound of %f.\n",
            mat_ader_ele_row, target_lower_value,
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

    percent_lower_diff = (RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] -
    		              target_lower_value ) / target_lower_value;

    percent_upper_diff = (RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] -
                           target_upper_value ) / target_upper_value;

    if(fabs(percent_lower_diff) < 0.00001 && fabs(percent_upper_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatelefutbounds.c                      */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the elemental row bounds are properly  */
/*              set                                                          */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatEleFutBounds:"

void TESTADERMatEleFutBounds(long step)
{

    char *const test_name = "ADERMatEleFutBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0, boolean_ele_controlled = 0, boolean_ele_uncontrolled = 0;
    long ader_data, ader_test_block, controlled_ele_row, controlled_row_bound;
    long i, mat, mat_ader_data;
    long mat_ader_ele, mat_matrix_data;
    long uncontrolled_ele_row, uncontrolled_row_bound;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatEleFutBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ader_ele > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has ader elements but no Li.\n");

        if((long)RDB[mat_ader_ele + ADER_MAT_ELE_Z] == 3)
        {

            sprintf(print_data, "Material FLiBeFuel not found. \n");

            uncontrolled_ele_row = (long)RDB[mat_ader_ele + ADER_MAT_ELE_FUT_ROW_ID];

            break;

        }

        mat_ader_ele = NextItem(mat_ader_ele);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ader_ele > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader elements but no Li.\n");

        if((long)RDB[mat_ader_ele + ADER_MAT_ELE_Z] == 3)
        {

            sprintf(print_data, "Material FLiBeFuel has no matrix row bounds.\n");

            controlled_ele_row = (long)RDB[mat_ader_ele + ADER_MAT_ELE_FUT_ROW_ID];

            break;

        }

        mat_ader_ele = NextItem(mat_ader_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    controlled_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < controlled_ele_row; i++)
    {

    	controlled_row_bound = NextItem(controlled_row_bound);

    }

    if((RDB[controlled_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] == 0.0) &&
       (RDB[controlled_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0))
    {

        boolean_ele_controlled = 1;

    }

    uncontrolled_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < uncontrolled_ele_row; i++)
    {

    	uncontrolled_row_bound = NextItem(uncontrolled_row_bound);

    }


    if((RDB[uncontrolled_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] < -1E17) &&
       (RDB[uncontrolled_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0))
    {

        boolean_ele_uncontrolled = 1;

    }

    if(boolean_ele_controlled == 1 &&
       boolean_ele_uncontrolled == 1)
    {

    	boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_ele_controlled == 0)
        {

            sprintf(print_data, "\nTest: Controlled Element Future Row Bounds: FAIL:\n\
Material FLiBeFuel has matrix row %ld should\n\
have lower bound of %f and upper bound of %f\n\
but has lower bound of %f and upper bound of %f.\n",
                    controlled_ele_row, 0.0, 0.0,
                    RDB[controlled_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
                    RDB[controlled_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Controlled Element Future Row Bounds: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_ele_uncontrolled == 0)
        {

            sprintf(print_data, "\nTest: Uncontrolled Element Future Row Bounds: FAIL:\n\
Material FLiBeFuel has matrix row %ld should\n\
have lower bound of %f and upper bound of %f\n\
but has lower bound of %f and upper bound of %f.\n",
                    uncontrolled_ele_row, -1E+18, 0.0,
                    RDB[uncontrolled_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
                    RDB[uncontrolled_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Uncontrolled Element Future Row Bounds: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatelefutcolbounds.c                   */
/*                                                                           */
/* Created:       2017/11/29 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure the elemental column bounds are properly    */
/*              adjusted to account for removal in the ele fut column.       */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatEleFutColBounds:"

void TESTADERMatEleFutColBounds(long step)
{

    char *const test_name = "ADERMatEleFutColBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double argon40_adens = 0.0, flibefuel_adens = 0.0;
    double expected_removal_amount = 0.001219;
    double expected_value_lower = 0.0, expected_value_upper = 1E+18;
    double percent_diff_lower = 0.0, percent_diff_upper = 0.0;
    double test_value_lower = 0.0, test_value_upper = 0.0;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block;
    long i, mat, mat_ader_data;
    long mat_ader_ele, mat_matrix_column, mat_matrix_data;
    long ele_col;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatEleFutColBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    argon40_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ader_ele > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has ader elements but no Li.\n");

        if((long)RDB[mat_ader_ele + ADER_MAT_ELE_Z] == 3)
        {

            sprintf(print_data, "Material FLiBeFuel not found. \n");

            ele_col = (long)RDB[mat_ader_ele + ADER_MAT_ELE_FUT_COL_ID];

            break;

        }

        mat_ader_ele = NextItem(mat_ader_ele);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    flibefuel_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_column = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ele_col; i++)
    {

    	mat_matrix_column = NextItem(mat_matrix_column);

    }

    /* The expected change in the column bounds must be adjusted for removal  */
    /* with density effects factored in                                       */

    expected_removal_amount = expected_removal_amount * (flibefuel_adens /
    		                                             argon40_adens);

    expected_value_lower = expected_value_lower - expected_removal_amount;

    expected_value_upper = expected_value_upper - expected_removal_amount;

    percent_diff_lower = (RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] - expected_value_lower)/
    		             expected_value_lower;

    percent_diff_upper = (RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] - expected_value_upper)/
    		             expected_value_upper;

    sprintf(print_data, "Element lithium in material Argon40 has bad future column bounds of\n\
%.8E and %.8E and should have bounds of .8E and .8E.\n",
            RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND],
			RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND],
			expected_value_lower, expected_value_upper);

    if((fabs(percent_diff_lower) <= 0.001) &&
       (fabs(percent_diff_upper) <= 0.001))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));


    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermateleisobounds.c                      */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the elemental row bounds are properly  */
/*              set                                                          */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatEleIsoBounds:"

void TESTADERMatEleIsoBounds()
{

    char *const test_name = "ADERMatEleIsoBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, ele_iso_row, ele_iso_row_bound;
    long i, mat, mat_ader_data;
    long mat_ader_ele, mat_matrix_data;


    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMatEleIsoBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader elements.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ader_ele > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader elements but no Li.\n");

        if((long)RDB[mat_ader_ele + ADER_MAT_ELE_Z] == 3)
        {

            sprintf(print_data, "Material FLiBeFuel has no matrix row bounds.\n");

            ele_iso_row = (long)RDB[mat_ader_ele + ADER_MAT_ELE_ISO_ROW_ID];

            break;

        }

        mat_ader_ele = NextItem(mat_ader_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ele_iso_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < ele_iso_row; i++)
    {

    	ele_iso_row_bound = NextItem(ele_iso_row_bound);

    }

    if((RDB[ele_iso_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] == 0.0) &&
       (RDB[ele_iso_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if(boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

		sprintf(print_data, "\nTest: Elememt Isotope Balance Row Bounds: FAIL:\n\
Material FLiBeFuel has matrix row %ld should\n\
have lower bound of %f and upper bound of %f\n\
but has lower bound of %f and upper bound of %f.\n",
				ele_iso_row, 0.0, 0.0,
				RDB[ele_iso_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
				RDB[ele_iso_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

		PrintTest(test_name, status, print_data, append);

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisoabsmicxsbos.c                    */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes micro absorption cross               */
/*              section is calculated correctly                              */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoAbsMicXsBos:"

void TESTADERMatIsoAbsMicXsBos(long step)
{

    char *const test_name = "ADERMatIsoAbsMicXsBos";
    char status[5];
    char print_data[256];
    char *mat_name;
    double percent_diff;
    double total_abs_xs = 0.0;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, id, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc, rea;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoAbsMicXsBos.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get OMP_ID, this will only work on non OMP runs...I think              */

    id = OMP_THREAD_NUM;

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Calculate transmutation cross sections */

    CalculateTransmuXS(mat, OMP_THREAD_NUM);

    /* Store the xs from above */

    StoreTransmuXS(mat, step, 3, OMP_THREAD_NUM, 0);

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

        	/* Get the total abs xs as calcuated by SERPENT                   */

        	rea = (long)RDB[nuc + NUCLIDE_PTR_REA];

        	while(rea > VALID_PTR)
        	{

        		/* This establishes that the reaction is not fission and is   */
        		/* not decay                                                  */

        		if((long)RDB[rea + REACTION_PTR_TRANSMUXS] > VALID_PTR)
        		{

        			total_abs_xs += TestValuePair(rea + REACTION_PTR_TRANSMUXS,
        					                      mat, id);
        		}

        		rea = NextItem(rea);

        	}

        	percent_diff = ((RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS] -
        			         total_abs_xs) / total_abs_xs) * 100.0;

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_ABS_MIC_XS_BOS has bad value of %f.\n \
Has percent difference with possible SERPENT XS of: %f \n \
Needs value of UNKNOWN.\n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
					percent_diff);

            if(fabs(percent_diff) < 0.001)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisoabsmicxseosinit.c                */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes miscro fission x nu_bar cross section */
/*              for the end of step is properly initiated to -INFTY at       */
/*              first step                                                   */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoAbsMicXsEosInit:"

void TESTADERMatIsoAbsMicXsEosInit(long step)
{

    char *const test_name = "ADERMatIsoAbsMicXsEosInit";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoAbsMicXsEosInit.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_ABS_MIC_XS_EOS has bad value of %f. Needs value of -INFTY.\n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS]);

            if(RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS] < -1E-36)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisoabsmicxsps1init.c                */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes miscro fission x nu_bar cross section */
/*              for the 'previous' step is properly initiated to -INFTY at   */
/*              first step                                                   */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoAbsMicXsPs1Init:"

void TESTADERMatIsoAbsMicXsPs1Init(long step)
{

    char *const test_name = "ADERMatIsoAbsMicXsPs1Init";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoAbsMicXsPs1Init.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_ABS_MIC_XS_PS1 has bad value of %f. Needs value of -INFTY.\n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1]);

            if(RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1] < -1E-36)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisobalbounds.c                      */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the isotopic row bounds are properly   */
/*              adjusted to account for removal and mateiral abundance in the*/
/*              isos bal row                                                 */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoBalBounds:"

void TESTADERMatIsoBalBounds(long step)
{

    char *const test_name = "ADERMatIsoBalBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data, mat_ader_iso;
    long mat_ader_iso_row, mat_iso, mat_matrix_data, mat_matrix_row_bound, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoBalBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel not has no matrix rows.\n");

            mat_ader_iso_row = (long)RDB[mat_ader_iso + ADER_MAT_ISO_BAL_ROW_ID];

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < mat_ader_iso_row; i++)
    {

        mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

    }

    sprintf(print_data, "Material FLiBeFuel has matrix row %ld should have bounds \n \
of 0.008503482 but has lower bound of %f and upper bound of %f.\n",
            mat_ader_iso_row,
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

    if((RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] > 0.000135 &&
        RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] < 0.000137) &&
       (RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] > 0.000135 &&
        RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] < 0.000137))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisofutbounds.c                      */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the isotopic row bounds are properly   */
/*              set                                                          */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoFutBounds:"

void TESTADERMatIsoFutBounds(long step)
{

    char *const test_name = "ADERMatIsoFutBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0, boolean_iso_controlled = 0, boolean_iso_uncontrolled = 0;
    long ader_data, ader_test_block, controlled_row_bounds, i;
    long iso_controlled_row, iso_uncontrolled_row, mat, mat_ader_data;
    long mat_ader_iso, mat_iso, mat_matrix_data, nuc;
    long uncontrolled_row_bounds;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoFutBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel not found.\n");

            iso_uncontrolled_row = (long)RDB[mat_ader_iso + ADER_MAT_ISO_FUT_ROW_ID];

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has bad matrix data.\n");

            iso_controlled_row = (long)RDB[mat_ader_iso + ADER_MAT_ISO_FUT_ROW_ID];

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    controlled_row_bounds = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < iso_controlled_row; i++)
    {

    	controlled_row_bounds = NextItem(controlled_row_bounds);

    }

    if((RDB[controlled_row_bounds + ADER_MAT_MATRIX_ROW_LOWER_BOUND] == 0.0) &&
       (RDB[controlled_row_bounds + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0))
    {

        boolean_iso_controlled = 1;

    }

    uncontrolled_row_bounds = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < iso_uncontrolled_row; i++)
    {

    	uncontrolled_row_bounds = NextItem(uncontrolled_row_bounds);

    }

    if((RDB[uncontrolled_row_bounds + ADER_MAT_MATRIX_ROW_LOWER_BOUND] < -1E+17) &&
       (RDB[uncontrolled_row_bounds + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0))
    {

        boolean_iso_uncontrolled = 1;

    }

    if(boolean_iso_controlled == 1 &&
       boolean_iso_uncontrolled == 1)
    {

    	boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_iso_controlled == 0)
        {

            sprintf(print_data, "\nTest: Controlled Isotope Future Row Bounds: FAIL:\n\
Material FLiBeFuel has matrix row %ld should have lower bound\n \
of %f and upper bound of %f but has lower bound of %f and upper bound of %f.\n",
                    iso_controlled_row, 0.0, 0.0,
                    RDB[controlled_row_bounds + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
                    RDB[controlled_row_bounds + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Controlled Isotope Future Row Bounds: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_iso_uncontrolled == 0)
        {

            sprintf(print_data, "\nTest: Uncontrolled Isotope Future Row Bounds: FAIL:\n\
Material FLiBeFuel has matrix row %ld should have lower bound\n \
of %f and upper bound of %f but has lower bound of %f and upper bound of %f.\n",
                    iso_uncontrolled_row, -1E+18, 0.0,
                    RDB[uncontrolled_row_bounds + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
                    RDB[uncontrolled_row_bounds + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

            PrintTest(test_name, status, print_data, 1);

        }
        else
        {

            sprintf(print_data, "\nTest: Uncontrolled Isotope Future Row Bounds: PASS\n");

            PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisofutcolbounds.c                   */
/*                                                                           */
/* Created:       2017/11/29 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the isotopic future column bounds are  */
/*              adjusted to account for removal in the isotope's future col  */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoFutColBounds:"

void TESTADERMatIsoFutColBounds(long step)
{

    char *const test_name = "ADERMatIsoFutColBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double expected_value_lower = 0.0;
    double expected_value_upper = 1E+18;
    double expected_removal_amount = 0.004183572012;
    double percent_diff_lower = 0.0, percent_diff_upper = 0.0;
    double test_value_lower = 0.0, test_value_upper = 0.0;
    double argon40_adens, flibefuel_adens;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, controlled_row_bounds, i;
    long iso_col, mat, mat_ader_data;
    long mat_ader_iso, mat_iso, mat_matrix_column, mat_matrix_data, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoFutColBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    argon40_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel not found.\n");

            iso_col = (long)RDB[mat_ader_iso + ADER_MAT_ISO_FUT_ROW_ID];

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    flibefuel_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* The expected values for the  isotope future column bounds must be      */
    /* adjusted for the density difference between the two materials          */

    expected_removal_amount = expected_removal_amount * (flibefuel_adens /
    		                                             argon40_adens);

    /* We add the expected removal amount because it is negative for the mat  */

    expected_value_lower = expected_value_lower - expected_removal_amount;

    expected_value_upper = expected_value_upper - expected_removal_amount;

    mat_matrix_column = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < iso_col; i++)
    {

    	mat_matrix_column = NextItem(mat_matrix_column);

    }

    percent_diff_lower = (RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND] -
    		             expected_value_lower) / expected_value_lower;

    percent_diff_upper = (RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND] -
    		             expected_value_upper) / expected_value_upper;

    sprintf(print_data, "Isotope U-233 in material Argon40 has bad future column bounds of\n\
%.8E and %.8E and should have bounds of .8E and .8E.\n",
            RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_LOWER_BOUND],
			RDB[mat_matrix_column + ADER_MAT_MATRIX_COL_UPPER_BOUND],
			expected_value_lower, expected_value_upper);

    if((fabs(percent_diff_lower) < 0.001) &&
       (fabs(percent_diff_upper) < 0.001))
    {

    	boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisonubarfismicxsbos.c               */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes miscro fission times nu_bar cross     */
/*              section is calculated correctly                              */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoNuBarFisMicXsBos:"

void TESTADERMatIsoNuBarFisMicXsBos(long step)
{

    char *const test_name = "ADERMatIsoNuBarFisMicXsBos";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoNuBarFisMicXsBos.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS has value of %1.16E. \n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS]);

            if(RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS] > 0.0 &&
               RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS] < 1E3)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisonubarfismicxseosinit.c           */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes miscro absorption cross section for   */
/*              the end of step is properly initiated to -INFTY at first     */
/*              step                                                         */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoNuBarFisMicXsEosInit:"

void TESTADERMatIsoNuBarFisMicXsEosInit(long step)
{

    char *const test_name = "ADERMatIsoNuBarFisMicXsEosInit";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoNuBarFisMicXsEosInit.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS has bad value of %f. Needs value of -INFTY.\n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS]);

            if(RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS] < -1E-36)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisonubarfismicxsps1init.c           */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes miscro absorption cross section for   */
/*              the 'previous' step is properly initiated to -INFTY at first */
/*              step                                                         */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoNuBarFisMicXsPs1Init:"

void TESTADERMatIsoNuBarFisMicXsPs1Init(long step)
{

    char *const test_name = "ADERMatIsoNuBarFisMicXsPs1Init";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, mat_ader_iso;
    long mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoNuBarFisMicXsPs1Init.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has U-233 but the \n \
ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1 has bad value of %f. Needs value of -INFTY.\n",
                    RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1]);

            if(RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1] < -1E-36)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatisorhorowentry.c                    */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that an isotopes reactivity control entry is correct   */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatIsoRhoRowEntry:"

void TESTADERMatIsoRhoRowEntry(long dep, long step)
{

    char *const test_name = "ADERMatIsoRhoRowEntry";
    char status[5];
    char print_data[256];
    char *mat_name;
    double bias = 0, percent_diff, test_value;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data, mat_ader_iso;
    long mat_ader_iso_fut_col, mat_iso, mat_matrix_data, mat_matrix_col;
    long mat_matrix_col_row, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatIsoRhoRowEntry.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    bias = ADERGetEigenBias(dep, mat, 0.0, RDB[DATA_BURN_TIME_INTERVAL]);

    mat_ader_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_ader_iso > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has ader isotopes but no U-233.\n");

        mat_iso = (long)RDB[mat_ader_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "Material FLiBeFuel has no matrix columns.\n");

            /* This test value should be equal to....                         */
            /* ( ( ( K_max /( ( 1 - p_l) * bias) ) * sigma_abs ) - ( nu_bar * sigma_fis ) ) */

            test_value = (((RDB[ader_data + ADER_K_MAX] /
                           ((1.0 - ADERAverageValue(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
                        		                    RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
								                    RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1],
                                                    0.0, RDB[DATA_BURN_TIME_INTERVAL], dep)) *
                             bias)) *
                            ADERAverageValue(RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_BOS],
                            		         RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_EOS],
									         RDB[mat_ader_iso + ADER_MAT_ISO_ABS_MIC_XS_PS1],
                                             0.0, RDB[DATA_BURN_TIME_INTERVAL], dep)) -
                          ADERAverageValue(RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_BOS],
                        		           RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_EOS],
								           RDB[mat_ader_iso + ADER_MAT_ISO_NUBAR_FIS_MIC_XS_PS1],
                                           0.0, RDB[DATA_BURN_TIME_INTERVAL], dep));

            mat_ader_iso_fut_col = (long)RDB[mat_ader_iso + ADER_MAT_ISO_FUT_COL_ID];

            break;

        }

        mat_ader_iso = NextItem(mat_ader_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for( i = 0; i < mat_ader_iso_fut_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID]; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    percent_diff = fabs((RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
                         test_value) / test_value);

    sprintf(print_data, "Material FLiBeFuel isotope U-233 has reactivity \n \
value %f in matrix element (%ld, %ld) but needs reactivity value %f.\n",
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
            mat_ader_iso_fut_col,
            (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID], test_value);

    if(percent_diff < 0.001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatmaxrhominrowbound.c                 */
/*                                                                           */
/* Created:       2018/02/03 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that the reactivity maximum row minimum bound is set   */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatMaxRhoMinRowBound:"

void TESTADERMatMaxRhoMinRowBound()
{

    char *const test_name = "ADERMatMaxRhoMinRowBound";
    char status[5];
    char print_data[256];
    char *mat_name;
    double percent_diff, test_value;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data, mat_ader_iso;
    long mat_ader_iso_fut_col, mat_iso, mat_matrix_data, mat_matrix_col;
    long mat_matrix_row_bound, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMatMaxRhoMinRowBound.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for( i = 0; i < (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID]; i++)
    {

    	mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

    }

    sprintf(print_data, "Material FLiBeFuel maximum reactivity row has lower \n \
bound of %.12f and should have a lower bound of 0.0.\n",
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND]);

    if(RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND] == 0.0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatminrhomaxrowbound.c                 */
/*                                                                           */
/* Created:       2018/02/03 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that the reactivity minimum row maximum bound has been */
/*              set properly                                                 */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatMinRhoMaxRowBound:"

void TESTADERMatMinRhoMaxRowBound()
{

    char *const test_name = "ADERMatMinRhoMaxRowBound";
    char status[5];
    char print_data[256];
    char *mat_name;
    double percent_diff, test_value;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data, mat_ader_iso;
    long mat_ader_iso_fut_col, mat_iso, mat_matrix_data, mat_matrix_col;
    long mat_matrix_row_bound, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    fprintf(outp, "Begin: TESTADERMatMinRhoMaxRowBound.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for( i = 0; i < (long)RDB[mat_ader_data + ADER_MAT_RHO_MIN_ROW_ID]; i++)
    {

    	mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

    }

    sprintf(print_data, "Material FLiBeFuel minimum reactivity row has upper \n \
bound of %.12f and should have an upper bound of 0.0.\n",
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

    if(RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND] == 0.0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatpresbounds.c                        */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the preservation mols row bounds are   */
/*              properly adjusted to account for removal                     */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatPresBounds:"

void TESTADERMatPresBounds(long step)
{

    char *const test_name = "ADERMatPresBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double expected_value_lower = -2.10536, expected_value_upper = -2.10536;
    double percent_diff_lower = 1.0, percent_diff_upper = 1.0;
    double test_value_lower = 0.0, test_value_upper = 0.0;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, i, mat, mat_ader_data;
    long mat_matrix_data, mat_matrix_row_bound, mat_pres;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatPresBounds.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no preservation entries.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_pres = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    while(mat_pres > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has no preservation mols entries.\n");

    	if(strcmp("mols", GetText(mat_pres + ADER_MAT_PRESERVE_ENT)) == 0)
    	{

    		break;

    	}

    	mat_pres = NextItem(mat_pres);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

    for(i = 0; i < (long)RDB[mat_pres + ADER_MAT_PRESERVE_ROW_ID]; i++)
    {

        mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

    }

    sprintf(print_data, "Material FLiBeFuel has matrix row %ld should have bounds \n \
of -2.10536 but has lower bound of %f and upper bound of %f.\n",
            (long)RDB[mat_pres + ADER_MAT_PRESERVE_ROW_ID],
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND],
            RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND]);

    test_value_lower = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

    test_value_upper = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

    percent_diff_lower = (test_value_lower - expected_value_lower) /
    		             expected_value_lower;

    percent_diff_upper = (test_value_upper - expected_value_upper) /
    		             expected_value_upper;

    if((fabs(percent_diff_lower) < 0.01) && fabs(percent_diff_upper) < 0.01)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatremveleamount.c                     */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the calculated amount of elemental     */
/*              removal is correct.                                          */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatRemvEleAmount:"

void TESTADERMatRemvEleAmount(long step)
{

    char *const test_name = "ADERMatRemvEleAmount";
    char status[5];
    char print_data[256];
    char *mat_name, *strm_id;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, strm, strm_ele;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatRemvEleAmount.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in FLiBeFuel has no elements.\n");

            strm_ele = (long)RDB[strm + ADER_MAT_STREAM_ELES_PTR];

            while(strm_ele > VALID_PTR)
            {

                sprintf(print_data, "'reproc' stream in FLiBeFuel has no Li.\n");

                if((long)RDB[strm_ele + ADER_MAT_GRP_ELE_Z] == 3)
                {

                    sprintf(print_data, "'reproc' stream in FLiBeFuel has Li but\n \
bad ele removal of %f and needs ele rate of 0.00121949 .\n", RDB[strm_ele + ADER_MAT_GRP_ELE_FRAC]);

                    if(RDB[strm_ele + ADER_MAT_GRP_ELE_FRAC] < 0.00121950 &&
                       RDB[strm_ele + ADER_MAT_GRP_ELE_FRAC] > 0.00121948)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_ele = NextItem(strm_ele);
            }

            break;
        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatremvisoamount.c                     */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that the calculated amount of isotopic      */
/*              removal is correct for all three scenarios                   */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatRemvIsoAmount:"

void TESTADERMatRemvIsoAmount(long step)
{

    char *const test_name = "ADERMatRemvIsoAmount";
    char status[5];
    char print_data[256];
    char *mat_name, *strm_id;
    double argon40_adens, f19_target_value, flibefuel_adens, fluorine1_adens;
    double lithium7_adens, percent_diff_cont, percent_diff_disc;
    double percent_diff_prop, test_value_cont, test_value_disc, test_value_prop;
    double u233_target_value;
    int append = 0;
    int boolean = 0, boolean_disc = 0, boolean_cont = 0, boolean_prop = 0;
    long ader_data, ader_test_block, mat, mat_ader_data, strm, strm_iso;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatRemvIsoAmount.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams. \n");

            break;

        }

        mat = NextItem(mat);
    }

    flibefuel_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc2", strm_id, 7) == 0)
        {

            sprintf(print_data, "'reproc2' stream in FLiBeFuel has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                sprintf(print_data, "'reproc2' stream in FLiBeFuel has no F-19.\n");

                if((long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI] == 90190)
                {

                    sprintf(print_data, "'reproc2' stream in FLiBeFuel has F-19 but\n \
material Fluorine1 not found.\n");

                    test_value_cont = RDB[strm_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

                    percent_diff_cont = (test_value_cont - (0.0000030229 * 864000)) / (0.0000030229 * 864000);

                    if(fabs(percent_diff_cont) < 0.001)
                    {

                        boolean_cont = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine1", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no streams. \n");

            break;

        }

        mat = NextItem(mat);
    }

    fluorine1_adens = RDB[mat + MATERIAL_ADENS];

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no streams. \n");

            break;

        }

        mat = NextItem(mat);
    }

    lithium7_adens = RDB[mat + MATERIAL_ADENS];

    /* The 0.5 is for the volume correction factor                            */

    f19_target_value = (fluorine1_adens / lithium7_adens) * 0.00001 * 864000 * 0.5;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc3", strm_id, 7) == 0)
        {

            sprintf(print_data, "'reproc3' stream in Lithium7 has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                sprintf(print_data, "'reproc3' stream in Lithium7 has no F-19.\n");

                if((long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI] == 90190)
                {

                    sprintf(print_data, "'reproc3' stream in Lithium7 has F-19 but\n \
material Argone40 not found.\n");

                    test_value_disc = RDB[strm_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

                    percent_diff_disc = (test_value_disc -
                    		        f19_target_value) / f19_target_value;

                    if(fabs(percent_diff_disc) < 0.001)
                    {

                        boolean_disc = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);

    }

    /* Get Argon40 */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    argon40_adens = RDB[mat + MATERIAL_ADENS];

    /* The 2.0 is for volume effects                                          */

    u233_target_value = 0.00418358 * (flibefuel_adens / argon40_adens) * 2.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in Argon40 has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                sprintf(print_data, "'reproc' stream in Argon40 has no U-233.\n");

                if((long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI] == 922330)
                {

                    sprintf(print_data, "'reproc' stream in Argon40 has U-233 but\n \
bad iso removal of %f and needs iso rate of %f.\n",
                            RDB[strm_iso + ADER_MAT_GRP_ISO_ELE_FRAC],
							u233_target_value);

                    test_value_prop = RDB[strm_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

                    percent_diff_prop = (test_value_prop -
                    		        u233_target_value) / u233_target_value;

                    if(fabs(percent_diff_prop) < 0.0001)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean_prop = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);

    }

    if(boolean_cont == 1 &&
       boolean_disc == 1 &&
	   boolean_prop == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_cont == 0)
        {

            sprintf(print_data, "Test: Continuous removal: FAIL:\n \
FLiBeFuel remv stream reproc2 F-19 isotope has bad removal amount %f but \n \
needs removal rate %f.\n", test_value_cont, 0.0000030229);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Continuous removal: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_disc == 0)
        {

            sprintf(print_data, "Test: Discreet removal: FAIL:\n \
Fluorine1 remv stream reproc3 F-19 isotope has bad removal amount %f but \n \
needs removal rate %f.\n", test_value_disc, f19_target_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Discreet removal: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_prop == 0)
        {

            sprintf(print_data, "Test: Proportional removal: FAIL:\n \
Argon40 remv stream reproc U-233 isotope has bad removal amount of %f but \n \
needs removal rate of %f.\n", test_value_prop, u233_target_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test:Proportional removal: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }


    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatsysleakagebos.c                     */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the value of the system leakage in the bos spot at init*/
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatSysLeakageBos:"

void TESTADERMatSysLeakageBos(long step)
{

    char *const test_name = "ADERMatSysLeakageBos";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatSysLeakageBos.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS] > 0.0)
    {

        boolean = 1;

        sprintf(print_data, "Material FLiBeFuel has BOS leakage of %f.\n \
K-imp-inf: %f \n K-imp-eff: %f \n K-imp-leakage: %f \n \
RES_TOT_NEUTRON_LEAKRATE: %f \n NEUT_FLUX: %f \n",
                RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_BOS],
                RDB[RES_IMP_KINF], RDB[RES_IMP_KEFF],
                (1.0 - RDB[RES_IMP_KEFF] / RDB[RES_IMP_KINF]),
                RDB[RES_TOT_NEUTRON_LEAKRATE],
				RDB[RES_TOT_NEUTRON_FLUX]);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatsysleakageeos.c                     */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the value of the system leakage in the eos spot at init*/
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatSysLeakageEos:"

void TESTADERMatSysLeakageEos(long step)
{

    char *const test_name = "ADERMatSysLeakageEos";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatSysLeakageEos.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS] < -1E+35)
    {

        boolean = 1;

        sprintf(print_data, "Material FLiBeFuel has EOS leakage of %f.\n \
K-imp-inf: %f \n K-imp-eff: %f \n K-imp-leakage: %f \n",
                RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_EOS],
                RDB[RES_IMP_KINF], RDB[RES_IMP_KEFF],
                (1.0 - RDB[RES_IMP_KEFF] / RDB[RES_IMP_KINF]));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermatsysleakageps1init.c                 */
/*                                                                           */
/* Created:       2016/04/16 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the value of the system leakage in the ps1 spot at init*/
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERMatSysLeakagePs1Init:"

void TESTADERMatSysLeakagePs1Init(long step)
{

    char *const test_name = "ADERMatSysLeakagePs1Init";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERMatSysLeakagePs1Init.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no ader data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    if(RDB[mat_ader_data + ADER_MAT_SYS_LEAKAGE_PS1] < -1E+35)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadermodifyclpsolution.c                    */
/*                                                                           */
/* Created:       2016/04/28 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Overwrites Clp solution vector for testing                   */
/*                                                                           */
/* Comments:This function is called from ADERSolveClpModel                   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTAderModifyClpSolution"

void TESTAderModifyClpSolution(double* clp_solution, long num_cols)
{

	long i;

	for(i = 0; i < num_cols; i++)
	{

		clp_solution[i] = 0.0;

	}

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadernormalizematerialstreamdensity.c       */
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that destination stream fractions are normalized to the*/
/*              MATERIAL_ADENS of the material for the source (shadow) stream*/
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERNormalizeMaterialStreamDensity:"

void TESTADERNormalizeMaterialStreamDensity(long step)
{

    char *const test_name = "ADERNormalizeMaterialStreamDensity";
    char status[5];
    char print_data[256];
    char *mat_name;
    double argon40_adens, ele_value, iso_value, percent_diff_ele_value;
    double percent_diff_iso_value, target_iso_value, target_ele_value;
    int i;
    int append = 0;
    int boolean = 0, boolean_ele = 0, boolean_iso = 0;
    long ader_data;
    long ader_mat_ele, ader_mat_ele_row, ader_mat_iso, ader_mat_iso_row;
    long ader_mat_matrix_col;
    long ader_mat_matrix_col_row, ader_mat_matrix_data, ader_mat_stream;
    long ader_mat_stream_col_id, ader_mat_sum_stream;
    long ader_mat_sum_stream_ent, ader_test_block, argon40, mat, mat_iso;
    long mat_ader_data, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERNormalizeMaterialStreamDensity.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    argon40 = mat;

    argon40_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has feed streams but no ActF stream.\n");

        if(strcmp("ActF", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Argon40 has feed stream ActF but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material Argon40 feed stream ActF has sum streams but no Uranium sum stream.\n");

                if(strcmp("Uranium", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material Argon40 has no elements. \n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    ader_mat_stream_col_id = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_COL_ID];

                	break;

                }

            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);
            }

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	sprintf(print_data, "Material Argon40 has elements but no U. \n");

        if((long)RDB[ader_mat_ele + ADER_MAT_ELE_Z] == 92)
        {

        	sprintf(print_data, "Material Argon40 has U but no isotopes. \n");

            ader_mat_ele_row = (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID];

            break;

        }

        ader_mat_ele = NextItem(ader_mat_ele);

    }

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Argon40 has isotopes but no U-233. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

        	sprintf(print_data, "Material Argon40 has U-233 but material FLiBeFuel does not exist. \n");

            ader_mat_iso_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Get FLiBeFuel where the matrix lives                                   */

    mat = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ader_mat_stream_col_id; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_ele_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    /* The 2.0 is for a volume correction factor                              */

    target_ele_value = 1.0 * (RDB[mat + MATERIAL_ADENS] / argon40_adens) * 2.0;

    ele_value = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_ele_value = (RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		                target_ele_value) / target_ele_value;

    if(fabs(percent_diff_ele_value) < 0.00001)
    {

        boolean_ele = 1;

    }

    /* Now check the isotope                                                  */

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_iso_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    /* The 2.0 is for a volume correction factor                              */

    target_iso_value = 1.0 * (RDB[mat + MATERIAL_ADENS] / argon40_adens) * 2.0;

    iso_value = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_iso_value = (RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		                  target_iso_value) / target_iso_value;

    if(fabs(percent_diff_iso_value) < 0.00001)
    {

        boolean_iso = 1;

    }


    if(boolean_ele == 1 &&
       boolean_iso == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_ele == 0)
        {

            sprintf(print_data, "Test: Elemental stream fraction adens: FAIL:\n \
FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_ele_row, ele_value,
        			target_ele_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Elemental stream fraction adens: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_iso == 0)
        {

            sprintf(print_data, "Test: Isotopic stream fraction adens: FAIL:\n \
FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_iso_row, iso_value,
        			target_iso_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Isotopic stream fraction adens: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderparseclpsolution.c                     */
/*                                                                           */
/* Created:       2016/04/12 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that the components of the clp solution are properly   */
/*              assinged to composition groups and streams as well as to     */
/*              their respective burn step trackers                          */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterialCompMatrix       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERParseClpSolution:"

void TESTADERParseClpSolution(double *solution, long step)
{

    char *const test_name = "ADERParseClpSolution";
    char status[5];
    char print_data[256];
    char *mat_name;
    double argon40_density = 0.0, flibefuel_density = 0.0;
    double pass_value_stream_burn_step = 0.0, pass_value_stream_cur_amt = 0.0;
    double percent_diff_stream_burn_step = 0.0, percent_diff_stream_cur_amt = 0.0;
    double test_value_stream_burn_step = 0.0, test_value_stream_cur_amt = 0.0;
    int append = 0;
    int boolean = 0, boolean_cmp = 0, boolean_cmp_burn = 0, boolean_stream = 0;
    int boolean_stream_burn = 0;
    long ader_data, ader_mat_cmp, ader_mat_cmp_burn_step, ader_mat_cmp_col_id;
    long ader_mat_stream, ader_mat_stream_burn_step, ader_mat_stream_col_id;
    long ader_mat_sum_stream;
    long ader_mat_sum_stream_ent, ader_test_block, argon40, mat, mat_ader_data;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERParseClpSolution.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    argon40 = mat;

    argon40_density = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has feed streams but no ActF stream.\n");

        if(strcmp("ActF", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Argon40 has feed stream ActF but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material Argon40 feed stream ActF has sum streams but no Uranium sum stream.\n");

                if(strcmp("Uranium", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material FLiBeFuel not found. \n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    ader_mat_stream_col_id = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_COL_ID];

                	break;

                }

            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);
            }

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no cmp groups.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    flibefuel_density = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    ader_mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(ader_mat_cmp > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has cmp groups but no FLiBe.\n");

        if(strcmp("FLiBe", GetText(ader_mat_cmp + ADER_MAT_CMP_ID)) == 0)
        {

        	ader_mat_cmp_col_id = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_COL_ID];

        	break;

        }

    	ader_mat_cmp = NextItem(ader_mat_cmp);

    }

    /* Now that we have the column indices we need, modify the solution array */

    solution[ader_mat_cmp_col_id] = 0.3;

    solution[ader_mat_stream_col_id] = 0.1;

    pass_value_stream_cur_amt = 0.1 *
    		                   (RDB[mat + MATERIAL_VOLUME] /
    		                    RDB[argon40 + MATERIAL_VOLUME]);

    pass_value_stream_burn_step = 0.1 * flibefuel_density *
                                  (RDB[mat + MATERIAL_VOLUME] /
                                   RDB[argon40 + MATERIAL_VOLUME]);
;

    /* Now, run the function and test if it assigns new values                */

    ADERParseClpSolution(0, 0, mat, step, solution);

    if(RDB[ader_mat_cmp + ADER_MAT_CMP_CUR_AMT] < 0.300001 &&
       RDB[ader_mat_cmp + ADER_MAT_CMP_CUR_AMT] > 0.299999)
    {

    	boolean_cmp = 1;

    }

    test_value_stream_cur_amt = RDB[ader_mat_sum_stream + ADER_MAT_STREAM_CUR_AMT];

    percent_diff_stream_cur_amt = (test_value_stream_cur_amt -
    		                       pass_value_stream_cur_amt) /
    		                      test_value_stream_cur_amt;

    if(fabs(percent_diff_stream_cur_amt) < 0.001)
    {

    	boolean_stream = 1;

    }

    /* Now retrieve the burn step information, there is only one burn step so */
    /* no looping to the answer is needed                                     */

    ader_mat_cmp_burn_step = (long)RDB[ader_mat_cmp + ADER_MAT_CMP_BURN_STEPS_PTR];

    if(RDB[ader_mat_cmp_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] < 0.300001 &&
       RDB[ader_mat_cmp_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE] > 0.299999)
    {

    	boolean_cmp_burn = 1;

    }

    ader_mat_stream_burn_step = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_BURN_STEPS_PTR];

    test_value_stream_burn_step = RDB[ader_mat_stream_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE];

    percent_diff_stream_burn_step = (test_value_stream_burn_step -
    		                         pass_value_stream_burn_step ) /
    		                         pass_value_stream_burn_step;

    if(fabs(percent_diff_stream_burn_step) < 0.001)
    {

    	boolean_stream_burn = 1;

    }

    if(boolean_cmp == 1 &&
       boolean_cmp_burn == 1 &&
       boolean_stream == 1 &&
	   boolean_stream_burn == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_cmp == 0)
        {

        	sprintf(print_data, "Test: cmp group: FAIL - Index %ld has as value %f\n \
but ADER_MAT_CMP_CUR_AMT, with value %f, needs value 0.3.\n",
                    ader_mat_cmp_col_id, solution[ader_mat_cmp_col_id],
					RDB[ader_mat_cmp + ADER_MAT_CMP_CUR_AMT]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: cmp group: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_cmp_burn == 0)
        {

        	sprintf(print_data, "Test: cmp group burn step value: FAIL - Index %ld has as value %f\n \
but the burn step value is reported as %f and needs value 0.3.\n",
                    ader_mat_cmp_col_id, solution[ader_mat_cmp_col_id],
					RDB[ader_mat_cmp_burn_step + ADER_MAT_GRP_BURN_STEP_VALUE]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: cmp group burn step value: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream == 0)
        {

        	sprintf(print_data, "Test: stream: FAIL - Index %ld has as value %f\n \
but ADER_MAT_STREAM_CUR_AMT, with value %f, needs value 0.1.\n",
                    ader_mat_stream_col_id, solution[ader_mat_stream_col_id],
					RDB[ader_mat_sum_stream + ADER_MAT_STREAM_CUR_AMT]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: stream group: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_stream_burn == 0)
        {

        	sprintf(print_data, "Test: stream burn step value: FAIL - Burn step value is reported as %f\n\
  and needs value %f.\n", test_value_stream_burn_step,
                          pass_value_stream_burn_step);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: cmp group burn step value: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

    /* Quickly reset all the streams in this cluster to not complicate testing*/

    solution[ader_mat_cmp_col_id] = 0.0;

    solution[ader_mat_stream_col_id] = 0.0;

    /* Now, run the function and test if it assigns new values                */

    ADERParseClpSolution(0, 0, mat, step, solution);

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderprocessmatstreameleunfixedisoelefrac.c */
/*                                                                           */
/* Created:       2016/30/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests for correct fraction of host element in unfixed iso    */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERProcessMatStreamEleUnFixedIsoEleFrac:"

void TESTADERProcessMatStreamEleUnFixedIsoEleFrac(long step)
{

    char *const test_name = "ADERProcessMatStreamEleUnFixedIsoEleFrac";
    char status[5];
    char print_data[256];
    char *mat_name, *stream_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block;
    long mat, mat_ader_data, stream, stream_iso, stream_iso_zai ;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERProcessMatStreamEleUnFixedIsoEleFrac.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no redox streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Fluorine redox stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", stream_name, 8) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Fluorine redox stream but no isotopes.\n");

            stream_iso = (long)RDB[stream + ADER_MAT_STREAM_ISOS_PTR];

            while(stream_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel Fluorine stream has isotopes but no F-19.\n");

                stream_iso_zai = (long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI];

                if(stream_iso_zai == 90190)
                {

                    sprintf(print_data, "FLiBeFuel Fluorine stream has F-19 but bad frac of %f.\n",
                            RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC]);

                    if(RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] < 1.0000001 &&
                       RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] > 0.9999999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                stream_iso = NextItem(stream_iso);
            }

            break;
        }

        stream = NextItem(stream);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderprocessmatstreameleunfixedisofrac.c    */
/*                                                                           */
/* Created:       2016/30/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests for correct fraction of isotope in unfixed ele stream  */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERProcessMatStreamEleUnFixedIsoFrac:"

void TESTADERProcessMatStreamEleUnFixedIsoFrac(long step)
{

    char *const test_name = "ADERProcessMatStreamEleUnFixedIsoFrac";
    char status[5];
    char print_data[256];
    char *mat_name, *stream_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block;
    long mat, mat_ader_data, stream, stream_iso, stream_iso_zai ;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERProcessMatStreamEleUnFixedIsoFrac.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no redox streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Fluorine redox stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", stream_name, 8) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Fluorine redox stream but no isotopes.\n");

            stream_iso = (long)RDB[stream + ADER_MAT_STREAM_ISOS_PTR];

            while(stream_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel Fluorine stream has isotopes but no F-19.\n");

                stream_iso_zai = (long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI];

                if(stream_iso_zai == 90190)
                {

                    sprintf(print_data, "FLiBeFuel Fluorine stream has F-19 but bad frac of %f.\n",
                            RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC]);

                    if(RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] < 1.0000001 &&
                       RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] > 0.9999999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                stream_iso = NextItem(stream_iso);
            }

            break;
        }

        stream = NextItem(stream);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderprocessmatsumstreameleunfixedisofrac.c */
/*                                                                           */
/* Created:       2016/30/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests for correct fraction of isotope in unfixed ele  sum    */
/* sum stream                                                                */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERProcessMatSumStreamEleUnFixedIsoFrac:"

void TESTADERProcessMatSumStreamEleUnFixedIsoFrac(long step)
{

    char *const test_name = "ADERProcessMatSumStreamEleUnFixedIsoFrac";
    char status[5];
    char print_data[256];
    char *mat_name, *stream_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block;
    long mat, mat_ader_data, stream, stream_iso, stream_iso_zai;
    long sum_stream_data, sum_stream;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERProcessMatSumStreamEleUnFixedIsoFrac.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no remv streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no ActF2 remv stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("ActF2", stream_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ActF2 remv stream but no sum streams.\n");

            sum_stream_data = (long)RDB[stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(sum_stream_data > VALID_PTR)
            {


                sprintf(print_data, "FLiBeFuel ActF2 remv stream has sum streams but no Uranium2.\n");

                if(strncmp("Uranium2", GetText(sum_stream_data + ADER_MAT_GRP_SUM_GRP_ID), 8) == 0)
                {

                    sprintf(print_data, "FLiBeFuel ActF2 remv stream has Uranium2 but Uranium2 has no isotopes.\n");

                    sum_stream = (long)RDB[sum_stream_data + ADER_MAT_GRP_SUM_GRP_PTR];

                    stream_iso = (long)RDB[sum_stream + ADER_MAT_STREAM_ISOS_PTR];

                    while(stream_iso > VALID_PTR)
                    {

                        sprintf(print_data, "FLiBeFuel ActF2 remv stream Uranium2 has isotopes but no U-233.\n");

                        stream_iso_zai = (long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI];

                        if(stream_iso_zai == 922330)
                        {

                            sprintf(print_data, "FLiBeFuel ActF2 remv stream Uranium2 U-233 has bad frac of %f.\n",
                                    RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC]);

                            if(RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] < 0.949993 &&
                               RDB[stream_iso + ADER_MAT_GRP_ISO_FRAC] > 0.949991)
                            {

                                boolean = 1;

                                memset(print_data, 0, strlen(print_data));

                            }

                            break;

                        }

                        stream_iso = NextItem(stream_iso);
                    }

                    break;

                }

                sum_stream_data = NextItem(sum_stream_data);

            }

            break;
        }

        stream = NextItem(stream);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadersolveclpmodel.c                        */
/*                                                                           */
/* Created:       2016/04/26 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests the solution of the clp model                          */
/*                                                                           */
/* Comments:This function is called from ADEROperateMaterial                 */
/*                                       ADEROperateMaterialCompMatrix       */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERSolveClpModel:"

void TESTADERSolveClpModel(long step)
{

    char *const test_name = "ADERSolveClpModel";
    char status[5];
    char print_data[256];
    int append = 0;
    int boolean = 0, boolean_column = 0, boolean_objective = 0;
    long ader_data, ader_test_block;

    /* Clp data                                                               */

    long num_col = 5;
    long num_ent = 9;
    long num_row = 3;
    double index_column_starts[6] = {0.0, 1.0, 2.0, 3.0, 6.0, 9.0};
    double row_indices[9] = {0.0, 1.0, 2.0, 0.0, 1.0, 2.0, 0.0, 1.0, 2.0};
    double values[9] = {1.0, 1.0, 1.0, -2.0, 1.0, 3.0, 1.0, 4.0, 2.0};
    double column_lower_bounds[5] = {0.0, 0.0, 0.0, 0.0, 0.0};
    double column_upper_bounds[5] = {1000000.0, 1000000.0, 1000000.0, 1000000.0, 1000000.0};
    double objective_row[5] = {2.0, -1.0, 1.0, -5.0, 22.0};
    double row_lower_bounds[3] = {6.0, 3.0, 10.0};
    double row_upper_bounds[3] = {6.0, 3.0, 10.0};
    double solution[5] = {0.0, 0.0, 0.0, 0.0, 0.0};

    /* The matrix these vectors define is given below. The bounds on the rows */
    /* are given as the values to the left ( min ) and right ( max ) of the   */
    /* rows of the matrix. The bounds on the columns are given as the numbers */
    /* above and below the matrix ( min on top, max on bottom ). inf = infinity*/
    /* The letters above the columns are the variables those columns represent.*/
    /* The matrix as a whole represents the constrains that the objective     */
    /* function, p, is subject to. The problem is a minimization problem as   */
    /* seen by the value of 1 as the seventh argument to the ADERSolveClpModel*/
    /* function                                                               */

    /*          a   b   c   d   e
     *          0   0   0   0   0
     *        ___               ___
     *      6 | 1   0   0  -2   1 | 6
     *      3 | 0   1   0   1   4 | 3
     *     10 | 0   0   1   3   2 | 10
     *        ---               ---
     *         inf inf inf inf inf
     *
     * Min P = 2a - 1b + 1c - 5d + 22e
     */

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERSolveClpModel.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    ADERSolveClpModel(column_lower_bounds, column_upper_bounds,
    		          index_column_starts, num_col, num_ent, num_row,
					  objective_row, 1, row_lower_bounds, row_indices,
					  row_upper_bounds, solution, values, 0);

    /* Check both the first column value and the objective value              */

    if(solution[0] < 12.00001 &&
       solution[0] > 11.99999)
    {

    	boolean_column = 1;

    }

    if(solution[5] < 10.00001 &&
       solution[5] > 0.99999)
    {

    	boolean_objective = 1;

    }

    if(boolean_column == 1 &&
       boolean_objective == 1)
    {

    	boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_column == 0)
        {

        	sprintf(print_data, "Test: column solution: FAIL - First value is %f\n \
but needs value 12.\n", solution[0]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: column solution: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_objective == 0)
        {

        	sprintf(print_data, "Test: objective value: FAIL - Objective value is %f\n \
but needs value 10.\n", solution[5]);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: objective value: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testadertransmuxs.c                            */
/*                                                                           */
/* Created:       2016/04/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests to be sure that transmutation cross sections were      */
/*              acquired                                                     */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERTransmuXS:"

void TESTADERTransmuXS(long step)
{

    char *const test_name = "ADERTransmuXS";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ader_data, ader_test_block, mat, mat_iso, rea, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERTransmuXS.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBEFuel not found.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no U-233.\n");

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

            sprintf(print_data, "FLiBeFuel U-233 has no reactions.\n");

            rea = (long)RDB[nuc + NUCLIDE_PTR_REA];

            while(rea > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel U-233 has reactions but no fission XS.\n");

                if((long)RDB[rea + REACTION_PTR_FISSY] > VALID_PTR)
                {

                    sprintf(print_data, "FLiBeFuel U-233 has fission XS but only decay.\n");

                    if((long)RDB[rea + REACTION_TYPE] != REACTION_TYPE_DECAY)
                    {

                        sprintf(print_data, "FLiBeFuel U-233 has fission XS but 0 value.\n");

                        if((long)RDB[rea + REACTION_PTR_TRANSMUXS] > 0)
                        {

                            boolean = 1;

                            memset(print_data, 0, strlen(print_data));

                            break;

                        }

                    }

                }

                rea = NextItem(rea);

            }

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderupdatematerialcompmatrixstreamisofracs.c*/
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that destination stream isotope fractions are updated  */
/*              with the source stream isotope fractions. Additionally checks*/
/*              that stream isotopic fractions for unfixed elements are      */
/*              updated                                                      */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERUpdateMaterialCompMatrixStreamIsoFracs:"

void TESTADERUpdateMaterialCompMatrixStreamIsoFracs(long step)
{

    char *const test_name = "ADERUpdateMaterialCompMatrixStreamIsoFracs";
    char status[5];
    char print_data[256];
    char *mat_name;
    double Li6_frac, Li7_frac;
    double Lithium7_adens, Fluorine1_adens, percent_diff_Li6_value;
    double percent_diff_Li7_value, target_Li6_value, target_Li7_value;
    int i;
    int append = 0;
    int boolean = 0, boolean_Li6 = 0, boolean_Li7 = 0;
    long ader_data, ader_mat_Li6_row, ader_mat_Li7_row;
    long ader_mat_iso;
    long ader_mat_matrix_col;
    long ader_mat_matrix_col_row, ader_mat_matrix_data, ader_mat_stream;
    long ader_mat_stream_col_id;
    long ader_test_block, mat, mat_iso, mat_ader_data;
    long nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERUpdateMaterialCompMatrixStreamIsoFracs.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    Lithium7_adens = RDB[mat + MATERIAL_ADENS];

    /* Adjust Lithium isotopic composition to test adjustments                */

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {
        sprintf(print_data, "Material Lithium7 has isotopes but is missing Li-6.\n");

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
    	{

            sprintf(print_data, "Material Lithium7 has Li-6 but is missing Li-7.\n");

    		WDB[mat_iso + COMPOSITION_ADENS] = 0.9 * RDB[mat_iso + COMPOSITION_ADENS];

    		break;

    	}

    	mat_iso = NextItem(mat_iso);

    }

    mat_iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(mat_iso > VALID_PTR)
    {

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

    	if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
    	{

            sprintf(print_data, "Material Lithium7 has Li-7 but is missing ader isotope.\n");

    		WDB[mat_iso + COMPOSITION_ADENS] = 1.1 * RDB[mat_iso + COMPOSITION_ADENS];

    		break;

    	}

    	mat_iso = NextItem(mat_iso);

    }

    target_Li7_value = -0.55;

    /* Rerun the update functions to insert these values                       */

    ADERProcessMaterialStreamUnFixedEleIsoFracs(mat);

    ADERProcessMaterialShadowStreamEleAndIsoFracs(mat);

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Lithium7 has ader isotopes but no Li-7. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
        {

        	sprintf(print_data, "Material Lithium7 has Li-7 but no ader streams. \n");

            ader_mat_Li7_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Lithium7 has redox streams but no LithiumFree stream.\n");

        if(strcmp("LithiumFree", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Lithium7 has LithiumFree stream but material Fluorine1 does not exist.\n");

			ader_mat_stream_col_id = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_COL_ID];

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine1", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Fluorine1 has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Run the update functions on this material as well                      */

    ADERProcessMaterialStreamUnFixedEleIsoFracs(mat);

    ADERProcessMaterialShadowStreamEleAndIsoFracs(mat);

    Fluorine1_adens = RDB[mat + MATERIAL_ADENS];

    /* The 2.0 is for a volume correction factor                              */

    target_Li6_value = 0.45 * (Lithium7_adens / Fluorine1_adens) * 2.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Fluorine1 has ader isotopes but no Li-6. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

        	sprintf(print_data, "Material Fluorine1 has Li-6 but Lithium7 has no matrix data. \n");

            ader_mat_Li6_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "There is an error in the matrix.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ader_mat_stream_col_id; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_Li6_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    Li6_frac = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_Li6_value = (Li6_frac - target_Li6_value) / target_Li6_value;

    if(fabs(percent_diff_Li6_value) < 0.00001)
    {

        boolean_Li6 = 1;

    }

    /* Now check the isotope                                                  */

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_Li7_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    Li7_frac = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_Li7_value = (Li7_frac - target_Li7_value) / target_Li7_value;

    if(fabs(percent_diff_Li7_value) < 0.00001)
    {

        boolean_Li7 = 1;

    }


    if(boolean_Li6 == 1 &&
       boolean_Li7 == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_Li6 == 0)
        {

            sprintf(print_data, "Test: Li-6 update: FAIL:\n \
Lithium7 matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_Li6_row, Li6_frac,
        			target_Li6_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Li-6 update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_Li7 == 0)
        {

            sprintf(print_data, "Test: Li-7 update: FAIL:\n \
Lithium7 matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_Li7_row, Li7_frac,
        			target_Li7_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Li-7 update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderupdatematerialcompmatrixsumstreamisofracs.c*/
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests that destination stream isotope fractions are updated  */
/*              with the source stream isotope fractions. Additionally checks*/
/*              that stream isotopic fractions for unfixed elements are      */
/*              updated                                                      */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERUpdateMaterialCompMatrixSumStreamIsoFracs:"

void TESTADERUpdateMaterialCompMatrixSumStreamIsoFracs(long step)
{

    char *const test_name = "ADERUpdateMaterialCompMatrixSumStreamIsoFracs";
    char status[5];
    char print_data[256];
    char *mat_name;
    double Li6_frac, Li7_frac;
    double Lithium7_adens, Fluorine1_adens, percent_diff_Li6_value;
    double percent_diff_Li7_value, target_Li6_value, target_Li7_value;
    int i;
    int append = 0;
    int boolean = 0, boolean_Li6 = 0, boolean_Li7 = 0;
    long ader_data, ader_mat_Li6_row, ader_mat_Li7_row;
    long ader_mat_iso;
    long ader_mat_matrix_col;
    long ader_mat_matrix_col_row, ader_mat_matrix_data, ader_mat_stream;
    long ader_mat_stream_col_id, ader_mat_sum_stream_ent, ader_mat_sum_stream;
    long ader_test_block, mat, mat_iso, mat_ader_data;
    long nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERUpdateMaterialCompMatrixSumStreamIsoFracs.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    Lithium7_adens = RDB[mat + MATERIAL_ADENS];

    target_Li7_value = -0.55;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Lithium7 has ader isotopes but no Li-7. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30070)
        {

        	sprintf(print_data, "Material Lithium7 has Li-7 but no ader streams. \n");

            ader_mat_Li7_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Lithium7 has feed streams but no FreeStreams stream.\n");

        if(strcmp("FreeStreams", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Lithium7 has FreeStreams stream but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material Lithium7 FreeStreams stream has sum streams but no LithiumFree stream.\n");

                if(strcmp("LithiumFree", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material Lithium7 FreeStreams has LithiumFree stream but material Fluorine1 does not exist.\n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

        			ader_mat_stream_col_id = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_COL_ID];

                	break;

                }


            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);

            }

            break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine1", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Fluorine1 has no ader isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    Fluorine1_adens = RDB[mat + MATERIAL_ADENS];

    /* The 2.0 is for a volume correction factor                              */

    target_Li6_value = 0.45 * (Lithium7_adens / Fluorine1_adens) * 2.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Fluorine1 has ader isotopes but no Li-6. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

        	sprintf(print_data, "Material Fluorine1 has Li-6 but Lithium7 has no matrix data. \n");

            ader_mat_Li6_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "There is an error in the matrix.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ader_mat_stream_col_id; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_Li6_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    Li6_frac = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_Li6_value = (Li6_frac - target_Li6_value) / target_Li6_value;

    if(fabs(percent_diff_Li6_value) < 0.00001)
    {

        boolean_Li6 = 1;

    }

    /* Now check the isotope                                                  */

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_Li7_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    Li7_frac = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff_Li7_value = (Li7_frac - target_Li7_value) / target_Li7_value;

    if(fabs(percent_diff_Li7_value) < 0.00001)
    {

        boolean_Li7 = 1;

    }


    if(boolean_Li6 == 1 &&
       boolean_Li7 == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_Li6 == 0)
        {

            sprintf(print_data, "Test: Li-6 update: FAIL:\n \
Lithium7 matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_Li6_row, Li6_frac,
        			target_Li6_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Li-6 update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_Li7 == 0)
        {

            sprintf(print_data, "Test: Li-7 update: FAIL:\n \
Lithium7 matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_Li7_row, Li7_frac,
        			target_Li7_value);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Li-7 update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderupdatematerialdiscstreameffects.c      */
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests four things: material compositions are updated with    */
/*              disc stream effects and that material density is updated     */
/*              The same is tested for rem table disc type streams           */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERUpdateMaterialDiscStreamEffects:"

void TESTADERUpdateMaterialDiscStreamEffects(long step)
{

    char *const test_name = "ADERUpdateMaterialDiscStreamEffects";
    char status[5];
    char print_data[256];
    char *mat_name;
    double f19_adens, fluorine0_adens;
    double fluorine0_adens_old, fluorine1_adens, lithium7_adens;
    double lithium7_adens_old, percent_diff_f19;
    double percent_diff_fluorine_adens, percent_diff_lithium7_adens;
    double percent_diff_u233, target_value_f19, target_value_fluorine0_adens;
    double target_value_lithium7_adens, target_value_u233, uranium233_adens;
    double u233_adens;
    int append = 0;
    int boolean = 0, boolean_den_lithium7 = 0, boolean_f19 = 0;
    int boolean_den_fluorine0 = 0, boolean_u233 = 0;
    long ader_data;
    long ader_mat_iso, ader_mat_stream;
    long ader_test_block, mat, mat_ader_data, mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERUpdateMaterialDiscStreamEffects.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Uranium233 not found. \n");

    /* Get the first test mat */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Uranium233", mat_name, 10) == 0)
        {

            sprintf(print_data, "Material Fluorine0 not found.\n");

            break;

        }

        mat = NextItem(mat);

    }

    uranium233_adens = RDB[mat + MATERIAL_ADENS];

    target_value_u233 = uranium233_adens * 0.1;

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine0", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Fluorine0 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* First grab the old adens before the update                             */

    fluorine0_adens_old = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

    	sprintf(print_data, "Material Fluorine0 has redox streams but no U233 stream. \n");

        if(strncmp("U233", GetText(ader_mat_stream + ADER_MAT_STREAM_ID), 4) == 0)
        {

        	sprintf(print_data, "Material Fluorine0 has no ader isotopes. \n");

        	WDB[ader_mat_stream + ADER_MAT_STREAM_CUR_AMT] = 0.1;

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Call the function to test                                              */

    ADERUpdateMaterialDiscStreamEffects(0, 0, mat);

    fluorine0_adens = RDB[mat + MATERIAL_ADENS];

    target_value_fluorine0_adens = fluorine0_adens_old + uranium233_adens * 0.1;

    percent_diff_fluorine_adens = (fluorine0_adens - target_value_fluorine0_adens) / target_value_fluorine0_adens;

    if(fabs(percent_diff_fluorine_adens) < 0.00001)
    {

    	boolean_den_fluorine0 = 1;

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Fluorine0 has ader isotopes but no U-233. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

        	sprintf(print_data, "Material Fluorine1 not found. \n");

        	u233_adens = RDB[mat_iso + COMPOSITION_ADENS];

            percent_diff_u233 = (u233_adens - target_value_u233) / target_value_u233;

            if(fabs(percent_diff_u233) < 0.00001)
            {

            	boolean_u233 = 1;

            }

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    /* Now test that removal table streams which are disc in form are handeld */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine1", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Lithium7 not found.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    fluorine1_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    /* The 0.5 is a volume correction factor                                  */

    target_value_f19 = fluorine1_adens * 0.00001 * 864000 * 0.5;

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "Material Lithium7 has no isotopes.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    lithium7_adens_old = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    /* Call the function to test                                              */

    ADERUpdateMaterialDiscStreamEffects(0, 0, mat);

    lithium7_adens = RDB[mat + MATERIAL_ADENS];

    target_value_lithium7_adens = lithium7_adens_old + target_value_f19;

    percent_diff_lithium7_adens = (lithium7_adens - target_value_lithium7_adens) / target_value_lithium7_adens;

    if(fabs(percent_diff_lithium7_adens) < 0.001)
    {

    	boolean_den_lithium7 = 1;

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Lithium7 has ader isotopes but no F-19. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 90190)
        {

        	sprintf(print_data, "Material Lithium7 has F-19. \n");

        	f19_adens = RDB[mat_iso + COMPOSITION_ADENS];

            percent_diff_f19 = (f19_adens - target_value_f19) / target_value_f19;

            if(fabs(percent_diff_f19) < 0.001)
            {

            	boolean_f19 = 1;

            }

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(boolean_den_fluorine0 == 1 &&
       boolean_u233 == 1 &&
	   boolean_den_lithium7 == 1 &&
	   boolean_f19 == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_f19 == 0)
        {

            sprintf(print_data, "Test: F-19 isotopic adens update: FAIL:\n \
F-19 in Lithium7 has adens %f and needs adens %f.\n",
                    f19_adens, target_value_f19);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: F-19 isotopic adens update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_den_fluorine0 == 0)
        {

            sprintf(print_data, "Test: Density group type update: FAIL:\n \
Fluorine0 has density %f and needs density %f.\n", fluorine0_adens,
                    target_value_fluorine0_adens);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Density group type update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_den_lithium7 == 0)
        {

            sprintf(print_data, "Test: Density rem type update: FAIL:\n \
Lithium7 has density %f and needs density %f.\n", lithium7_adens,
                    target_value_lithium7_adens);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Density rem type update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_u233 == 0)
        {

            sprintf(print_data, "Test: U-233 isotopic adens update: FAIL:\n \
U-233 in Fluorine0 has adens %f and needs adens %f.\n",
                    u233_adens, target_value_u233);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: U-233 isotopic adens update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : testaderupdatematerialdiscsumstreameffects.c   */
/*                                                                           */
/* Created:       2016/28/09 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Tests two things: material compositions are updated with     */
/*              disc stream effects and that material density is updated     */
/*              This test is executed on sum streams                         */
/*                                                                           */
/* Comments:This function is called from ADERCorrectTransportCycle           */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "TESTADERUpdateMaterialDiscSumStreamEffects:"

void TESTADERUpdateMaterialDiscSumStreamEffects(long step)
{

    char *const test_name = "ADERUpdateMaterialDiscSumStreamEffects";
    char status[5];
    char print_data[256];
    char *mat_name;
    double fluorine1_adens;
    double fluorine1_adens_old, percent_diff_fluorine_adens, percent_diff_li6;
    double target_value_fluorine_adens, target_value_li6, lithium7_adens;
    int append = 0;
    int boolean = 0, boolean_den = 0, boolean_li6 = 0;
    long ader_data;
    long ader_mat_iso, ader_mat_stream, ader_mat_sum_stream;
    long ader_mat_sum_stream_ent;
    long ader_test_block, mat, mat_ader_data, mat_iso, nuc;

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_test_block = (long)RDB[ader_data + ADER_TEST_INFO_PTR];

    /* This test only runs if its the first step                              */

    if(step > 0)
    {

        return;

    }

    fprintf(outp, "Begin: TESTADERUpdateMaterialDiscSumStreamEffects.\n");

    WDB[ader_test_block + ADER_TEST_NUM_CASES] += 1.0;

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test mat */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            sprintf(print_data, "Material Fluorine1 not found.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    lithium7_adens = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    target_value_li6 = lithium7_adens * 0.1 * 0.45;

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine1", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material Fluorine1 has no ader streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* First grab the old adens before the update                             */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    fluorine1_adens_old = RDB[mat_ader_data + ADER_MAT_PRE_STEP_ADENS];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Fluorine1 has redox streams but no FreeStreams stream.\n");

        if(strcmp("FreeStreams", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Fluorine1 has FreeStreams stream but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material Fluorine1 FreeStreams stream has sum streams but no LithiumFree stream.\n");

                if(strcmp("LithiumFree", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material Fluorine1 FreeStreams has LithiumFree stream but has no ader isotopes.\n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    WDB[ader_mat_sum_stream + ADER_MAT_STREAM_CUR_AMT] = 0.1;

                	break;

                }


            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);

            }

            break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    /* Call the function to test                                              */

    ADERUpdateMaterialDiscStreamEffects(0, 0, mat);

    fluorine1_adens = RDB[mat + MATERIAL_ADENS];

    target_value_fluorine_adens = fluorine1_adens_old + lithium7_adens * 0.1 -
    		                      (fluorine1_adens_old * 0.5 * 0.00002 * 864000);

    percent_diff_fluorine_adens = (fluorine1_adens - target_value_fluorine_adens) / target_value_fluorine_adens;

    if(fabs(percent_diff_fluorine_adens) < 0.001)
    {

    	boolean_den = 1;

    }

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material Fluorine1 has ader isotopes but no Li-6. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

        	sprintf(print_data, "Material Fluorine0 has U-233. \n");

            percent_diff_li6 = (RDB[mat_iso + COMPOSITION_ADENS] - target_value_li6) / target_value_li6;

            if(fabs(percent_diff_li6) < 0.00001)
            {

            	boolean_li6 = 1;

            }

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    if(boolean_den == 1 &&
       boolean_li6 == 1)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {

        WDB[ader_test_block + ADER_TEST_NUM_PASSED] += 1.0;

        strcpy(status, "pass");

        PrintTest(test_name, status, print_data, append);

    }
    else
    {

        WDB[ader_test_block + ADER_TEST_NUM_FAILED] += 1.0;

        strcpy(status, "fail");

        PrintTest(test_name, status, print_data, append);

        if(boolean_den == 0)
        {

            sprintf(print_data, "Test: Density update: FAIL:\n \
Fluorine1 has density %f and needs density %f.\n", fluorine1_adens,
                    target_value_fluorine_adens);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Density update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

        if(boolean_li6 == 0)
        {

            sprintf(print_data, "Test: Li-6 isotopic adens update: FAIL:\n \
Li-6 in Fluorine1 has adens %f and needs adens %f.\n",
                    RDB[mat_iso + COMPOSITION_ADENS], target_value_li6);

        	PrintTest(test_name, status, print_data, 1);

        }
        else
        {

        	sprintf(print_data, "Test: Li-6 isotopic adens update: PASS\n");

        	PrintTest(test_name, status, print_data, 1);

        }

    }

}
/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : printtest.c                                    */
/*                                                                           */
/* Created:       2015/10/11 (DDW)                                           */
/* Last modified: 2019/06/09 (DDW)                                           */
/* Version:       2.1.31                                                     */
/*                                                                           */
/* Description: Holds tests. Does not actually run them. runtests.c does.    */
/*                                                                           */
/* Comments:                                                                 */
/*                                                                           */
/*****************************************************************************/

#include "element_data.h"
#include "header.h"
#include "locations.h"
#include "serp_tests.h"

/*****************************************************************************/

int test_num_cases = 172;

int Test_ADERFillMatCompMatrixCmpFutEle();
int Test_ADERFillMatCompMatrixCmpFutIso();
int Test_ADERFillMatCompMatrixCmpSumGrp();
int Test_ADERFillMatCompMatrixEleDelBal();
int Test_ADERFillMatCompMatrixEleDelDel();
int Test_ADERFillMatCompMatrixEleFutBal();
int Test_ADERFillMatCompMatrixEleFutFut();
int Test_ADERFillMatCompMatrixEleIsoFutEle();
int Test_ADERFillMatCompMatrixEleIsoFutIso();
int Test_ADERFillMatCompMatrixIsoDelBal();
int Test_ADERFillMatCompMatrixIsoDelDel();
int Test_ADERFillMatCompMatrixIsoFutBal();
int Test_ADERFillMatCompMatrixIsoFutFut();
int Test_ADERFillMatCompMatrixOxiFutEle();
int Test_ADERFillMatCompMatrixStreamDelEle();
int Test_ADERFillMatCompMatrixStreamDelIso();
int Test_ADERFillMatCompMatrixStreamSumGrp();
int Test_ADERFillMatCompMatrixSumStreamDelEle();
int Test_ADERFillMatCompMatrixSumStreamDelIso();
int Test_ADERGetMatEleIsoFrac();
int Test_ADERProcessAderGrpCmpFrac();
int Test_ADERProcessAderGrpIsoFrac();
int Test_ADERProcessAderMatClusterMems();
int Test_ADERProcessAderMatClusterParent();
int Test_ADERProcessAderMatCmpEleFrac();
int Test_ADERProcessAderMatCmpGrpPtr();
int Test_ADERProcessAderMatCmpIsoEleFrac();
int Test_ADERProcessAderMatCmpIsoFrac();
int Test_ADERProcessAderMatCmpRngMax();
int Test_ADERProcessAderMatCmpRngMin();
int Test_ADERProcessAderMatCmpRto2GrpPtr();
int Test_ADERProcessAderMatCmpRtoMax();
int Test_ADERProcessAderMatCmpRtoMin();
int Test_ADERProcessAderMatCmpSumGrpsPtr();
int Test_ADERProcessAderMatCmpSumGrpWeight();
int Test_ADERProcessAderMatCndPtr();
int Test_ADERProcessAderMatCntTblPtr();
int Test_ADERProcessAderMatIsoPtr();
int Test_ADERProcessAderMatOptDir();
int Test_ADERProcessAderMatOptType();
int Test_ADERProcessAderMatOptTypeTarget();
int Test_ADERProcessAderMatOxiMax();
int Test_ADERProcessAderMatOxiMin();
int Test_ADERProcessAderMatOxiTblPtr();
int Test_ADERProcessAderMatPreserveType();
int Test_ADERProcessAderMatStrmDest();
int Test_ADERProcessAderMatStrmEleFix();
int Test_ADERProcessAderMatStrmEleFrac();
int Test_ADERProcessAderMatStrmFeedType();
int Test_ADERProcessAderMatStrmForm();
int Test_ADERProcessAderMatStrmIsoEleFrac();
int Test_ADERProcessAderMatStrmIsoFrac();
int Test_ADERProcessAderMatStrmMatPtr();
int Test_ADERProcessAderMatStrmPtr();
int Test_ADERProcessAderMatStrmRedoxType();
int Test_ADERProcessAderMatStrmRemvGroup();
int Test_ADERProcessAderMatStrmRemvType();
int Test_ADERProcessAderMatStrmReacType();
int Test_ADERProcessAderMatStrmShadowPtr();
int Test_ADERProcessAderMatStrmShadowSumStrmPtr();
int Test_ADERProcessAderMatStrmSrc();
int Test_ADERProcessAderMatStrmSumGrpsPtr();
int Test_ADERProcessAderMatStrmTypeGroup();
int Test_ADERProcessAderMatStrmTypeRem();
int Test_ADERProcessAderReproElement();
int Test_ADERProcessAderReproIsoEle();
int Test_ADERProcessAderReproIsotope();
int Test_ADERProcessAderStreamSourcesAndDests();
int Test_ADERProcessAderSumGrpPtr();
int Test_ADERProcessMatClusterOpt();
int Test_ADERProcessMatCmpIsoMatAderIsoPtr();
int Test_ADERProcessMatGrpEleIsoPtr();
int Test_ADERProcessMatReproEleIsoRate();
int Test_ADERProcessMatReproIsoRate();
int Test_ADERProcessMatStreamIsoMatAderIsoPtr();
int Test_ADERProcessMatStreamEleUnFixedIsos();
int Test_ADERSetAderClusterMembers();
int Test_ADERSetAderCndCntId();
int Test_ADERSetAderCndId();
int Test_ADERSetAderCndOptDir();
int Test_ADERSetAderCndOptTarget();
int Test_ADERSetAderCndOptType();
int Test_ADERSetAderCndOxiId();
int Test_ADERSetAderCndOxiMax();
int Test_ADERSetAderCndOxiMin();
int Test_ADERSetAderCndOxiVal();
int Test_ADERSetAderCndPreserveType();
int Test_ADERSetAderCndRngGrpId();
int Test_ADERSetAderCndRngMax();
int Test_ADERSetAderCndRngMin();
int Test_ADERSetAderCndRngVal();
int Test_ADERSetAderCndRtoGrpId();
int Test_ADERSetAderCndRtoMax();
int Test_ADERSetAderCndRtoMin();
int Test_ADERSetAderCndRtoVal();
int Test_ADERSetAderControlEntZ();
int Test_ADERSetAderControlEntZai();
int Test_ADERSetAderControlTblId();
int Test_ADERSetAderGrpCompZ();
int Test_ADERSetAderGrpId();
int Test_ADERSetAderGrpIsoZai();
int Test_ADERSetAderGrpSumGroupsPtr();
int Test_ADERSetAderKMax();
int Test_ADERSetAderKMin();
int Test_ADERSetAderNegAdens();
int Test_ADERSetAderOxiEleVal();
int Test_ADERSetAderOxiEleWeight();
int Test_ADERSetAderOxiEleZ();
int Test_ADERSetAderOxiTblId();
int Test_ADERSetAderReproEntVal();
int Test_ADERSetAderReproEntZ();
int Test_ADERSetAderReproEntZai();
int Test_ADERSetAderReproTblId();
int Test_ADERSetAderStrDest();
int Test_ADERSetAderStrForm();
int Test_ADERSetAderStrGrpId();
int Test_ADERSetAderStrGrpType();
int Test_ADERSetAderStrOpt1();
int Test_ADERSetAderStrSrc();
int Test_ADERSetAderStrType();
int Test_ADERSetAderSumGrpWeight();
int Test_ADERSetAderTransIter();
int Test_ADERSetMatAderMem();
int Test_ADERSetMatAderCndMem();
int Test_ADERSetMatCmpColLowerBounds();
int Test_ADERSetMatCmpColId();
int Test_ADERSetMatCmpColUpperBounds();
int Test_ADERSetMatCmpSumRowId();
int Test_ADERSetMatCompMatrixElement();
int Test_ADERSetMatEleBalRowId();
int Test_ADERSetMatEleControl();
int Test_ADERSetMatEleDelColId();
int Test_ADERSetMatEleDelColPtr();
int Test_ADERSetMatEleDelRowId();
int Test_ADERSetMatEleFutColId();
int Test_ADERSetMatEleFutColPtr();
int Test_ADERSetMatEleFutRowId();
int Test_ADERSetMatEleIsoAderMatIsoPtr();
int Test_ADERSetMatEleIsoRowId();
int Test_ADERSetMatIsoBalRowId();
int Test_ADERSetMatIsoControl();
int Test_ADERSetMatIsoDelColId();
int Test_ADERSetMatIsoDelColPtr();
int Test_ADERSetMatIsoDelRowId();
int Test_ADERSetMatIsoFutColId();
int Test_ADERSetMatIsoFutColPtr();
int Test_ADERSetMatIsoFutRowId();
int Test_ADERSetMatKMaxRowBounds();
int Test_ADERSetMatKMaxRowId();
int Test_ADERSetMatKMinRowBounds();
int Test_ADERSetMatKMinRowId();
int Test_ADERSetMatObjGroup();
int Test_ADERSetMatObjFeed();
int Test_ADERSetMatObjFeedAndRemoval();
int Test_ADERSetMatObjReac();
int Test_ADERSetMatObjRedox();
int Test_ADERSetMatObjRemoval();
int Test_ADERSetMatObjStream();
int Test_ADERSetMatObjStreams();
int Test_ADERSetMatObjTransfers();
int Test_ADERSetMatOxiRowBounds();
int Test_ADERSetMatOxiRowId();
int Test_ADERSetMatParentMPINum();
int Test_ADERSetMatPreserveRowBounds();
int Test_ADERSetMatPreserveRowId();
int Test_ADERSetMatStrmColId();
int Test_ADERSetMatStrmShadowColId();
int Test_ADERSetMatStrmShadowSumColId();
int Test_ADERSetMatStrmShadowSumRowId();
int Test_ADERSetMatStrmSumColId();
int Test_ADERSetMatStrmSumRowId();
int Test_RunTests();


int (*test_foo_array[172])() = {&Test_ADERFillMatCompMatrixCmpFutEle,
                              &Test_ADERFillMatCompMatrixCmpFutIso,
                              &Test_ADERFillMatCompMatrixCmpSumGrp,
                              &Test_ADERFillMatCompMatrixEleDelBal,
                              &Test_ADERFillMatCompMatrixEleDelDel,
                              &Test_ADERFillMatCompMatrixEleFutBal,
                              &Test_ADERFillMatCompMatrixEleFutFut,
                              &Test_ADERFillMatCompMatrixEleIsoFutEle,
                              &Test_ADERFillMatCompMatrixEleIsoFutIso,
                              &Test_ADERFillMatCompMatrixIsoDelBal,
                              &Test_ADERFillMatCompMatrixIsoDelDel,
                              &Test_ADERFillMatCompMatrixIsoFutBal,
                              &Test_ADERFillMatCompMatrixIsoFutFut,
                              &Test_ADERFillMatCompMatrixOxiFutEle,
                              &Test_ADERFillMatCompMatrixStreamDelEle,
                              &Test_ADERFillMatCompMatrixStreamDelIso,
                              &Test_ADERFillMatCompMatrixStreamSumGrp,
							  &Test_ADERFillMatCompMatrixSumStreamDelEle,
							  &Test_ADERFillMatCompMatrixSumStreamDelIso,
                              &Test_ADERGetMatEleIsoFrac,
                              &Test_ADERProcessAderGrpCmpFrac,
                              &Test_ADERProcessAderGrpIsoFrac,
                              &Test_ADERProcessAderMatClusterMems,
                              &Test_ADERProcessAderMatClusterParent,
                              &Test_ADERProcessAderMatCmpEleFrac,
                              &Test_ADERProcessAderMatCmpGrpPtr,
                              &Test_ADERProcessAderMatCmpIsoEleFrac,
                              &Test_ADERProcessAderMatCmpIsoFrac,
                              &Test_ADERProcessAderMatCmpRngMax,
                              &Test_ADERProcessAderMatCmpRngMin,
                              &Test_ADERProcessAderMatCmpRto2GrpPtr,
                              &Test_ADERProcessAderMatCmpRtoMax,
                              &Test_ADERProcessAderMatCmpRtoMin,
                              &Test_ADERProcessAderMatCmpSumGrpsPtr,
                              &Test_ADERProcessAderMatCmpSumGrpWeight,
                              &Test_ADERProcessAderMatCndPtr,
                              &Test_ADERProcessAderMatCntTblPtr,
                              &Test_ADERProcessAderMatIsoPtr,
                              &Test_ADERProcessAderMatOptDir,
                              &Test_ADERProcessAderMatOptType,
                              &Test_ADERProcessAderMatOptTypeTarget,
                              &Test_ADERProcessAderMatOxiMax,
                              &Test_ADERProcessAderMatOxiMin,
                              &Test_ADERProcessAderMatOxiTblPtr,
                              &Test_ADERProcessAderMatPreserveType,
                              &Test_ADERProcessAderMatStrmDest,
                              &Test_ADERProcessAderMatStrmEleFix,
                              &Test_ADERProcessAderMatStrmEleFrac,
                              &Test_ADERProcessAderMatStrmFeedType,
                              &Test_ADERProcessAderMatStrmForm,
                              &Test_ADERProcessAderMatStrmIsoEleFrac,
                              &Test_ADERProcessAderMatStrmIsoFrac,
							  &Test_ADERProcessAderMatStrmMatPtr,
                              &Test_ADERProcessAderMatStrmPtr,
                              &Test_ADERProcessAderMatStrmRedoxType,
                              &Test_ADERProcessAderMatStrmRemvGroup,
                              &Test_ADERProcessAderMatStrmRemvType,
                              &Test_ADERProcessAderMatStrmReacType,
                              &Test_ADERProcessAderMatStrmShadowPtr,
                              &Test_ADERProcessAderMatStrmShadowSumStrmPtr,
                              &Test_ADERProcessAderMatStrmSrc,
                              &Test_ADERProcessAderMatStrmSumGrpsPtr,
                              &Test_ADERProcessAderMatStrmTypeGroup,
                              &Test_ADERProcessAderMatStrmTypeRem,
                              &Test_ADERProcessAderReproElement,
							  &Test_ADERProcessAderReproIsoEle,
                              &Test_ADERProcessAderReproIsotope,
                              &Test_ADERProcessAderStreamSourcesAndDests,
                              &Test_ADERProcessAderSumGrpPtr,
                              &Test_ADERProcessMatClusterOpt,
                              &Test_ADERProcessMatCmpIsoMatAderIsoPtr,
                              &Test_ADERProcessMatReproEleIsoRate,
                              &Test_ADERProcessMatReproIsoRate,
                              &Test_ADERProcessMatStreamIsoMatAderIsoPtr,
                              &Test_ADERProcessMatGrpEleIsoPtr,
                              &Test_ADERProcessMatStreamEleUnFixedIsos,
                              &Test_ADERSetAderClusterMembers,
                              &Test_ADERSetAderCndCntId,
                              &Test_ADERSetAderCndId,
                              &Test_ADERSetAderCndOptDir,
                              &Test_ADERSetAderCndOptTarget,
                              &Test_ADERSetAderCndOptType,
                              &Test_ADERSetAderCndOxiId,
                              &Test_ADERSetAderCndOxiMax,
                              &Test_ADERSetAderCndOxiMin,
                              &Test_ADERSetAderCndOxiVal,
                              &Test_ADERSetAderCndPreserveType,
                              &Test_ADERSetAderCndRngGrpId,
                              &Test_ADERSetAderCndRngMax,
                              &Test_ADERSetAderCndRngMin,
                              &Test_ADERSetAderCndRngVal,
                              &Test_ADERSetAderCndRtoGrpId,
                              &Test_ADERSetAderCndRtoMax,
                              &Test_ADERSetAderCndRtoMin,
                              &Test_ADERSetAderCndRtoVal,
                              &Test_ADERSetAderControlEntZ,
                              &Test_ADERSetAderControlEntZai,
                              &Test_ADERSetAderControlTblId,
                              &Test_ADERSetAderGrpCompZ,
                              &Test_ADERSetAderGrpId,
                              &Test_ADERSetAderGrpIsoZai,
                              &Test_ADERSetAderGrpSumGroupsPtr,
                              &Test_ADERSetAderKMax,
                              &Test_ADERSetAderKMin,
							  &Test_ADERSetAderNegAdens,
                              &Test_ADERSetAderOxiEleVal,
                              &Test_ADERSetAderOxiEleWeight,
                              &Test_ADERSetAderOxiEleZ,
                              &Test_ADERSetAderOxiTblId,
                              &Test_ADERSetAderReproEntVal,
                              &Test_ADERSetAderReproEntZ,
                              &Test_ADERSetAderReproEntZai,
                              &Test_ADERSetAderReproTblId,
                              &Test_ADERSetAderStrDest,
                              &Test_ADERSetAderStrForm,
                              &Test_ADERSetAderStrGrpId,
                              &Test_ADERSetAderStrGrpType,
                              &Test_ADERSetAderStrOpt1,
                              &Test_ADERSetAderStrSrc,
                              &Test_ADERSetAderStrType,
                              &Test_ADERSetAderSumGrpWeight,
                              &Test_ADERSetAderTransIter,
                              &Test_ADERSetMatAderMem,
                              &Test_ADERSetMatAderCndMem,
                              &Test_ADERSetMatCmpColLowerBounds,
                              &Test_ADERSetMatCmpColId,
                              &Test_ADERSetMatCmpColLowerBounds,
                              &Test_ADERSetMatCmpSumRowId,
                              &Test_ADERSetMatCompMatrixElement,
                              &Test_ADERSetMatEleBalRowId,
							  &Test_ADERSetMatEleControl,
                              &Test_ADERSetMatEleDelColId,
                              &Test_ADERSetMatEleDelColPtr,
                              &Test_ADERSetMatEleDelRowId,
                              &Test_ADERSetMatEleFutColId,
                              &Test_ADERSetMatEleFutColPtr,
                              &Test_ADERSetMatEleFutRowId,
                              &Test_ADERSetMatEleIsoAderMatIsoPtr,
                              &Test_ADERSetMatEleIsoRowId,
                              &Test_ADERSetMatIsoBalRowId,
							  &Test_ADERSetMatIsoControl,
                              &Test_ADERSetMatIsoDelColId,
                              &Test_ADERSetMatIsoDelColPtr,
                              &Test_ADERSetMatIsoDelRowId,
                              &Test_ADERSetMatIsoFutColId,
                              &Test_ADERSetMatIsoFutColPtr,
                              &Test_ADERSetMatIsoFutRowId,
                              &Test_ADERSetMatKMaxRowBounds,
                              &Test_ADERSetMatKMaxRowId,
                              &Test_ADERSetMatKMinRowBounds,
                              &Test_ADERSetMatKMinRowId,
                              &Test_ADERSetMatObjGroup,
                              &Test_ADERSetMatObjFeed,
                              &Test_ADERSetMatObjFeedAndRemoval,
                              &Test_ADERSetMatObjReac,
                              &Test_ADERSetMatObjRedox,
                              &Test_ADERSetMatObjRemoval,
                              &Test_ADERSetMatObjStream,
                              &Test_ADERSetMatObjStreams,
                              &Test_ADERSetMatObjTransfers,
                              &Test_ADERSetMatOxiRowBounds,
                              &Test_ADERSetMatOxiRowId,
                              &Test_ADERSetMatParentMPINum,
                              &Test_ADERSetMatPreserveRowBounds,
                              &Test_ADERSetMatPreserveRowId,
                              &Test_ADERSetMatStrmColId,
                              &Test_ADERSetMatStrmShadowColId,
                              &Test_ADERSetMatStrmShadowSumColId,
                              &Test_ADERSetMatStrmShadowSumRowId,
                              &Test_ADERSetMatStrmSumColId,
                              &Test_ADERSetMatStrmSumRowId,
                              &Test_RunTests};

int Test_ADERFillMatCompMatrixCmpFutEle()
{
    char *const test_name = "ADERFillMatCompMatrixCmpFutEle";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_cmp, mat_cmp_col, mat_ele, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixCmpFutEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(mat_cmp > VALID_PTR)
    {

        if(strncmp("FLiBe", GetText(mat_cmp + ADER_MAT_CMP_ID), 5) == 0)
        {

            mat_cmp_col = (long)RDB[mat_cmp + ADER_MAT_CMP_COL_ID];

            sprintf(print_data, "FLiBeFuel has no Li ele in ader data.\n");

            break;

        }

        mat_cmp = NextItem(mat_cmp);

    }

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_cmp_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_row, mat_cmp_col,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 0.374608);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.374607 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 0.374609)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixCmpFutIso()
{
    char *const test_name = "ADERFillMatCompMatrixCmpFutIso";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_cmp, mat_cmp_col, mat_iso, mat_iso_act;
    long mat_iso_row, mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixCmpFutIso.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(mat_cmp > VALID_PTR)
    {

        if(strncmp("FLiBe", GetText(mat_cmp + ADER_MAT_CMP_ID), 5) == 0)
        {

            mat_cmp_col = (long)RDB[mat_cmp + ADER_MAT_CMP_COL_ID];

            sprintf(print_data, "FLiBeFuel has no Li-6 iso in ader data.\n");

            break;

        }

        mat_cmp = NextItem(mat_cmp);

    }

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_FUT_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_cmp_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %1.8e but \n\
needs value %1.8e.\n", mat_iso_row, mat_cmp_col,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 0.0003746);

    if((RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.000373) &&
       (RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 0.000375))
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixCmpSumGrp()
{
    char *const test_name = "ADERFillMatCompMatrixCmpSumGrp";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_cmp, mat_cmp_sum_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;
    long mat_sum_cmp, mat_sum_cmp_col, mat_sum_cmp_grp;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixCmpSumGrp.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no ActF cmp group.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(mat_cmp > VALID_PTR)
    {

        if(strncmp("ActF", GetText(mat_cmp + ADER_MAT_CMP_ID), 4) == 0)
        {

            mat_cmp_sum_row = (long)RDB[mat_cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID];

            sprintf(print_data, "FLiBeFuel has no Uranium cmp.\n");

            break;

        }

        mat_cmp = NextItem(mat_cmp);

    }

    mat_sum_cmp = (long)RDB[mat_cmp + ADER_MAT_CMP_SUM_GRPS_PTR];

    while(mat_sum_cmp > VALID_PTR)
    {

        if(strncmp("Uranium", GetText(mat_sum_cmp + ADER_GRP_SUM_GRP_ID), 7) == 0)
        {

            mat_sum_cmp_grp = (long)RDB[mat_sum_cmp + ADER_GRP_SUM_GRP_PTR];

            mat_sum_cmp_col = (long)RDB[mat_sum_cmp_grp + ADER_MAT_CMP_COL_ID];

            break;

        }

        mat_sum_cmp = NextItem(mat_sum_cmp);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_sum_cmp_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_cmp_sum_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_sum_cmp_col, mat_cmp_sum_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixEleDelBal()
{
    char *const test_name = "ADERFillMatCompMatrixEleDelBal";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleDelBal.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_DEL_COL_ID];

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_BAL_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixEleDelDel()
{
    char *const test_name = "ADERFillMatCompMatrixEleDelDel";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleDelDel.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_DEL_COL_ID];

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_DEL_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixEleFutBal()
{
    char *const test_name = "ADERFillMatCompMatrixEleFutBal";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleFutBal.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_COL_ID];

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_BAL_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.0000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.9999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}


int Test_ADERFillMatCompMatrixEleFutFut()
{
    char *const test_name = "ADERFillMatCompMatrixEleFutFut";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleFutFut.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_COL_ID];

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_row, mat_ele_col,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixEleIsoFutEle()
{
    char *const test_name = "ADERFillMatCompMatrixEleIsoFutEle";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleIsoFutEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_COL_ID];

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_ISO_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.0000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.9999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixEleIsoFutIso()
{
    char *const test_name = "ADERFillMatCompMatrixEleIsoFutIso";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_row, mat_iso, mat_iso_act;
    long mat_iso_col, mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixEleIsoFutIso.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_ISO_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_col = (long)RDB[mat_iso + ADER_MAT_ISO_FUT_COL_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_iso_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.00000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.99999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixIsoDelBal()
{
    char *const test_name = "ADERFillMatCompMatrixIsoDelBal";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_iso, mat_iso_act, mat_iso_col, mat_iso_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixIsoDelBal.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_col = (long)RDB[mat_iso + ADER_MAT_ISO_DEL_COL_ID];

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_BAL_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_iso_col, mat_iso_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixIsoDelDel()
{
    char *const test_name = "ADERFillMatCompMatrixIsoDelDel";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_iso, mat_iso_act, mat_iso_col, mat_iso_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixIsoDelDel.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_col = (long)RDB[mat_iso + ADER_MAT_ISO_DEL_COL_ID];

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_iso_col, mat_iso_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixIsoFutBal()
{
    char *const test_name = "ADERFillMatCompMatrixIsoFutBal";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_iso, mat_iso_act, mat_iso_col, mat_iso_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixIsoFutBal.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_col = (long)RDB[mat_iso + ADER_MAT_ISO_FUT_COL_ID];

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_BAL_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_iso_col, mat_iso_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.0000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.9999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixIsoFutFut()
{
    char *const test_name = "ADERFillMatCompMatrixIsoFutFut";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_iso, mat_iso_act, mat_iso_col, mat_iso_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixIsoFutFut.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no Li ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_col = (long)RDB[mat_iso + ADER_MAT_ISO_FUT_COL_ID];

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_FUT_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_iso_col, mat_iso_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.9999999 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.0000001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixOxiFutEle()
{
    char *const test_name = "ADERFillMatCompMatrixOxiFutEle";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_ele, mat_ele_col;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data, mat_oxi, mat_oxi_row;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixOxiFutEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no B ele data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    mat_oxi_row = (long)RDB[mat_oxi + ADER_MAT_OXI_ROW_ID];

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 5)
        {

            sprintf(print_data, "FLiBeFuel has B ele data but unknown error.\n");

            mat_ele_col = (long)RDB[mat_ele + ADER_MAT_ELE_FUT_COL_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_ele_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_oxi_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_ele_col, mat_oxi_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 2.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 2.0000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 1.9999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixStreamDelEle()
{
    char *const test_name = "ADERFillMatCompMatrixStreamDelEle";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_stream, mat_stream_col, mat_ele, mat_ele_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixStreamDelEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe stream.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no FLiBe feed stream.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        if(strncmp("FLiBe", GetText(mat_stream + ADER_MAT_STREAM_ID), 5) == 0)
        {

            mat_stream_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            sprintf(print_data, "FLiBeFuel has no Li ele in ader data.\n");

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(mat_ele > VALID_PTR)
    {

        if((long)RDB[mat_ele + ADER_MAT_ELE_Z] == 3)
        {

            mat_ele_row = (long)RDB[mat_ele + ADER_MAT_ELE_DEL_ROW_ID];

            break;

        }

        mat_ele = NextItem(mat_ele);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_ele_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_stream_col, mat_ele_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 0.374608);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 0.3746082 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.3746080)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixStreamDelIso()
{
    char *const test_name = "ADERFillMatCompMatrixStreamDelIso";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_stream, mat_stream_col, mat_iso, mat_iso_act;
    long mat_iso_row, mat_matrix_col, mat_matrix_col_row, mat_matrix_data, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixStreamDelIso.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe stream.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no FLiBe feed stream.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        if(strncmp("FLiBe", GetText(mat_stream + ADER_MAT_STREAM_ID), 5) == 0)
        {

            mat_stream_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            sprintf(print_data, "FLiBeFuel has no Li-6 iso in ader data.\n");

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_iso_act = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso_act + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            mat_iso_row = (long)RDB[mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_iso_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_stream_col, mat_iso_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 0.0003746);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 0.0003747 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.0003745)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixStreamSumGrp()
{
    char *const test_name = "ADERFillMatCompMatrixStreamSumGrp";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_stream, mat_stream_sum_row;
    long mat_matrix_col, mat_matrix_col_row, mat_matrix_data;
    long mat_sum_stream, mat_sum_stream_col, mat_sum_stream_grp;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixStreamSumGrp.\n");

    /*Clear the print_data */
    sprintf(print_data, "FLiBeFuel has no FLiBe composition group.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no ActF cmp group.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        if(strncmp("ActF", GetText(mat_stream + ADER_MAT_STREAM_ID), 4) == 0)
        {

            mat_stream_sum_row = (long)RDB[mat_stream + ADER_MAT_STREAM_SUM_GRPS_ROW_ID];

            sprintf(print_data, "FLiBeFuel stream ActF has no Uranium sum stream.\n");

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_sum_stream = (long)RDB[mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

    while(mat_sum_stream > VALID_PTR)
    {

        if(strncmp("Uranium", GetText(mat_sum_stream + ADER_GRP_SUM_GRP_ID), 7) == 0)
        {

            mat_sum_stream_grp = (long)RDB[mat_sum_stream + ADER_GRP_SUM_GRP_PTR];

            mat_sum_stream_col = (long)RDB[mat_sum_stream_grp + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_sum_stream = NextItem(mat_sum_stream);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_sum_stream_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < mat_stream_sum_row; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", mat_sum_stream_col, mat_stream_sum_row,
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], -1.0);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.000001 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixSumStreamDelEle()
{
    char *const test_name = "ADERFillMatCompMatrixSumStreamDelEle";
    char status[5];
    char print_data[256];
    char *mat_name;
    double adens_corr_factor, argon40_adens, flibefuel_adens, percent_diff;
    double test_value;
    int append = 0;
    int boolean = 0;
    int i;
    long ader_mat_ele, ader_mat_ele_row, ader_mat_matrix_data;
    long ader_mat_matrix_col, ader_mat_matrix_col_row;
    long ader_mat_stream, ader_mat_stream_col_id, ader_mat_sum_stream;
    long ader_mat_sum_stream_ent, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixSumStreamDelEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Save Argon40s adens                                                    */
    argon40_adens = RDB[mat + MATERIAL_ADENS];

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material Argon40 has feed streams but no ActF stream.\n");

        if(strcmp("ActF", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

            sprintf(print_data, "Material Argon40 has feed stream ActF but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material Argon40 feed stream ActF has sum streams but no Uranium sum stream.\n");

                if(strcmp("Uranium", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material Argon40 has no ader_mat_elements. \n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    ader_mat_stream_col_id = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_COL_ID];

                	break;

                }

            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);
            }

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ader_mat_ele > VALID_PTR)
    {

    	sprintf(print_data, "Material Argon40 has elements but no U. \n");

        if((long)RDB[ader_mat_ele + ADER_MAT_ELE_Z] == 92)
        {

        	sprintf(print_data, "Material Argon40 has U but material FLiBeFuel does not exist. \n");

            ader_mat_ele_row = (long)RDB[ader_mat_ele + ADER_MAT_ELE_DEL_ROW_ID];

            break;

        }

        ader_mat_ele = NextItem(ader_mat_ele);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no matrix data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get FLiBeFuel's adens and get the adens corr factor                    */

    flibefuel_adens = RDB[mat + MATERIAL_ADENS];

    /* The 2 is for the volume correction factor                              */

    adens_corr_factor = (flibefuel_adens / argon40_adens) * 2.0;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ader_mat_stream_col_id; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_ele_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    test_value = RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    percent_diff = (test_value - adens_corr_factor) / adens_corr_factor;

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value %f.\n", ader_mat_stream_col_id, ader_mat_ele_row,
            test_value, adens_corr_factor);

    if(fabs(percent_diff) < 0.00001)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERFillMatCompMatrixSumStreamDelIso()
{
    char *const test_name = "ADERFillMatCompMatrixSumStreamDelIso";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long ader_mat_iso, ader_mat_iso_row, ader_mat_matrix_data;
    long ader_mat_matrix_col, ader_mat_matrix_col_row;
    long ader_mat_stream, ader_mat_stream_col_id, ader_mat_sum_stream;
    long ader_mat_sum_stream_ent, mat, mat_ader_data, mat_iso, nuc;

    fprintf(outp, "Begin: Test_ADERFillMatCompMatrixSumStreamDelIso.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(ader_mat_stream > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel has feed streams but no ActF stream.\n");

        if(strcmp("ActF", GetText(ader_mat_stream + ADER_MAT_STREAM_ID)) == 0)
        {

        	if(strcmp("NULL", GetText(ader_mat_stream + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		ader_mat_stream = NextItem(ader_mat_stream);

        		continue;

        	}

            sprintf(print_data, "Material FLiBeFuel has feed stream ActF but no sum streams.\n");

            ader_mat_sum_stream_ent = (long)RDB[ader_mat_stream + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(ader_mat_sum_stream_ent > VALID_PTR)
            {

                sprintf(print_data, "Material FLiBeFuel feed stream ActF has sum streams but no Uranium sum stream.\n");

                if(strcmp("Uranium", GetText(ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_ID)) == 0)
                {

                    sprintf(print_data, "Material FLiBeFuel has no ader_mat_isos. \n");

                    ader_mat_sum_stream = (long)RDB[ader_mat_sum_stream_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    ader_mat_stream_col_id = (long)RDB[ader_mat_sum_stream + ADER_MAT_STREAM_COL_ID];

                	break;

                }

            	ader_mat_sum_stream_ent = NextItem(ader_mat_sum_stream_ent);
            }

        	break;

        }

        ader_mat_stream = NextItem(ader_mat_stream);

    }

    ader_mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(ader_mat_iso > VALID_PTR)
    {

    	sprintf(print_data, "Material FLiBeFuel has isotopes but no U-233. \n");

    	mat_iso = (long)RDB[ader_mat_iso + ADER_MAT_ISO_PTR];

    	nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 922330)
        {

        	sprintf(print_data, "Material FLiBeFuel has U-233 but no matrix data. \n");

            ader_mat_iso_row = (long)RDB[ader_mat_iso + ADER_MAT_ISO_DEL_ROW_ID];

            break;

        }

        ader_mat_iso = NextItem(ader_mat_iso);

    }

    ader_mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    ader_mat_matrix_col = (long)RDB[ader_mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < ader_mat_stream_col_id; i++)
    {

        ader_mat_matrix_col = NextItem(ader_mat_matrix_col);

    }

    ader_mat_matrix_col_row = (long)RDB[ader_mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < ader_mat_iso_row; i++)
    {

        ader_mat_matrix_col_row = NextItem(ader_mat_matrix_col_row);

    }

    sprintf(print_data, "FLiBeFuel matrix element, (%ld, %ld), has value %f but \n\
needs value 1.\n", ader_mat_iso_row, ader_mat_stream_col_id,
            RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

    if(RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > -1.000001 &&
       RDB[ader_mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < -0.999999)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERGetMatEleIsoFrac()
{
    char *const test_name = "ADERGetMatEleIsoFrac";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_iso, ele_z, mat, mat_ader_data, mat_iso, iso, nuc;

    fprintf(outp, "Begin: Test_ADERGetMatEleIsoFrac.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    ADERGetMatEleIsoFrac(mat);

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element Li not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 3)
        {


            ele_iso = (long)RDB[ele + ADER_MAT_ELE_ISOS_PTR];

            sprintf(print_data, "Element Li found but has no isotopes.\n");

            while(ele_iso > VALID_PTR)
            {

                sprintf(print_data, "Element Li found but has no Li-6.\n");

                mat_iso = (long)RDB[ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

                iso = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

                nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

                if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
                {

                    sprintf(print_data, "Li-6 found but has bad fraction of %f and needs fraction of %f.\n",
                            RDB[ele_iso + ADER_MAT_ELE_ISO_FRAC], 0.001);

                    if((RDB[ele_iso + ADER_MAT_ELE_ISO_FRAC] < 0.00101) &&
                       (RDB[ele_iso + ADER_MAT_ELE_ISO_FRAC] > 0.00099))
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                ele_iso = NextItem(ele_iso);

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderGrpCmpFrac()
{
    char *const test_name = "ADERProcessAderGrpCmpFrac";
    char *grp_name;
    char status[5], print_data[256];
    double comp_frac;
    int append = 0;
    int boolean = 0;
    long ADER_data, comp, comp_Z, grp;

    fprintf(outp, "Begin: Test_ADERProcessAderGrpCmpFrac.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];
    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("FLiBe", grp_name, 5) == 0)
        {
            break;
        }

        grp = NextItem(grp);
    }

    comp = (long)RDB[grp + ADER_GRP_COMP_PTR];

    while(comp > VALID_PTR)
    {
        comp_Z = (long)RDB[comp + ADER_GRP_COMP_Z];

        comp_frac = RDB[comp + ADER_GRP_COMP_FRAC];

        if(comp_Z == 4)
        {

            if(comp_frac < 0.083594567 && comp_frac > 0.083594565)
            {

               boolean = 1;

               break;

            }

        }

        comp = NextItem(comp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderGrpIsoFrac()
{
    char *const test_name = "ADERProcessAderGrpIsoFrac";
    char *grp_name;
    char status[5], print_data[256];
    double iso_frac;
    int append = 0;
    int boolean = 0;
    long ADER_data, comp, comp_Z, grp, iso, iso_ZAI;

    fprintf(outp, "Begin: Test_ADERProcessAderGrpIsoFrac.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];
    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("FLiBe", grp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBe group found but has no comp pointer.\n");

            break;

        }

        grp = NextItem(grp);
    }

    comp = (long)RDB[grp + ADER_GRP_COMP_PTR];

    while(comp > VALID_PTR)
    {
        comp_Z = (long)RDB[comp + ADER_GRP_COMP_Z];

        sprintf(print_data, "FLiBe group has comp but no Lithium.\n");

        if(comp_Z == 3)
        {

            sprintf(print_data, "FLiBe group has Lithium but no isos.\n");

            iso = (long)RDB[comp + ADER_GRP_COMP_ISOS_PTR];

            while(iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBe group has Lithium isos but no Li-7.\n");

                iso_ZAI = (long)RDB[iso + ADER_GRP_ISO_ZAI];

                iso_frac = RDB[iso + ADER_GRP_ISO_FRAC];

                if(iso_ZAI == 30070)
                {

                    sprintf(print_data, "FLiBe group has Li-7 but bad frac.\n");

                    if(iso_frac < 0.9990001 && iso_frac > 0.9989999)
                    {

                       boolean = 1;

                       memset(print_data, 0, strlen(print_data));

                       break;

                    }

                }

                iso = NextItem(iso);

            }

            break;

        }

        comp = NextItem(comp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatClusterMems()
{
    char *const test_name = "ADERProcessAderMatClusterMems";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_cluster_ent, mat_cluster_ent_ptr, mat_ader_data;
    long FLiBeFuel_ptr = 0, booleanFLiBeFuel = 0;
    long Fluorine_ptr = 0, booleanFluorine = 0;
    long Uranium_ptr = 0, booleanUranium = 0;

    fprintf(outp, "Begin: Test_ADERProcessAderMatClusterMems.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the pointers of the necessary materials*/

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            FLiBeFuel_ptr = mat;

        }
        else if(strncmp("Fluorine0", mat_name, 9) == 0)
        {

            Fluorine_ptr = mat;

        }
        else if(strncmp("Uranium233", mat_name, 10) == 0)
        {

            Uranium_ptr = mat;

        }

        if((FLiBeFuel_ptr > 0) && (Fluorine_ptr > 0) && (Uranium_ptr > 0))
        {

            sprintf(print_data, "Target material indicies found.\n");

            break;

        }

        mat = NextItem(mat);
    }

    /* We are going to check the pointers inside of Fluorine0, so set it to mat*/

    mat = Fluorine_ptr;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cluster_ent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_MEMS_PTR];

    sprintf(print_data, "Material Fluorine0 has no cluster members.\n");

    while(mat_cluster_ent > VALID_PTR)
    {

        mat_cluster_ent_ptr = (long)RDB[mat_cluster_ent + ADER_MAT_CLUSTER_MEM_PTR];

        if(mat_cluster_ent_ptr == FLiBeFuel_ptr)
        {

            booleanFLiBeFuel = 1;

        }
        else if(mat_cluster_ent_ptr == Fluorine_ptr)
        {

            booleanFluorine = 1;

        }
        else if(mat_cluster_ent_ptr == Uranium_ptr)
        {

            booleanUranium = 1;
        }

        if((booleanFLiBeFuel == 1) && (booleanFluorine == 1) && (booleanUranium == 1))
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        mat_cluster_ent = NextItem(mat_cluster_ent);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatClusterParent()
{
    char *const test_name = "ADERProcessAderMatClusterParent";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_cluster_parent, mat_cluster_parent_ptr, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessAderMatClusterParent.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the pointers of the parent materials*/

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            mat_cluster_parent = mat;

            break;

        }

        mat = NextItem(mat);

    }


    /* Get the pointers of the target materials*/

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine0", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    sprintf(print_data, "Material Fluorine0 has bad parent pointer.\n");

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cluster_parent_ptr = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    if(mat_cluster_parent == mat_cluster_parent_ptr)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpEleFrac()
{
    char *const test_name = "ADERProcessAderMatCmpEleFrac";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    double mat_cmp_ele_frac;
    int append = 0;
    int boolean = 0;
    long cmp, ele, ele_Z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessAderMatEleFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but no elements.\n");

            ele = (long)RDB[cmp + ADER_MAT_CMP_ELES_PTR];

            while(ele > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has elements but no F.\n");

                ele_Z = (long)RDB[ele + ADER_MAT_GRP_ELE_Z];

                mat_cmp_ele_frac = RDB[ele +ADER_MAT_GRP_ELE_FRAC];

                if(ele_Z == 9)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe group has F but bad frac.\n");

                    if(mat_cmp_ele_frac < 0.541798 && mat_cmp_ele_frac > 0.541796)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }
                    break;
                }

                ele = NextItem(ele);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpGrpPtr()
{
    char *const test_name = "ADERProcessAderMatCmpGrpPtr";
    char *cmp_name, *grp_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cmp, cmp_grp_ptr, grp, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpGrpPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but no group ID.\n");

            cmp_grp_ptr = (long)RDB[cmp + ADER_MAT_CMP_GRP_PTR];

            /* Get actual instance of group that sum_grp_ptr should point to */
            grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

            while(grp > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel has FLiBe group and ID but broken link.\n");

                grp_name = GetText(grp + ADER_GRP_ID);

                if(strncmp("FLiBe", grp_name, 5) == 0)
                {
                    break;
                }

                grp = NextItem(grp);
            }

            if(grp == cmp_grp_ptr)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpIsoEleFrac()
{
    char *const test_name = "ADERProcessAderMatCmpIsoEleFrac";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    double mat_cmp_iso_frac;
    int append = 0;
    int boolean = 0;
    long cmp, iso, iso_ZAI, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessAderMatIsoEleFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but no isotopes.\n");

            iso = (long)RDB[cmp + ADER_MAT_CMP_ISOS_PTR];

            while(iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has isotopes but no Li-7.\n");

                iso_ZAI = (long)RDB[iso + ADER_MAT_GRP_ISO_ZAI];

                mat_cmp_iso_frac = RDB[iso +ADER_MAT_GRP_ISO_ELE_FRAC];

                if(iso_ZAI == 30070)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe group has Li-7 but bad frac.\n");

                    if(mat_cmp_iso_frac < 0.999001 && mat_cmp_iso_frac > 0.998999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }
                    break;
                }

                iso = NextItem(iso);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpIsoFrac()
{
    char *const test_name = "ADERProcessAderMatCmpIsoFrac";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    double mat_cmp_iso_frac;
    int append = 0;
    int boolean = 0;
    long cmp, iso, iso_ZAI, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessAderMatIsoFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but no isotopes.\n");

            iso = (long)RDB[cmp + ADER_MAT_CMP_ISOS_PTR];

            while(iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has isotopes but no Li-6.\n");

                iso_ZAI = (long)RDB[iso + ADER_MAT_GRP_ISO_ZAI];

                mat_cmp_iso_frac = RDB[iso + ADER_MAT_GRP_ISO_FRAC];

                if(iso_ZAI == 30060)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe group has Li-6 but bad frac, %f, needs frac %f.\n",
                            mat_cmp_iso_frac, 0.0003746);

                    if(mat_cmp_iso_frac < 0.0003747 && mat_cmp_iso_frac > 0.0003745)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }
                    break;
                }

                iso = NextItem(iso);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpRngMax()
{
    char *const test_name = "ADERProcessAderMatCmpRngMax";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    double mat_rng_max;
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, rng;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpRngMax.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but bad rng max.\n");

            rng = (long)RDB[cmp + ADER_MAT_CMP_RNG_PTR];

            mat_rng_max = RDB[rng + ADER_MAT_CMP_RNG_MAX];

            if(mat_rng_max < 1.000001 && mat_rng_max > 0.9999999 )
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpRngMin()
{
    char *const test_name = "ADERProcessAderMatCmpRngMin";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    double mat_rng_min;
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, rng;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpRngMin.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but bad rng min.\n");

            rng = (long)RDB[cmp + ADER_MAT_CMP_RNG_PTR];

            mat_rng_min = RDB[rng + ADER_MAT_CMP_RNG_MIN];

            if(mat_rng_min < 0.200001 && mat_rng_min > 0.1999999 )
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpRto2GrpPtr()
{
    char *const test_name = "ADERProcessAderMatCmpRto2GrpPtr";
    char *cmp_name, *sec_cmp_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, rto, sec_cmp, sec_cmp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpRto2GrpPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

    sec_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(sec_cmp > VALID_PTR)
    {

        sec_cmp_name = GetText(sec_cmp + ADER_MAT_CMP_ID);

        if(strncmp("ThF4", sec_cmp_name, 4) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ThF4 cmp but no FLiBe cmp.\n");

            break;

        }

        sec_cmp = NextItem(sec_cmp);

    }

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            rto = (long)RDB[cmp + ADER_MAT_CMP_RTOS_PTR];

            sprintf(print_data, "FLiBeFuel has FLiBe cmp but no rtos.\n");

            while(rto > VALID_PTR)
            {

                sprintf(print_data, "ThF4 index not found in FLiBe cmp rtos 2nd grp ptrs in FLiBeFuel.\n");

                sec_cmp_ptr = (long)RDB[rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

                if(sec_cmp == sec_cmp_ptr)
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                    break;

                }

                rto = NextItem(rto);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpRtoMax()
{
    char *const test_name = "ADERProcessAderMatCmpRtoMax";
    char *cmp_name, *sec_cmp_name, *mat_name;
    char status[5], print_data[256];
    double rto_max;
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, rto, sec_cmp, sec_cmp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpRtoMax.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

    sec_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(sec_cmp > VALID_PTR)
    {

        sec_cmp_name = GetText(sec_cmp + ADER_MAT_CMP_ID);

        if(strncmp("ThF4", sec_cmp_name, 4) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ThF4 cmp but no FLiBe cmp.\n");

            break;

        }

        sec_cmp = NextItem(sec_cmp);

    }

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            rto = (long)RDB[cmp + ADER_MAT_CMP_RTOS_PTR];

            sprintf(print_data, "FLiBeFuel has FLiBe cmp but no rtos.\n");

            while(rto > VALID_PTR)
            {

                sprintf(print_data, "ThF4 index not found in FLiBe cmp rtos 2nd grp ptrs in FLiBeFuel.\n");

                sec_cmp_ptr = (long)RDB[rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

                rto_max = RDB[rto + ADER_MAT_CMP_RTO_MAX];

                if(sec_cmp == sec_cmp_ptr)
                {

                    sprintf(print_data, "FLiBe cmp has rto pointing to ThF4 but bad max.\n");

                    if(rto_max < 99.000001 && rto_max > 98.999999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                        break;

                    }

                }

                rto = NextItem(rto);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpRtoMin()
{
    char *const test_name = "ADERProcessAderMatCmpRtoMin";
    char *cmp_name, *sec_cmp_name, *mat_name;
    char status[5], print_data[256];
    double rto_min;
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, rto, sec_cmp, sec_cmp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpRtoMin.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

    sec_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(sec_cmp > VALID_PTR)
    {

        sec_cmp_name = GetText(sec_cmp + ADER_MAT_CMP_ID);

        if(strncmp("ThF4", sec_cmp_name, 4) == 0)
        {

            sprintf(print_data, "FLiBeFuel has ThF4 cmp but no FLiBe cmp.\n");

            break;

        }

        sec_cmp = NextItem(sec_cmp);

    }

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            rto = (long)RDB[cmp + ADER_MAT_CMP_RTOS_PTR];

            sprintf(print_data, "FLiBeFuel has FLiBe cmp but no rtos.\n");

            while(rto > VALID_PTR)
            {

                sprintf(print_data, "ThF4 index not found in FLiBe cmp rtos 2nd grp ptrs in FLiBeFuel.\n");

                sec_cmp_ptr = (long)RDB[rto + ADER_MAT_CMP_RTO_2ND_GRP_PTR];

                rto_min = RDB[rto + ADER_MAT_CMP_RTO_MIN];

                if(sec_cmp == sec_cmp_ptr)
                {

                    sprintf(print_data, "FLiBe cmp has rto pointing to ThF4 but bad min.\n");

                    if(rto_min < 4.000001 && rto_min > 3.999999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                        break;

                    }

                }

                rto = NextItem(rto);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpSumGrpsPtr()
{
    char *const test_name = "ADERProcessAderMatCmpSumGrpsPtr";
    char *cmp_name, *sum_cmp_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, sum, sum_cmp, sum_cmp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpSumGrpsPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

    sum_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(sum_cmp > VALID_PTR)
    {

        sum_cmp_name = GetText(sum_cmp + ADER_MAT_CMP_ID);

        if(strncmp("Uranium", sum_cmp_name, 7) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Uraniium cmp but no ActF cmp.\n");

            break;

        }

        sum_cmp = NextItem(sum_cmp);

    }

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("ActF", cmp_name, 4) == 0)
        {

            sum = (long)RDB[cmp + ADER_MAT_CMP_SUM_GRPS_PTR];

            sprintf(print_data, "FLiBeFuel has FLiBe cmp but no sum groups.\n");

            while(sum > VALID_PTR)
            {

                sprintf(print_data, "Uranium index not found in ActF cmp sum grps ptrs in FLiBeFuel.\n");

                sum_cmp_ptr = (long)RDB[sum + ADER_MAT_GRP_SUM_GRP_PTR];

                if(sum_cmp == sum_cmp_ptr)
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                    break;

                }

                sum = NextItem(sum);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCmpSumGrpWeight()
{
    char *const test_name = "ADERProcessAderMatCmpSumGrpWeight";
    char *cmp_name, *sum_cmp_name, *mat_name;
    char status[5], print_data[256];
    double sum_cmp_weight;
    int append = 0;
    int boolean = 0;
    long cmp, mat, mat_ader_data, sum, sum_cmp, sum_cmp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCmpSumGrpWeight.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

    sum_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(sum_cmp > VALID_PTR)
    {

        sum_cmp_name = GetText(sum_cmp + ADER_MAT_CMP_ID);

        if(strncmp("Uranium", sum_cmp_name, 7) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Uranium cmp but no ActF cmp.\n");

            break;

        }

        sum_cmp = NextItem(sum_cmp);

    }

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("ActF", cmp_name, 4) == 0)
        {

            sum = (long)RDB[cmp + ADER_MAT_CMP_SUM_GRPS_PTR];

            sprintf(print_data, "FLiBeFuel has FLiBe cmp but no sum groups.\n");

            while(sum > VALID_PTR)
            {

                sprintf(print_data, "Uranium index not found in ActF cmp sum grps ptrs in FLiBeFuel.\n");

                sum_cmp_ptr = (long)RDB[sum + ADER_MAT_GRP_SUM_GRP_PTR];

                sum_cmp_weight = RDB[sum + ADER_MAT_GRP_SUM_GRP_WEIGHT];

                if(sum_cmp == sum_cmp_ptr)
                {

                    sprintf(print_data, "Uranium sum group in ActF FLiBeFuel cmp group has bad weight.\n");

                    if(sum_cmp_weight < 1.000001 && sum_cmp_weight > 0.9999999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                sum = NextItem(sum);
            }

            break;
        }

        cmp = NextItem(cmp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCndPtr()
{
    char *const test_name = "ADERProcessAderMatCndPtr";
    char *cnd_id, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data, cnd, cnd_ptr, mat, mat_ader_data, mat_cnd;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCndPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "cnd table FLiBeFuel not found. \n");

    ader_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ader_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {

        cnd_id = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_id, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel not found.\n");

            break;

        }

        cnd = NextItem(cnd);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no cnd entries.\n");

            break;

        }

        mat = NextItem(mat);
    }


    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cnd = (long)RDB[mat_ader_data + ADER_MAT_CNDS_PTR];

    while(mat_cnd > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel cnd group 'FLiBeFuel not found.\n");

        cnd_ptr = (long)RDB[mat_cnd + ADER_MAT_CND_PTR];

        cnd_id = GetText(mat_cnd + ADER_MAT_CND_ID);

        if(strncmp("FLiBeFuel", cnd_id, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has cnd FLiBeFuel but bad pointer");

            if(cnd_ptr == cnd)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        mat_cnd = NextItem(mat_cnd);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatCntTblPtr()
{
    char *const test_name = "ADERProcessAderMatCntTblPtr";
    char *cnt_id, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long cnt_ptr, mat, mat_ader_data, mat_cnt;

    fprintf(outp, "Begin: Test_ADERProcessAderMatCntTblPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no CNT tables.\n");

            break;

        }

        mat = NextItem(mat);
    }


    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_cnt = (long)RDB[mat_ader_data + ADER_MAT_CNT_TBLS_PTR];

    while(mat_cnt > VALID_PTR)
    {

        sprintf(print_data, "Material FLiBeFuel cnt tables do not have table named '001'.\n");

        cnt_ptr = (long)RDB[mat_cnt + ADER_MAT_CNT_TBL_PTR];

        cnt_id = GetText(cnt_ptr + ADER_CONTROL_TBL_ID);

        if(strncmp("001", cnt_id, 3) == 0)
        {

            memset(print_data, 0, strlen(print_data));

            boolean = 1;

            break;

        }

        mat_cnt = NextItem(mat_cnt);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatIsoPtr()
{
    char *const test_name = "ADERProcessAderMatIsoPtr";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long iso, iso_ptr, mat, mat_ader_data, mat_iso, nuc, zai;

    fprintf(outp, "Begin: Test_ADERProcessAderMatIsoPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no Li-7 isotope.\n");

            break;

        }

        mat = NextItem(mat);
    }

    iso = (long)RDB[mat + MATERIAL_PTR_COMP];

    while(iso > VALID_PTR)
    {

        nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

        zai = (long)RDB[nuc + NUCLIDE_ZAI];

        if(zai == 30070)
        {

            sprintf(print_data, "Material FLiBeFuel has no MAT_ISO_PTR for Li-7.\n");

            break;

        }

        iso = NextItem(iso);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        iso_ptr = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        if(iso_ptr == iso)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOptDir()
{
    char *const test_name = "ADERProcessAderMatOptDir";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_opt, mat_opt_dir;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOptDir.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    mat_opt_dir = (long)RDB[mat_opt + ADER_MAT_OPT_DIR];

    sprintf(print_data, "Material Lithium7 has bad opt dir of %ld.\n",
            mat_opt_dir);

    if(mat_opt_dir < 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOptType()
{
    char *const test_name = "ADERProcessAderMatOptType";
    char *mat_name, *mat_opt_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_opt;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOptType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    mat_opt_type = GetText(mat_opt + ADER_MAT_OPT_TYPE);

    sprintf(print_data, "Material Lithium7 has bad opt type of %s.\n",
            mat_opt_type);

    if(strncmp("action", mat_opt_type, 6) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOptTypeTarget()
{
    char *const test_name = "ADERProcessAderMatOptTypeTarget";
    char *mat_name, *mat_opt_target;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_opt;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOptTypeTarget.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Lithium7 not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Lithium7", mat_name, 8) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    mat_opt_target = GetText(mat_opt + ADER_MAT_OPT_TYPE_TARGET);

    sprintf(print_data, "Material Lithium7 has bad opt type of %s.\n",
            mat_opt_target);

    if(strncmp("feed", mat_opt_target, 4) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOxiMax()
{
    char *const test_name = "ADERProcessAderMatOxiMax";
    char *mat_name;
    char status[5], print_data[256];
    double oxi_max;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_oxi;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOxiMax.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    oxi_max = RDB[mat_oxi + ADER_MAT_OXI_MAX];

    sprintf(print_data, "Material FLiBeFuel has bad oxi max of %f.\n",
            oxi_max);

    if((oxi_max < 0.001000001) && (oxi_max > 0.0009999999))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOxiMin()
{
    char *const test_name = "ADERProcessAderMatOxiMin";
    char *mat_name;
    char status[5], print_data[256];
    double oxi_min;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_oxi;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOxiMin.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    oxi_min = (long)RDB[mat_oxi + ADER_MAT_OXI_MIN];

    sprintf(print_data, "Material FLiBeFuel has bad oxi max of %f.\n",
            oxi_min);

    if((oxi_min < 0.000000001) && (oxi_min > -0.000000001))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatOxiTblPtr()
{
    char *const test_name = "ADERProcessAderMatOxiTblPtr";
    char *ader_oxi_id, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data, ader_oxi, mat, mat_ader_data, mat_oxi, mat_oxi_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatOxiTblPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_oxi = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    mat_oxi_ptr = (long)RDB[mat_oxi + ADER_MAT_OXI_TBL_PTR];

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_oxi = (long)RDB[ader_data + ADER_OXIS_PTR];

    sprintf(print_data, "ADER oxidation table '002' not found. \n");

    while(ader_oxi > VALID_PTR)
    {

        ader_oxi_id = GetText(ader_oxi + ADER_OXI_TBL_ID);

        if(strncmp("002", ader_oxi_id, 3) == 0)
        {

            sprintf(print_data, "Material oxidation ptr does not match ADER oxidation table '002' index. \n");

            if(ader_oxi == mat_oxi_ptr)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        ader_oxi = NextItem(ader_oxi);
    }
    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatPreserveType()
{
    char *const test_name = "ADERProcessAderMatPreserveType";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_preserve_ent;

    fprintf(outp, "Begin: Test_ADERProcessAderMatPreserveType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_preserve_ent = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    sprintf(print_data, "Material FLiBeFuel has no preserve entries. \n");

    while(mat_preserve_ent > VALID_PTR)
    {

        if(strncmp("mols", GetText(mat_preserve_ent + ADER_MAT_PRESERVE_ENT), 4) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        mat_preserve_ent = NextItem(mat_preserve_ent);

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmDest()
{
    char *const test_name = "ADERProcessAderMatStrmDest";
    char *mat_name, *strm_dest, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmDest.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe stream but bad destination.\n");

            strm_dest = GetText(strm + ADER_MAT_STREAM_DEST);

            if(strncmp("FLiBeFuel", strm_dest, 9) == 0)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmEleFix()
{
    char *const test_name = "ADERProcessAderMatStrmEleFix";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_ele;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmEleFix.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Beryllium redox group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("Beryllium", strm_id, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Beryllium stream but no elements.\n");

            strm_ele = (long)RDB[strm + ADER_MAT_STREAM_ELES_PTR];

            while(strm_ele > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel has Beryllium stream but no Be element.\n");

                if((long)RDB[strm_ele + ADER_MAT_GRP_ELE_Z] == 4)
                {

                    sprintf(print_data, "FLiBeFuel has Beryllium stream but the Be element has bad fix value.\n");

                    if((long)RDB[strm_ele + ADER_MAT_GRP_ELE_ISO_FIXED] > 0)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_ele = NextItem(strm_ele);

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmEleFrac()
{
    char *const test_name = "ADERProcessAderMatStrmEleFrac";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double mat_strm_ele_frac;
    int append = 0;
    int boolean = 0;
    long ele, ele_Z, mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmEleFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe stream group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if((strncmp("FLiBe", strm_id, 5) == 0))
        {

            sprintf(print_data, "FLiBeFuel has FLiBe feed stream but no elements.\n");

            ele = (long)RDB[strm + ADER_MAT_STREAM_ELES_PTR];

            while(ele > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe stream has elements but no F.\n");

                ele_Z = (long)RDB[ele + ADER_MAT_GRP_ELE_Z];

                mat_strm_ele_frac = RDB[ele + ADER_MAT_GRP_ELE_FRAC];

                if(ele_Z == 9)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe stream has F but bad frac.\n");

                    if(mat_strm_ele_frac < 0.541798 && mat_strm_ele_frac > 0.541796)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;
                }

                ele = NextItem(ele);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmFeedType()
{
    char *const test_name = "ADERProcessAderMatStrmFeedType";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmFeedType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmForm()
{
    char *const test_name = "ADERProcessAderMatStrmForm";
    char *mat_name, *strm_form, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmForm.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            strm_form = GetText(strm + ADER_MAT_STREAM_FORM);

            if(strncmp("disc", strm_form, 4) == 0)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

                break;

            }

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmIsoEleFrac()
{
    char *const test_name = "ADERProcessAderMatStrmIsoEleFrac";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double mat_strm_iso_frac;
    int append = 0;
    int boolean = 0;
    long iso, iso_ZAI, mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderStrmIsoEleFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no stream grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe stream group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if((strncmp("FLiBe", strm_id, 5) == 0))
        {

            sprintf(print_data, "FLiBeFuel has FLiBe removal stream but no isotopes.\n");

            iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe removal stream has isotopes but no Li-7.\n");

                iso_ZAI = (long)RDB[iso + ADER_MAT_GRP_ISO_ZAI];

                mat_strm_iso_frac = RDB[iso +ADER_MAT_GRP_ISO_ELE_FRAC];

                if(iso_ZAI == 30070)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe removal stream has Li-7 but bad frac.\n");

                    if(mat_strm_iso_frac < 0.999001 && mat_strm_iso_frac > 0.998999)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;
                }

                iso = NextItem(iso);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmIsoFrac()
{
    char *const test_name = "ADERProcessAderMatStrmIsoFrac";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double mat_strm_iso_frac;
    int append = 0;
    int boolean = 0;
    long iso, iso_ZAI, mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderStrmIsoFrac.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no stream grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe stream group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if((strncmp("FLiBe", strm_id, 5) == 0))
        {

            sprintf(print_data, "FLiBeFuel has FLiBe removal stream but no isotopes.\n");

            iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe removal stream has isotopes but no Li-6.\n");

                iso_ZAI = (long)RDB[iso + ADER_MAT_GRP_ISO_ZAI];

                mat_strm_iso_frac = RDB[iso + ADER_MAT_GRP_ISO_FRAC];

                if(iso_ZAI == 30060)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe removal stream has Li-6 but bad frac %f, needs frac %f.\n",
                            mat_strm_iso_frac, 0.0003746);

                    if(mat_strm_iso_frac < 0.0003747 && mat_strm_iso_frac > 0.0003745)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;
                }

                iso = NextItem(iso);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmMatPtr()
{
    char *const test_name = "ADERProcessAderMatStrmMatPtr";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmMatPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the target group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            strm_ptr = (long)RDB[strm + ADER_MAT_STREAM_MAT_PTR];

            sprintf(print_data, "FLiBeFuel stream has bad pointer to FLiBeFuel.\n");

            if(strm_ptr == mat)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmPtr()
{
    char *const test_name = "ADERProcessAderMatStrmPtr";
    char *ader_strm_dest, *ader_strm_grp, *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ader_strm, mat, mat_ader_data, strm, strm_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the target group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    ader_strm = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    while(ader_strm > VALID_PTR)
    {

        ader_strm_grp = GetText(ader_strm + ADER_STREAM_GRP_ID);

        ader_strm_dest = GetText(ader_strm + ADER_STREAM_DEST);

        if((strncmp("FLiBe", ader_strm_grp, 5) == 0) &&
           (strncmp("FLiBeFuel", ader_strm_dest, 9) == 0))
        {

            break;

        }

        ader_strm = NextItem(ader_strm);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            strm_ptr = (long)RDB[strm + ADER_MAT_STREAM_PTR];

            sprintf(print_data, "FLiBeFuel stream has bad pointer to group.\n");

            if(strm_ptr == ader_strm)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmRedoxType()
{
    char *const test_name = "ADERProcessAderMatStrmRedoxType";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmRedoxType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Lithium feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("Lithium", strm_id, 7) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmRemvGroup()
{
    char *const test_name = "ADERProcessAderMatStrmRemvGroup";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmRemvGroup.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no reproc stream.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmRemvType()
{
    char *const test_name = "ADERProcessAderMatStrmRemvType";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmRemvType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe removal group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmReacType()
{
    char *const test_name = "ADERProcessAderMatStrmReacType";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmReacType.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Thorium reactivity group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("Thorium", strm_id, 7) == 0)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmShadowPtr()
{
    char *const test_name = "ADERProcessAderMatStrmShadowPtr";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, shadow_ptr, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmShadowPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "Argon40 has no reproc stream.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            shadow_ptr = (long)RDB[strm + ADER_MAT_STREAM_SHADOW_PTR];

            break;

        }

        strm = NextItem(strm);

    }

    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no reproc stream.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "Mismatch between Argon40 shadow ptr, %ld, \n \
and FLiBeFuel reproc ptr of %ld.\n", shadow_ptr, strm);

            if(shadow_ptr == strm)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmShadowSumStrmPtr()
{
    char *const test_name = "ADERProcessAderMatStrmShadowSumStrmPtr";
    char *strm_name, *strm_sum_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, shadow_sum_strm_ptr, strm, strm_sum, strm_sum_ent;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmShadowSumStrmPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "ActF removal stream found but has no sum streams.\n");

            strm_sum_ent = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(strm_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "ActF removal stream sum streams found but has no sum stream 'Uranium'.\n");

                strm_sum_name = GetText(strm_sum_ent + ADER_MAT_GRP_SUM_GRP_ID);

                if(strncmp("Uranium", strm_sum_name, 7) == 0)
                {

                    strm_sum = (long)RDB[strm_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    sprintf(print_data, "Argon40 material not found.\n");

                    shadow_sum_strm_ptr = -(long)RDB[strm_sum + ADER_MAT_STREAM_SHADOW_PTR];

                    break;

                }

                strm_sum_ent = NextItem(strm_sum_ent);

            }

            break;

        }

        strm = NextItem(strm);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material Argon40.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "ActF feed stream found but has no sum streams.\n");

            strm_sum_ent = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(strm_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "ActF feed stream sum streams found but has no sum stream 'Uranium'.\n");

                strm_sum_name = GetText(strm_sum_ent + ADER_MAT_GRP_SUM_GRP_ID);

                if(strncmp("Uranium", strm_sum_name, 7) == 0)
                {

                    strm_sum = (long)RDB[strm_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    sprintf(print_data, "Argon40 ActF feed stream sum group 'Uranium' has index %ld \n\
while ActF removal stream sum group Uranium in FLiBeFuel has index %ld.\n",
                            strm_sum, shadow_sum_strm_ptr);

                    if(strm_sum == shadow_sum_strm_ptr)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                strm_sum_ent = NextItem(strm_sum_ent);

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmSrc()
{
    char *const test_name = "ADERProcessAderMatStrmSrc";
    char *mat_name, *strm_id, *strm_src;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmSrc.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe stream but bad source.\n");

            strm_src = GetText(strm + ADER_MAT_STREAM_SRC);

            if(strncmp("FLiBeFuel", strm_src, 9) == 0)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmSumGrpsPtr()
{
    char *const test_name = "ADERProcessAderMatStrmSumGrpsPtr";
    char *mat_name, *strm_id, *sum_strm_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, sum, sum_strm_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmSumGrpsPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_id, 4) == 0)
        {

            sum = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            sprintf(print_data, "FLiBeFuel has ActF stream but no sum groups.\n");

            while(sum > VALID_PTR)
            {

                sprintf(print_data, "Uranium stream not found in ActF stream sum grps ptrs in FLiBeFuel.\n");

                sum_strm_ptr = (long)RDB[sum + ADER_MAT_GRP_SUM_GRP_PTR];

                sum_strm_name = GetText(sum_strm_ptr + ADER_MAT_STREAM_ID);

                if(strncmp("Uranium", sum_strm_name, 7) == 0)
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                    break;

                }

                sum = NextItem(sum);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmTypeGroup()
{
    char *const test_name = "Test_ADERProcessAderMatStrmTypeGroup";
    char *mat_name, *strm_grp_type, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmTypeGroup.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_id, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe stream but bad group type.\n");

            strm_grp_type = GetText(strm + ADER_MAT_STREAM_TYPE);

            if(strncmp("group", strm_grp_type, 3) == 0)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderMatStrmTypeRem()
{
    char *const test_name = "Test_ADERProcessAderMatStrmTypeRem";
    char *mat_name, *strm_grp_type, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERProcessAderMatStrmTypeRem.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no reproc removal group.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "FLiBeFuel has reproc stream but bad group type.\n");

            strm_grp_type = GetText(strm + ADER_MAT_STREAM_TYPE);

            if(strcmp("rem", strm_grp_type) == 0)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderReproElement()
{
    char *const test_name = "ADERProcessAderReproElement";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double strm_ele_val;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_ele, strm_ele_z;

    fprintf(outp, "Begin: Test_ADERProcessAderReproElement.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in FLiBeFuel has no elements.\n");

            strm_ele = (long)RDB[strm + ADER_MAT_STREAM_ELES_PTR];

            while(strm_ele > VALID_PTR)
            {

                strm_ele_z = (long)RDB[strm_ele + ADER_MAT_GRP_ELE_Z];

                if(strm_ele_z == 1)
                {

                    sprintf(print_data, "'reproc' stream in FLiBeFuel has H but bad val.\n");

                    strm_ele_val = RDB[strm_ele + ADER_MAT_GRP_ELE_FRAC];

                    if(strm_ele_val <= 0.400001 && strm_ele_val >= 0.3999999)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_ele = NextItem(strm_ele);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderReproIsoEle()
{
    char *const test_name = "ADERProcessAderReproIsoEle";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_ele, strm_ele_z;

    fprintf(outp, "Begin: Test_ADERProcessAderReproIsoEle.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc2", strm_id, 7) == 0)
        {

            sprintf(print_data, "'reproc2' stream in FLiBeFuel has no elements.\n");

            strm_ele = (long)RDB[strm + ADER_MAT_STREAM_ELES_PTR];

            while(strm_ele > VALID_PTR)
            {

                strm_ele_z = (long)RDB[strm_ele + ADER_MAT_GRP_ELE_Z];

                if(strm_ele_z == 94)
                {

					memset(print_data, 0, strlen(print_data));

					boolean = 1;

                }

                strm_ele = NextItem(strm_ele);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderReproIsotope()
{
    char *const test_name = "ADERProcessAderReproIsotope";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double strm_iso_val;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_iso, strm_iso_zai;

    fprintf(outp, "Begin: Test_ADERProcessAderReproIsotope.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in FLiBeFuel has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                strm_iso_zai = (long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI];

                if(strm_iso_zai == 942390)
                {

                    sprintf(print_data, "'reproc' stream in FLiBeFuel has Pu-239 but bad val of %f.\n",
                            RDB[strm_iso + ADER_MAT_GRP_ISO_FRAC]);

                    strm_iso_val = RDB[strm_iso + ADER_MAT_GRP_ISO_FRAC];

                    if(strm_iso_val <= 0.300001 && strm_iso_val >= 0.2999999)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderStreamSourcesAndDests()
{
    char *const test_name = "ADERProcessAderStreamSourcesAndDests";
    char *strm_id, *strm_src;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ader_data, ader_strm;

    fprintf(outp, "Begin: Test_ADERProcessAderStreamSourcesAndDests.\n");

    /*Clear the print_data */
    sprintf(print_data, "Beryllium stream not found. \n");

    ader_data = (long)RDB[DATA_PTR_ADER];

    ader_strm = (long)RDB[ader_data + ADER_STREAMS_PTR];

    while(ader_strm > VALID_PTR)
    {

        strm_id = GetText(ader_strm + ADER_STREAM_GRP_ID);

        if(strncmp(strm_id, "Beryllium", 9) == 0)
        {

            sprintf(print_data, "Beryllium stream found but has no null source.\n");

            strm_src = GetText(ader_strm + ADER_STREAM_SRC);

            if(strncmp(strm_src, "NULL", 4) == 0)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;
        }

        ader_strm = NextItem(ader_strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessAderSumGrpPtr()
{
    char *const test_name = "ADERProcessAderSumGrpPtr";
    char *grp_name, *sgrp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, grp, sgrp, sgrp_ptr;

    fprintf(outp, "Begin: Test_ADERProcessAderSumGrpPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("NestedSum", grp_name, 9) == 0)
        {

            break;

        }

        grp = NextItem(grp);
    }

    sgrp = (long)RDB[grp + ADER_GRP_SUM_GRPS_PTR];

    while(sgrp > VALID_PTR)
    {

        sgrp_name = GetText(sgrp + ADER_GRP_SUM_GRP_ID);

        if(strncmp("ActF", sgrp_name, 4) == 0)
        {

            sgrp_ptr = (long)RDB[sgrp + ADER_GRP_SUM_GRP_PTR];

            /* Get actual instance of group that sum_grp_ptr should point to */
            grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

            while(grp > VALID_PTR)
            {
                grp_name = GetText(grp + ADER_GRP_ID);

                if(strncmp("ActF", grp_name, 4) == 0)
                {

                    break;

                }

                grp = NextItem(grp);
            }

            sprintf(print_data, "ADER_SUM_GRP_PTR for ActF element of \
                                 NestedSum points to %ld while ActF \
                                 has grp ptr of %ld.\n", sgrp_ptr, grp);

            if(grp == sgrp_ptr)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;
        }

        sgrp = NextItem(sgrp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatClusterOpt()
{
    char *const test_name = "ADERProcessMatClusterOpt";
    char *mat_name, *mat_opt_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_opt;

    fprintf(outp, "Begin: Test_ADERProcessMatClusterOpt.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no opt entry. \n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    mat_opt_type = GetText(mat_opt + ADER_MAT_OPT_TYPE);

    sprintf(print_data, "Material FLiBeFuel has bad opt type of %s.\n",
            mat_opt_type);

    if(strncmp("spec_stream", mat_opt_type, 11) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatCmpIsoMatAderIsoPtr()
{
    char *const test_name = "ADERProcessMatCmpIsoMatAderIsoPtr";
    char *cmp_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long cmp, cmp_iso, cmp_iso_mat_ader_iso_ptr, mat, mat_ader_data, mat_iso;
    long iso, iso_ZAI, nuc;

    fprintf(outp, "Begin: Test_ADERProcessMatCmpIsoMatAderIsoPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no composition grps.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe cmp group.\n");

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe group but no isotopes.\n");

            cmp_iso = (long)RDB[cmp + ADER_MAT_CMP_ISOS_PTR];

            while(cmp_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has isotopes but no Li-6.\n");

                iso_ZAI = (long)RDB[cmp_iso + ADER_MAT_GRP_ISO_ZAI];

                cmp_iso_mat_ader_iso_ptr = RDB[cmp_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

                if(iso_ZAI == 30060)
                {

                    sprintf(print_data, "FLiBeFuel has no mat ader isos.\n");

                    break;

                }

                cmp_iso = NextItem(cmp_iso);
            }

            break;
        }

        cmp = NextItem(cmp);

    }

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has mat ader isos but no Li-6 iso.\n");

        iso = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            sprintf(print_data, "FLiBeFuel has mat ader isos Li-6 but index, %ld, does not match\n \
cmp iso ptr of %ld.\n", mat_iso, cmp_iso_mat_ader_iso_ptr);

            if(mat_iso == cmp_iso_mat_ader_iso_ptr)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatReproEleIsoRate()
{
    char *const test_name = "ADERProcessMatReproEleIsoRate";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double strm_iso_val;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_iso, strm_iso_zai;

    fprintf(outp, "Begin: Test_ADERProcessMatReproEleIsoRate.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in FLiBeFuel has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                sprintf(print_data, "'reproc' stream in FLiBeFuel has no U-235.\n");

                strm_iso_zai = (long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI];

                if(strm_iso_zai == 922350)
                {

                    strm_iso_val = RDB[strm_iso + ADER_MAT_GRP_ISO_ELE_FRAC];

                    sprintf(print_data, "'reproc' stream in FLiBeFuel has U-235 but\n \
bad iso frac of %f and needs iso_frac of 0.0 .\n", strm_iso_val);

                    if(strm_iso_val < 0.000001 && strm_iso_val > -0.000001)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatReproIsoRate()
{
    char *const test_name = "ADERProcessMatReproIsoRate";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    double strm_iso_val;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_iso, strm_iso_zai;

    fprintf(outp, "Begin: Test_ADERProcessMatReproIsoRate.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "'reproc' stream in FLiBeFuel has no isotopes.\n");

            strm_iso = (long)RDB[strm + ADER_MAT_STREAM_ISOS_PTR];

            while(strm_iso > VALID_PTR)
            {

                sprintf(print_data, "'reproc' stream in FLiBeFuel has no U-233.\n");

                strm_iso_zai = (long)RDB[strm_iso + ADER_MAT_GRP_ISO_ZAI];

                if(strm_iso_zai == 922330)
                {

                    strm_iso_val = RDB[strm_iso + ADER_MAT_GRP_ISO_FRAC];

                    sprintf(print_data, "'reproc' stream in FLiBeFuel has U-233 but\n \
bad iso frac of %f and needs iso_frac of 0.4 .\n", strm_iso_val);

                    if(strm_iso_val <= 0.400001 && strm_iso_val >= 0.3999999)
                    {

                        memset(print_data, 0, strlen(print_data));

                        boolean = 1;

                    }

                    break;

                }

                strm_iso = NextItem(strm_iso);
            }

            break;
        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatStreamIsoMatAderIsoPtr()
{
    char *const test_name = "ADERProcessMatStreamIsoMatAderIsoPtr";
    char *stream_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long stream, stream_iso, stream_iso_mat_ader_iso_ptr, mat, mat_ader_data;
    long mat_iso, iso, iso_ZAI, nuc;

    fprintf(outp, "Begin: Test_ADERProcessMatStreamIsoMatAderIsoPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", stream_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe feed stream but no isotopes.\n");

            stream_iso = (long)RDB[stream + ADER_MAT_STREAM_ISOS_PTR];

            while(stream_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has isotopes but no Li-6.\n");

                iso_ZAI = (long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI];

                stream_iso_mat_ader_iso_ptr = RDB[stream_iso + ADER_MAT_GRP_MAT_ADER_ISO_PTR];

                if(iso_ZAI == 30060)
                {

                    sprintf(print_data, "FLiBeFuel has no mat ader isos.\n");

                    break;

                }

                stream_iso = NextItem(stream_iso);
            }

            break;
        }

        stream = NextItem(stream);

    }

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has mat ader isos but no Li-6 iso.\n");

        iso = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
        {

            sprintf(print_data, "FLiBeFuel has mat ader isos Li-6 but index, %ld, does not match\n \
cmp iso ptr of %ld.\n", mat_iso, stream_iso_mat_ader_iso_ptr);

            if(mat_iso == stream_iso_mat_ader_iso_ptr)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        mat_iso = NextItem(mat_iso);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatGrpEleIsoPtr()
{
    char *const test_name = "ADERProcessMatGrpEleIsoPtr";
    char *stream_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long stream, stream_ele, stream_ele_iso, stream_iso, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERProcessMatGrpEleIsoPtr.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no feed streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no FLiBe feed stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", stream_name, 5) == 0)
        {

            sprintf(print_data, "FLiBeFuel has FLiBe feed stream but no isotopes.\n");

            stream_iso = (long)RDB[stream + ADER_MAT_STREAM_ISOS_PTR];

            while(stream_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe group has isotopes but no Li-6.\n");

                if((long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI] == 30060)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe stream has no elements.\n");

                    break;

                }

                stream_iso = NextItem(stream_iso);
            }

            stream_ele = (long)RDB[stream + ADER_MAT_STREAM_ELES_PTR];

            while(stream_ele > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel FLiBe stream has elements but no Li.\n");

                if((long)RDB[stream_ele + ADER_MAT_GRP_ELE_Z] == 3)
                {

                    sprintf(print_data, "FLiBeFuel FLiBe stream has Li but no ele isos.\n");

                    stream_ele_iso = (long)RDB[stream_ele + ADER_MAT_GRP_ELE_ISOS_PTR];

                    while(stream_ele_iso > VALID_PTR)
                    {

                        sprintf(print_data, "FLiBeFuel FLiBe stream has Li and its isos but no Li-6 ptr.\n");

                        if((long)RDB[stream_ele_iso + ADER_MAT_GRP_ELE_ISO_PTR] == stream_iso)
                        {

                            boolean = 1;

                            memset(print_data, 0, strlen(print_data));

                            break;

                        }

                        stream_ele_iso = NextItem(stream_ele_iso);

                    }

                    break;

                }

                stream_ele = NextItem(stream_ele);

            }

            break;
        }

        stream = NextItem(stream);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERProcessMatStreamEleUnFixedIsos()
{
    char *const test_name = "ADERProcessMatStreamEleUnFixedIsos";
    char *stream_name, *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, stream, stream_iso, stream_iso_zai ;

    fprintf(outp, "Begin: Test_ADERProcessMatStreamEleUnFixedIsos.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no redox streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(stream > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no Beryllium redox stream.\n");

        stream_name = GetText(stream + ADER_MAT_STREAM_ID);

        if(strncmp("Beryllium", stream_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has Be redox stream but no isotopes.\n");

            stream_iso = (long)RDB[stream + ADER_MAT_STREAM_ISOS_PTR];

            while(stream_iso > VALID_PTR)
            {

                sprintf(print_data, "FLiBeFuel Be stream has isotopes but no Be-9.\n");

                stream_iso_zai = (long)RDB[stream_iso + ADER_MAT_GRP_ISO_ZAI];

                if(stream_iso_zai == 40090)
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                    break;

                }

                stream_iso = NextItem(stream_iso);
            }

            break;
        }

        stream = NextItem(stream);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderClusterMembers()
{
    char *const test_name = "ADERSetAderClusterMembers";
    char *ader_clus_ent_id, *ader_clus_parent_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    int booleanFLiBeFuel = 0;
    int booleanFluorine = 0;
    int booleanUranium = 0;
    long ader_clus, ader_clus_ent, ADER_data;

    fprintf(outp, "Begin: Test_ADERSetAderClusterMembers.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    ader_clus = (long)RDB[ADER_data + ADER_CLUSTERS_PTR];

    sprintf(print_data, "No ADER clusters found.\n");

    while(ader_clus > VALID_PTR)
    {

        sprintf(print_data, "No FLiBeFuel parent cluster found.\n");

        ader_clus_parent_id = GetText(ader_clus + ADER_CLUSTER_PARENT_ID);

        if(strncmp("FLiBeFuel", ader_clus_parent_id, 9) == 0)
        {

            ader_clus_ent = (long)RDB[ader_clus + ADER_CLUSTER_ENT_PTR];

            while(ader_clus_ent > VALID_PTR)
            {

                ader_clus_ent_id = GetText(ader_clus_ent + ADER_CLUSTER_ENT_ID);

                if(strncmp("FLiBeFuel", ader_clus_ent_id, 9) == 0)
                {

                    booleanFLiBeFuel = 1;

                }
                else if(strncmp("Fluorine0", ader_clus_ent_id, 9) == 0)
                {

                    booleanFluorine = 1;

                }
                else if(strncmp("Uranium233", ader_clus_ent_id, 10) == 0)
                {

                    booleanUranium = 1;

                }

                ader_clus_ent = NextItem(ader_clus_ent);

            }

            break;

        }

        ader_clus = NextItem(ader_clus);

    }

    if((booleanFLiBeFuel == 1) && (booleanFluorine == 1) && (booleanUranium == 1))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndCntId()
{
    char *const test_name = "ADERSetAderCndCntId";
    char *cnd_name, *cnt_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, cnt;

    fprintf(outp, "Begin: Test_ADERSetAderCndCntId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];


    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    cnt = (long)RDB[cnd + ADER_CND_CNT_PTR];

    cnt_name = GetText(cnt + ADER_CND_CNT_ID);

    sprintf(print_data, "Ader CND FLiBeFuel cnt group 001 not found. \n");

    if(strncmp("001", cnt_name, 3) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndId()
{
    char *const test_name = "ADERSetAderCndId";
    char *cnd_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd;

    fprintf(outp, "Begin: Test_ADERSetAderCndId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];


    sprintf(print_data, "ADER CND FLiBeFuel not found. \n");

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        cnd = NextItem(cnd);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOptDir()
{
    char *const test_name = "ADERSetAderCndOptDir";
    char *cnd_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, cnd_opt, cnd_opt_dir;

    fprintf(outp, "Begin: Test_ADERSetAderCndOptDir.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];


    sprintf(print_data, "ADER CND LiF not found. \n");

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("LiF", cnd_name, 3) == 0)
        {

            sprintf(print_data, "ADER CND LiF has no optimization entry or bad direction.\n");

            break;
        }

        cnd = NextItem(cnd);
    }

    cnd_opt = (long)RDB[cnd + ADER_CND_OPT_PTR];

    cnd_opt_dir = (long)RDB[cnd_opt + ADER_CND_OPT_DIR];

    if(cnd_opt_dir < 0 )
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOptTarget()
{
    char *const test_name = "ADERSetAderCndOptTarget";
    char *cnd_name, *cnd_opt_target;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, cnd_opt;

    fprintf(outp, "Begin: Test_ADERSetAderCndOptTarget.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];


    sprintf(print_data, "ADER CND LiF not found. \n");

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("LiF", cnd_name, 3) == 0)
        {

            sprintf(print_data, "ADER CND LiF has no optimization entry or bad target.\n");

            break;
        }

        cnd = NextItem(cnd);
    }

    cnd_opt = (long)RDB[cnd + ADER_CND_OPT_PTR];

    cnd_opt_target = GetText(cnd_opt + ADER_CND_OPT_TYPE_TARGET);

    if(strncmp("feed", cnd_opt_target, 4) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOptType()
{
    char *const test_name = "ADERSetAderCndOptType";
    char *cnd_name, *cnd_opt_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, cnd_opt;

    fprintf(outp, "Begin: Test_ADERSetAderCndOptType.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];


    sprintf(print_data, "ADER CND LiF not found. \n");

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("LiF", cnd_name, 3) == 0)
        {

            sprintf(print_data, "ADER CND LiF has no optimization entry or bad type.\n");

            break;
        }

        cnd = NextItem(cnd);
    }

    cnd_opt = (long)RDB[cnd + ADER_CND_OPT_PTR];

    cnd_opt_type = GetText(cnd_opt + ADER_CND_OPT_TYPE);

    if(strncmp("action", cnd_opt_type, 6) == 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOxiId()
{
    char *const test_name = "ADERSetAderCndOxiId";
    char *cnd_name, *oxi_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, oxi;

    fprintf(outp, "Begin: Test_ADERSetAderCndOxiId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    oxi = (long)RDB[cnd + ADER_CND_OXI_PTR];

    oxi_name = GetText(oxi + ADER_CND_OXI_ID);

    sprintf(print_data, "Ader CND FLiBeFuel oxi group 001 not found. \n");

    if(strncmp("002", oxi_name, 3) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOxiMax()
{
    char *const test_name = "ADERSetAderCndOxiMax";
    char *cnd_name, *oxi_name;
    char status[5], print_data[256];
    double cnd_oxi_max;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, oxi;

    fprintf(outp, "Begin: Test_ADERSetAderCndOxiMax.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {

        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {

            break;

        }

        cnd = NextItem(cnd);
    }

    oxi = (long)RDB[cnd + ADER_CND_OXI_PTR];

    oxi_name = GetText(oxi + ADER_CND_OXI_ID);

    sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 not found. \n");

    if(strncmp("002", oxi_name, 3) == 0)
    {

        sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 has bad max. \n");

        cnd_oxi_max = RDB[oxi + ADER_CND_OXI_MAX];

        if(cnd_oxi_max < 0.0010001 && cnd_oxi_max >0.00099999)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

        }

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOxiMin()
{
    char *const test_name = "ADERSetAderCndOxiMin";
    char *cnd_name, *oxi_name;
    char status[5], print_data[256];
    double cnd_oxi_min;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, oxi;

    fprintf(outp, "Begin: Test_ADERSetAderCndOxiMin.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {

        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {

            break;

        }

        cnd = NextItem(cnd);
    }

    oxi = (long)RDB[cnd + ADER_CND_OXI_PTR];

    oxi_name = GetText(oxi + ADER_CND_OXI_ID);

    sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 not found. \n");

    if(strncmp("002", oxi_name, 3) == 0)
    {

        sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 has bad min. \n");

        cnd_oxi_min = RDB[oxi + ADER_CND_OXI_MIN];

        if(cnd_oxi_min < 0.0000001 && cnd_oxi_min > -0.00000001)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

        }

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndOxiVal()
{
    char *const test_name = "ADERSetAderCndOxiVal";
    char *cnd_name, *oxi_name;
    char status[5], print_data[256];
    double cnd_oxi_val;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, oxi;

    fprintf(outp, "Begin: Test_ADERSetAderCndOxiVal.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {

        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("LiF", cnd_name, 3) == 0)
        {

            break;

        }

        cnd = NextItem(cnd);
    }

    oxi = (long)RDB[cnd + ADER_CND_OXI_PTR];

    oxi_name = GetText(oxi + ADER_CND_OXI_ID);

    sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 not found. \n");

    if(strncmp("002", oxi_name, 3) == 0)
    {

        sprintf(print_data, "Ader CND FLiBeFuel oxi group 002 has bad value. \n");

        cnd_oxi_val = RDB[oxi + ADER_CND_OXI_MAX];

        if(cnd_oxi_val < 0.00020001 && cnd_oxi_val > 0.000199999)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

        }

    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndPreserveType()
{
    char *const test_name = "ADERSetAderCndPreserveType";
    char *cnd_name, *pres_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, pres;

    fprintf(outp, "Begin: Test_ADERSetAderCndPreserveType.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    sprintf(print_data, "ADER CND FLiBeFuel not found. \n");

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {

            pres = (long)RDB[cnd + ADER_CND_PRES_PTR];

            while(pres > VALID_PTR)
            {

                pres_type = GetText(pres + ADER_CND_PRES_ENT);

                if(strncmp("mols", pres_type, 4) == 0)
                {

                    memset(print_data, 0, strlen(print_data));

                    boolean = 1;

                    break;

                }

                pres = NextItem(pres);
            }

            break;

        }

        cnd = NextItem(cnd);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRngGrpId()
{
    char *const test_name = "ADERSetAderCndRngGrpId";
    char *cnd_name, *rng_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rng;

    fprintf(outp, "Begin: Test_ADERSetAderCndRngGrpId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rng = (long)RDB[cnd + ADER_CND_RNGS_PTR];

    sprintf(print_data, "Ader RNG FLiBe in CNT FLiBeFuel not found.\n");

    while(rng > VALID_PTR)
    {
        rng_name = GetText(rng + ADER_CND_RNG_GRP_ID);

        if(strncmp("FLiBe", rng_name, 5) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        rng = NextItem(rng);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRngMax()
{
    char *const test_name = "ADERSetAderCndRngMax";
    char *cnd_name, *rng_name;
    char status[5], print_data[256];
    double rng_max;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rng;

    fprintf(outp, "Begin: Test_ADERSetAderCndRngMax.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rng = (long)RDB[cnd + ADER_CND_RNGS_PTR];

    while(rng > VALID_PTR)
    {
        rng_name = GetText(rng + ADER_CND_RNG_GRP_ID);

        if(strncmp("FLiBe", rng_name, 5) == 0)
        {
            rng_max = RDB[rng + ADER_CND_RNG_MAX];
            sprintf(print_data, "Rng max is %f, not 1.0 for \
                                rng FLiBe in CND FliBeFuel.\n",
                    rng_max);
            break;
        }

        rng = NextItem(rng);
    }

    if(rng_max < 1.000001 && rng_max > 0.999999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRngMin()
{
    char *const test_name = "ADERSetAderCndRngMin";
    char *cnd_name, *rng_name;
    char status[5], print_data[256];
    double rng_min;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rng;

    fprintf(outp, "Begin: Test_ADERSetAderCndRngMin.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rng = (long)RDB[cnd + ADER_CND_RNGS_PTR];

    while(rng > VALID_PTR)
    {
        rng_name = GetText(rng + ADER_CND_RNG_GRP_ID);

        if(strncmp("FLiBe", rng_name, 5) == 0)
        {
            rng_min = RDB[rng + ADER_CND_RNG_MIN];
            sprintf(print_data, "Rng min is %f, not 0.2 for \
                                 rng FLiBe in CND FliBeFuel.\n",
                    rng_min);
            break;
        }

        rng = NextItem(rng);
    }

    if(rng_min < 0.200001 && rng_min > 0.1999999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRngVal()
{
    char *const test_name = "ADERSetAderCndRngVal";
    char *cnd_name, *rng_name;
    char status[5], print_data[256];
    double rng_val;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rng;

    fprintf(outp, "Begin: Test_ADERSetAderCndRngVal.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rng = (long)RDB[cnd + ADER_CND_RNGS_PTR];

    while(rng > VALID_PTR)
    {
        rng_name = GetText(rng + ADER_CND_RNG_GRP_ID);

        if(strncmp("ActF", rng_name, 4) == 0)
        {
            rng_val = RDB[rng + ADER_CND_RNG_MIN];
            sprintf(print_data, "Rng val is %f, not 0.4 for \
                                rng FLiBe in CND FliBeFuel.\n",
                    rng_val);
            break;
        }

        rng = NextItem(rng);
    }

    if(rng_val < 0.400001 && rng_val > 0.3999999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRtoGrpId()
{
    char *const test_name = "ADERSetAderCndRtoGrpsId";
    char *cnd_name, *rto1_name, *rto2_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rto;

    fprintf(outp, "Begin: Test_ADERSetAderCndRtoGrpsId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rto = (long)RDB[cnd + ADER_CND_RTOS_PTR];

    sprintf(print_data, "Ader RTO FLiBe/ActF in CNT FLiBeFuel not found.\n");

    while(rto > VALID_PTR)
    {
        rto1_name = GetText(rto + ADER_CND_RTO_GRP1_ID);
        rto2_name = GetText(rto + ADER_CND_RTO_GRP2_ID);

        if((strncmp("FLiBe", rto1_name, 5) == 0) &&
           (strncmp("ActF", rto2_name, 4) == 0))
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        rto = NextItem(rto);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRtoMax()
{
    char *const test_name = "ADERSetAderCndRtoMax";
    char *cnd_name, *rto1_name, *rto2_name;
    char status[5], print_data[256];
    double rto_max;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rto;

    fprintf(outp, "Begin: Test_ADERSetAderCndRtoMax.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rto = (long)RDB[cnd + ADER_CND_RTOS_PTR];

    while(rto > VALID_PTR)
    {

        rto1_name = GetText(rto + ADER_CND_RTO_GRP1_ID);

        rto2_name = GetText(rto + ADER_CND_RTO_GRP2_ID);

        if((strncmp("FLiBe", rto1_name, 5) == 0) &&
           (strncmp("ThF4", rto2_name, 4) == 0))
        {
            rto_max = RDB[rto + ADER_CND_RTO_MAX];

            sprintf(print_data, "Rto max is %f, not 99 for \
                                rto FLiBe/ActF in CND FliBeFuel.\n",
                    rto_max);

            break;

        }

        rto = NextItem(rto);
    }

    if(rto_max < 99.000001 && rto_max > 98.999999)
    {
        boolean = 1;

        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRtoMin()
{
    char *const test_name = "ADERSetAderCndRtoMin";
    char *cnd_name, *rto1_name, *rto2_name;
    char status[5], print_data[256];
    double rto_min;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rto;

    fprintf(outp, "Begin: Test_ADERSetAderCndRtoMin.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rto = (long)RDB[cnd + ADER_CND_RTOS_PTR];

    while(rto > VALID_PTR)
    {
        rto1_name = GetText(rto + ADER_CND_RTO_GRP1_ID);
        rto2_name = GetText(rto + ADER_CND_RTO_GRP2_ID);

        if((strncmp("FLiBe", rto1_name, 5) == 0) &&
           (strncmp("ThF4", rto2_name, 4) == 0))
        {
            rto_min = RDB[rto + ADER_CND_RTO_MIN];
            sprintf(print_data, "Rto min is %f, not 4.0 for \
                                rto FLiBe/ActF in CND FliBeFuel.\n",
                    rto_min);
            break;
        }

        rto = NextItem(rto);
    }

    if(rto_min < 4.000001 && rto_min > 3.999999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderCndRtoVal()
{
    char *const test_name = "ADERSetAderCndRtoVal";
    char *cnd_name, *rto1_name, *rto2_name;
    char status[5], print_data[256];
    double rto_val;
    int append = 0;
    int boolean = 0;
    long ADER_data, cnd, rto;

    fprintf(outp, "Begin: Test_ADERSetAderCndRtoVal.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnd = (long)RDB[ADER_data + ADER_CONDITIONS_PTR];

    while(cnd > VALID_PTR)
    {
        cnd_name = GetText(cnd + ADER_CND_ID);

        if(strncmp("FLiBeFuel", cnd_name, 9) == 0)
        {
            break;
        }

        cnd = NextItem(cnd);
    }

    rto = (long)RDB[cnd + ADER_CND_RTOS_PTR];

    while(rto > VALID_PTR)
    {
        rto1_name = GetText(rto + ADER_CND_RTO_GRP1_ID);
        rto2_name = GetText(rto + ADER_CND_RTO_GRP2_ID);

        if((strncmp("FLiBe", rto1_name, 5) == 0) &&
           (strncmp("ActF", rto2_name, 4) == 0))
        {
            rto_val = RDB[rto + ADER_CND_RTO_MIN];
            sprintf(print_data, "Rto val is %f, not 2.0 for \
                                rto FLiBe/ActF in CND FliBeFuel.\n",
                    rto_val);
            break;
        }

        rto = NextItem(rto);
    }

    if(rto_val < 2.000001 || rto_val > 1.999999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderControlEntZ()
{
    char *const test_name = "ADERSetAderControlEntZ";
    char *cnt_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ent, cnt, Z;

    fprintf(outp, "Begin: Test_ADERSetAderControlEntZ.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnt = (long)RDB[ADER_data + ADER_CONTROL_PTR];

    sprintf(print_data, "ADER Control has no entry data \n");

    while(cnt > VALID_PTR)
    {
        cnt_name = GetText(cnt + ADER_CONTROL_TBL_ID);

        if(strncmp("001", cnt_name, 1) == 0)
        {
            ent = (long)RDB[cnt + ADER_CONTROL_ENT_PTR];

            if(ent > VALID_PTR)
            {
                sprintf(print_data, "ADER control has valid entry data but no Li.\n");
                break;
            }
        }

        cnt = NextItem(cnt);
    }

    while(ent > VALID_PTR)
    {
        Z = (long)RDB[ent + ADER_CONTROL_ENT_Z];

        if(Z == 3)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderControlEntZai()
{
    char *const test_name = "ADERSetAderControlEntZai";
    char *cnt_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ent, cnt, Zai;

    fprintf(outp, "Begin: Test_ADERSetAderControlEntZai.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnt = (long)RDB[ADER_data + ADER_CONTROL_PTR];

    sprintf(print_data, "ADER Control has no entry data \n");

    while(cnt > VALID_PTR)
    {
        cnt_name = GetText(cnt + ADER_CONTROL_TBL_ID);

        if(strncmp("001", cnt_name, 1) == 0)
        {
            ent = (long)RDB[cnt + ADER_CONTROL_ENT_PTR];

            if(ent > VALID_PTR)
            {
                sprintf(print_data, "ADER Control has valid entry data but no Pu-239.\n");
                break;
            }
        }

        cnt = NextItem(cnt);
    }

    while(ent > VALID_PTR)
    {
        Zai = (long)RDB[ent + ADER_CONTROL_ENT_ZAI];

        if(Zai == 942390)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        ent = NextItem(ent);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderControlTblId()
{
    char *const test_name = "ADERSetAderControlTblId";
    char *cnt_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, cnt;

    fprintf(outp, "Begin: Test_ADERSetAderControlTblId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    cnt = (long)RDB[ADER_data + ADER_CONTROL_PTR];

    sprintf(print_data, "ADER Control has no entry data \n");

    while(cnt > VALID_PTR)
    {
        cnt_name = GetText(cnt + ADER_CONTROL_TBL_ID);

        if(strncmp("001", cnt_name, 1) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        cnt = NextItem(cnt);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderGrpCompZ()
{
    char *const test_name = "ADERSetAderGrpCompZ";
    char *grp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    int booleanBe = 0;
    int booleanF = 0;
    int booleanLi = 0;
    int booleanOther = 0;
    long ADER_data, comp, comp_Z, grp;

    fprintf(outp, "Begin: Test_ADERSetAderGrpCompZ.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("FLiBe", grp_name, 5) == 0)
        {
            break;
        }

        grp = NextItem(grp);
    }

    /*Check FLiBe group composition */

    comp = (long)RDB[grp + ADER_GRP_COMP_PTR];

    if(comp < VALID_PTR)
    {
        boolean = 0;
        sprintf(print_data, "Group FLiBe does not have composition. \n");
    }
    else
    {
        while(comp > VALID_PTR)
        {

           comp_Z = (long)RDB[comp + ADER_GRP_COMP_Z];

           if(comp_Z == 3)
           {
               booleanLi = 1;
           }
           else if(comp_Z == 4)
           {
               booleanBe = 1;
           }
           else if(comp_Z == 9)
           {
               booleanF = 1;
           }
           else
           {
               booleanOther = 1;
           }

           comp = NextItem(comp);
        }
    }

    if((booleanLi == 1 && booleanBe == 1 && booleanF == 1)
       && booleanOther == 0 )
    {
        boolean = 1;
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderGrpId()
{
    char *const test_name = "ADERSetAderGrpID";
    char *grp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, grp;

    fprintf(outp, "Begin: Test_ADERSetAderGrpID.\n");

    sprintf(print_data, "FLiBe group not found. \n");

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("FLiBe", grp_name, 5) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        grp = NextItem(grp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderGrpIsoZai()
{
    char *const test_name = "ADERSetAderGrpIsoZai";
    char *grp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    int boolean6 = 0;
    int boolean7 = 0;
    int booleanOther = 0;
    long ADER_data, comp, comp_Z, grp, iso, iso_zai;

    fprintf(outp, "Begin: Test_ADERSetAderGrpIsoZai.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("FLiBe", grp_name, 5) == 0)
        {
            break;
        }

        grp = NextItem(grp);
    }

    comp = (long)RDB[grp + ADER_GRP_COMP_PTR];

    while(comp > VALID_PTR)
    {
        comp_Z = (long)RDB[comp + ADER_GRP_COMP_Z];

        iso = (long)RDB[comp + ADER_GRP_COMP_ISOS_PTR];

        if(comp_Z == 3)
        {
            boolean = 0;
            sprintf(print_data, "Group FLiBe Li has no isos");

            while(iso > VALID_PTR)
            {

               iso_zai = (long)RDB[iso + ADER_GRP_ISO_ZAI];

               if(iso_zai == 30060)
               {
                   boolean6 = 1;
               }
               else if(iso_zai == 30070)
               {
                   boolean7 = 1;
               }
               else
               {
                   booleanOther = 1;
               }

               iso = NextItem(iso);
            }

            if(boolean6 == 1 && boolean7 == 1 && booleanOther == 0)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

                break;

            }
        }
        else if(comp_Z == 4 && iso > VALID_PTR)
        {

            boolean = 0;

            sprintf(print_data, "Group FLiBe Be entry has isos. \n");

            break;

        }
        else if(comp_Z == 9 && iso > VALID_PTR)
        {

            boolean = 0;

            sprintf(print_data, "Group FLiBe F entry has isos. \n");

            break;

        }

        comp = NextItem(comp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }

}

int Test_ADERSetAderGrpSumGroupsPtr()
{
    char *const test_name = "ADERSetAderGrpSumGroupsPtr";
    char *grp_name, *sgrp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    int boolean1 = 0;
    int boolean2 = 0;
    int booleanOther = 0;
    long ADER_data, grp, sgrp;

    fprintf(outp, "Begin: Test_ADERSetAderGrpSumGroupsPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("NestedSum", grp_name, 9) == 0)
        {
            break;
        }

        grp = NextItem(grp);
    }

    /* Check the 'summation' groups */
    if((long)RDB[grp + ADER_GRP_SUM_GRPS_PTR] < VALID_PTR)
    {
        sprintf(print_data, "Group NestedSum has no 'summation' groups.\n");
    }
    else
    {
        sgrp = (long)RDB[grp + ADER_GRP_SUM_GRPS_PTR];
        while(sgrp > VALID_PTR)
        {

            sgrp_name = GetText(sgrp + ADER_GRP_SUM_GRP_ID);

            if(strncmp("ActF", sgrp_name, 4) == 0)
            {

                boolean1 = 1;

            }
            else if(strncmp("Beryllium", sgrp_name, 9) == 0)
            {

                boolean2 = 1;

            }
            else
            {

                booleanOther = 1;

            }

            sgrp = NextItem(sgrp);
        }

        sprintf(print_data, "Group NestedSum doesn't have correct groups. \n");

        if(boolean1 == 1 && boolean2 == 1 && booleanOther == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
        }
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderKMax()
{
    char *const test_name = "ADERSetAderKMax";
    char status[5], print_data[256];
    double ADER_kMax;
    int append = 0;
    int boolean = 0;
    long ADER_data;

    fprintf(outp, "Begin: Test_ADERSetAderKMax.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    ADER_kMax = RDB[ADER_data + ADER_K_MAX];

    sprintf(print_data, "ADER k max criteria is %f but should be 1.00005.\n",
            ADER_kMax);

    if(ADER_kMax < 1.000050001 && ADER_kMax > 1.000049999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderKMin()
{
    char *const test_name = "ADERSetAderKMin";
    char status[5], print_data[256];
    double ADER_kMin;
    int append = 0;
    int boolean = 0;
    long ADER_data;

    fprintf(outp, "Begin: Test_ADERSetAderKMax.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    ADER_kMin = RDB[ADER_data + ADER_K_MIN];

    sprintf(print_data, "ADER k min criteria is %f but should be 0.99995.\n",
            ADER_kMin);

    if(ADER_kMin < 0.999950001 && ADER_kMin > 0.999949999)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderNegAdens()
{
    char *const test_name = "ADERSetAderNegAdens";
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data;

    fprintf(outp, "Begin: Test_ADERSetAderNegAdens.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    sprintf(print_data, "ADER negative adens key is %ld but should be 1.\n",
            (long)RDB[ADER_data + ADER_TRANS_ITER]);

    if((long)RDB[ADER_data + ADER_NEG_ADENS_OPT] > 0)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderOxiEleVal()
{
    char *const test_name = "ADERSetAderOxiEleVal";
    char *oxi_name;
    char status[5], print_data[256];
    double oxi_val;
    int append = 0;
    int boolean = 0;
    long ADER_data, ele, oxi, Z;

    fprintf(outp, "Begin: Test_ADERSetAderOxiEleVal.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    oxi = (long)RDB[ADER_data + ADER_OXIS_PTR];

    sprintf(print_data, "ADER oxi has no entry data \n");

    while(oxi > VALID_PTR)
    {
        oxi_name = GetText(oxi + ADER_OXI_TBL_ID);

        if(strncmp("002", oxi_name, 3) == 0)
        {
            ele = (long)RDB[oxi + ADER_OXI_ELES_PTR];

            if(ele > VALID_PTR)
            {
                sprintf(print_data, "ADER oxi has valid entry data but \
                                     no either no H or incorrect value.\n");
                break;
            }
        }

        oxi = NextItem(oxi);
    }

    while(ele > VALID_PTR)
    {
        Z = (long)RDB[ele + ADER_OXI_ELE_Z];

        oxi_val = RDB[ele + ADER_OXI_ELE_VAL];

        if(Z == 1 && (oxi_val > 0.999999 && oxi_val < 1.000001))
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        ele = NextItem(ele);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderOxiEleWeight()
{
    char *const test_name = "ADERSetAderOxiEleWeight";
    char *oxi_name;
    char status[5], print_data[256];\
    double oxi_weight;
    int append = 0;
    int boolean = 0;
    long ADER_data, ele, oxi, Z;

    fprintf(outp, "Begin: Test_ADERSetAderOxiEleWeight.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    oxi = (long)RDB[ADER_data + ADER_OXIS_PTR];

    sprintf(print_data, "ADER oxi has no entry data \n");

    while(oxi > VALID_PTR)
    {
        oxi_name = GetText(oxi + ADER_OXI_TBL_ID);

        if(strncmp("002", oxi_name, 3) == 0)
        {
            ele = (long)RDB[oxi + ADER_OXI_ELES_PTR];

            if(ele > VALID_PTR)
            {
                sprintf(print_data, "ADER oxi has valid entry data but \
                                     either no H or incorrect weight.\n");
                break;
            }
        }

        oxi = NextItem(oxi);
    }

    while(ele > VALID_PTR)
    {
        Z = (long)RDB[ele + ADER_OXI_ELE_Z];

        oxi_weight = RDB[ele + ADER_OXI_ELE_WEIGHT];

        if(Z == 1)
        {
            sprintf(print_data, "ADER oxi has valid entry data and \
                                 H but incorrect weight for H.\n");
            if(oxi_weight < 2.000001 && oxi_weight > 1.999999)
            {
                boolean = 1;

                memset(print_data, 0, strlen(print_data));

                break;
            }
        }

        ele = NextItem(ele);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderOxiEleZ()
{
    char *const test_name = "ADERSetAderOxiEleZ";
    char *oxi_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ele, oxi, Z;

    fprintf(outp, "Begin: Test_ADERSetAderOxiEleZ.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    oxi = (long)RDB[ADER_data + ADER_OXIS_PTR];

    sprintf(print_data, "ADER oxi has no entry data \n");

    while(oxi > VALID_PTR)
    {
        oxi_name = GetText(oxi + ADER_OXI_TBL_ID);

        if(strncmp("002", oxi_name, 3) == 0)
        {
            ele = (long)RDB[oxi + ADER_OXI_ELES_PTR];

            if(ele > VALID_PTR)
            {
                sprintf(print_data, "ADER oxi has valid entry data but no H.\n");
                break;
            }
        }

        oxi = NextItem(oxi);
    }

    while(ele > VALID_PTR)
    {
        Z = (long)RDB[ele + ADER_OXI_ELE_Z];

        if(Z == 1)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        ele = NextItem(ele);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderOxiTblId()
{
    char *const test_name = "ADERSetAderOxiTblId";
    char *oxi_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, oxi;

    fprintf(outp, "Begin: Test_ADERSetAderOxiTblId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    oxi = (long)RDB[ADER_data + ADER_OXIS_PTR];

    sprintf(print_data, "ADER oxi '002' not found. \n");

    while(oxi > VALID_PTR)
    {
        oxi_name = GetText(oxi + ADER_OXI_TBL_ID);

        if(strncmp("002", oxi_name, 3) == 0)
        {
            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;
        }

        oxi = NextItem(oxi);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderReproEntVal()
{
    char *const test_name = "ADERSetAderReproEntVal";
    char *repro_name;
    char status[5], print_data[256];
    double repro_val;
    int append = 0;
    int boolean = 0;
    long ADER_data, ent, repro, Z;

    fprintf(outp, "Begin: Test_ADERSetAderReproEntVal.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    repro = (long)RDB[ADER_data + ADER_REPROS_PTR];

    sprintf(print_data, "ADER Repro has no entry data \n");

    while(repro > VALID_PTR)
    {
        repro_name = GetText(repro + ADER_REPRO_TBL_ID);

        if(strncmp("reproc", repro_name, 6) == 0)
        {
            ent = (long)RDB[repro + ADER_REPRO_ENT_PTR];

            if(ent > VALID_PTR)
            {
                sprintf(print_data, "ADER Repro has valid entry data but \
                                     either no H or wrong repro val.\n");
                break;
            }
        }

        repro = NextItem(repro);
    }

    while(ent > VALID_PTR)
    {
        Z = (long)RDB[ent + ADER_REPRO_ENT_Z];

        repro_val = RDB[ent + ADER_REPRO_ENT_VAL];

        if(Z == 1 && (repro_val < 0.400001 && repro_val > 0.399999))
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        ent = NextItem(ent);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderReproEntZ()
{
    char *const test_name = "ADERSetAderReproEntZ";
    char *repro_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ent, repro, Z;

    fprintf(outp, "Begin: Test_ADERSetAderReproEntZ.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    repro = (long)RDB[ADER_data + ADER_REPROS_PTR];

    sprintf(print_data, "ADER Repro has no entry data \n");

    while(repro > VALID_PTR)
    {

        repro_name = GetText(repro + ADER_REPRO_TBL_ID);

        if(strncmp("reproc", repro_name, 6) == 0)
        {

            ent = (long)RDB[repro + ADER_REPRO_ENT_PTR];

            if(ent > VALID_PTR)
            {

                sprintf(print_data, "ADER Repro has valid entry data but no H.\n");

                break;

            }

        }

        repro = NextItem(repro);
    }

    while(ent > VALID_PTR)
    {

        Z = (long)RDB[ent + ADER_REPRO_ENT_Z];

        if(Z == 1)
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

            break;

        }

        ent = NextItem(ent);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderReproEntZai()
{
    char *const test_name = "ADERSetAderReproEntZai";
    char *repro_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, ent, repro, ZAI;

    fprintf(outp, "Begin: Test_ADERSetAderReproEntZai.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    repro = (long)RDB[ADER_data + ADER_REPROS_PTR];

    sprintf(print_data, "ADER Repro has no entry data \n");

    while(repro > VALID_PTR)
    {
        repro_name = GetText(repro + ADER_REPRO_TBL_ID);

        if(strncmp("reproc", repro_name, 6) == 0)
        {
            ent = (long)RDB[repro + ADER_REPRO_ENT_PTR];

            if(ent > VALID_PTR)
            {
                sprintf(print_data, "ADER Repro has valid entry data but no U-233.\n");
                break;
            }
        }

        repro = NextItem(repro);
    }

    while(ent > VALID_PTR)
    {
        ZAI = (long)RDB[ent + ADER_REPRO_ENT_ZAI];

        if(ZAI == 922330)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        ent = NextItem(ent);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderReproTblId()
{
    char *const test_name = "ADERSetAderReproTblId";
    char *repro_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, repro;

    fprintf(outp, "Begin: Test_ADERSetAderReproTblId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    repro = (long)RDB[ADER_data + ADER_REPROS_PTR];

    sprintf(print_data, "ADER Repro 'reproc'not found. \n");

    while(repro > VALID_PTR)
    {
        repro_name = GetText(repro + ADER_REPRO_TBL_ID);

        if(strncmp("reproc", repro_name, 6) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        repro = NextItem(repro);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrDest()
{
    char *const test_name = "ADERSetAderStrDest";
    char *str_grp_name, *str_dest_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrDest.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("Beryllium", str_grp_name, 9) == 0)
        {
            break;
        }

        str = NextItem(str);
    }

    str_dest_name = GetText(str + ADER_STREAM_DEST);

    sprintf(print_data, "Destination FLiBeFuel not found in \
                         Beryllium stream.\n");

    if(strncmp("FLiBeFuel", str_dest_name, 9) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrForm()
{
    char *const test_name = "ADERSetAderStrForm";
    char *form, *str_grp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrForm.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("Beryllium", str_grp_name, 9) == 0)
        {
            form = GetText(str + ADER_STREAM_FORM);
            break;
        }

        str = NextItem(str);
    }

    sprintf(print_data, "Form for Beryllium stream not equal to 'cont'.\n");

    if(strncmp("cont", form, 4) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrGrpId()
{
    char *const test_name = "ADERSetAderStrGrpId";
    char *str_grp_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrGrpId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    sprintf(print_data, "ADER Str Beryllium to FLiBeFuel not found. \n");

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("Beryllium", str_grp_name, 9) == 0)
        {
            boolean = 1;
            memset(print_data, 0, strlen(print_data));
            break;
        }

        str = NextItem(str);
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrGrpType()
{
    char *const test_name = "ADERSetAderStrGrpType";
    char *str_grp_name, *str_grp_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrGrpType.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    sprintf(print_data, "ADER Str Beryllium to FLiBeFuel grp type is not grp. \n");

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("Beryllium", str_grp_name, 9) == 0)
        {
            str_grp_type = GetText(str + ADER_STREAM_GRP_TYPE);
            break;
        }

        str = NextItem(str);
    }

    if(strncmp("group", str_grp_type, 3) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrOpt1()
{
    char *const test_name = "ADERSetAderStrOpt1";
    char *str_grp_name;
    char status[5], print_data[256];
    double opt1;
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrOpt1.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("reproc", str_grp_name, 6) == 0)
        {
            opt1 = RDB[str + ADER_STREAM_OPT1];
            break;
        }

        str = NextItem(str);
    }

    sprintf(print_data, "Opt1 for 'reproc' stream is %f, not 0.00001.\n",
            opt1);

    if(opt1 > 0.00000999 && opt1 < 0.00001001)
    {

        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrSrc()
{
    char *const test_name = "ADERSetAderStrSrc";
    char *str_grp_name, *str_src_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrSrc.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("reproc", str_grp_name, 6) == 0)
        {
            break;
        }

        str = NextItem(str);
    }

    str_src_name = GetText(str + ADER_STREAM_SRC);

    sprintf(print_data, "Source FLiBeFuel not found in \
                         'reproc'stream.\n");

    if(strncmp("FLiBeFuel", str_src_name, 9) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderStrType()
{
    char *const test_name = "ADERSetAderStrType";
    char *str_grp_name, *str_type;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data, str;

    fprintf(outp, "Begin: Test_ADERSetAderStrType.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    str = (long)RDB[ADER_data + ADER_STREAMS_PTR];

    sprintf(print_data, "ADER Str Beryllium to FLiBeFuel type is not redox. \n");

    while(str > VALID_PTR)
    {
        str_grp_name = GetText(str + ADER_STREAM_GRP_ID);

        if(strncmp("Beryllium", str_grp_name, 9) == 0)
        {
            str_type = GetText(str + ADER_STREAM_TYPE);
            break;
        }

        str = NextItem(str);
    }

    if(strncmp("redox", str_type, 5) == 0)
    {
        boolean = 1;
        memset(print_data, 0, strlen(print_data));
    }


    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderSumGrpWeight()
{
    char *const test_name = "ADERSetAderSumGrpWeight";
    char *grp_name, *sgrp_name;
    char status[5], print_data[256];
    double sgrp_weight;
    int append = 0;
    int boolean = 0;
    long ADER_data, grp, sgrp;

    fprintf(outp, "Begin: Test_ADERSetAderSumGrpWeight.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    grp = (long)RDB[ADER_data + ADER_GROUPS_PTR];

    while(grp > VALID_PTR)
    {
        grp_name = GetText(grp + ADER_GRP_ID);

        if(strncmp("NestedSum", grp_name, 9) == 0)
        {
            break;
        }

        grp = NextItem(grp);
    }

    sgrp = (long)RDB[grp + ADER_GRP_SUM_GRPS_PTR];

    while(sgrp > VALID_PTR)
    {

        sgrp_name = GetText(sgrp + ADER_GRP_SUM_GRP_ID);

        if(strncmp("ActF", sgrp_name, 4) == 0)
        {

            sprintf(print_data, "Sum grp weight for sum component \
                                 ActF in group NestedSum is %f but \
                                 should be 0.25.\n",sgrp_weight);

            sgrp_weight = RDB[sgrp + ADER_GRP_SUM_GRP_WEIGHT];

            if(sgrp_weight < 0.2500001 && sgrp_weight > 0.24999999)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

        }

        sgrp = NextItem(sgrp);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetAderTransIter()
{
    char *const test_name = "ADERSetAderTransIter";
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long ADER_data;

    fprintf(outp, "Begin: Test_ADERSetAderTransIter.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the first test group */

    ADER_data = (long)RDB[DATA_PTR_ADER];

    sprintf(print_data, "ADER number of transport iterations is %ld but should be 5.\n",
            (long)RDB[ADER_data + ADER_TRANS_ITER]);

    if((long)RDB[ADER_data + ADER_TRANS_ITER] == 5)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatAderMem()
{
    char *const test_name = "ADERSetMatAderMem";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long ADER_data, ele, mat, Z;

    fprintf(outp, "Begin: Test_ADERSetMatAderMem.\n");
    /* This test is unique in that the tested function, ADERSetMatAderMem,
     * does not return a value, rather, it modifies an array. To prevent
     * interference with other tests this test will not call ADERSetMatAderMem
     * to create a new material and what not. Rather, it will check that
     * the test material has the memory.
     */

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {
            break;
        }

        mat = NextItem(mat);
    }

    /* Get material ADER data */
    ADER_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Check that ADER data block exists */
    if(ADER_data < VALID_PTR)
    {
        boolean = 0;
        sprintf(print_data, "ADER material data block does not exist\n");
    }
    /* Check ADER_MAT_ELEMENTS_PTR */
    else if(RDB[ADER_data + ADER_MAT_ELES_PTR] < VALID_PTR)
    {
        boolean = 0;
        sprintf(print_data, "ADER material element block does not exist\n");
    }
    /*Check ADER_MAT_ELEMENTS_PTR array */
    else
    {
        ele = (long)RDB[ADER_data + ADER_MAT_ELES_PTR];
        for(i=0; i < NUMBER_OF_ELEMENTS; i++)
        {
            /* Check that element entry exits */
            if(ele < VALID_PTR)
            {
                boolean = 0;
                sprintf(print_data, "ADER material element, %d, does not exist\n",
                        i);
                break;
            }
            Z = (long)RDB[ele + ADER_MAT_ELE_Z];
            /* Check that element Z set correctly */
            if(Z != (i + 1))
            {
                boolean = 0;
                sprintf(print_data, "ADER material element, %d, does not \
                                     have proper Z value of %d, rather has %ld. \n",
                                        i, i + 1, Z);
                break;
            }
            ele = NextItem(ele);
        }
    }

    /* Check the reactivity weight */
    if(RDB[ADER_data + ADER_MAT_RHO_WEIGHT] < 1.000001 &&
       RDB[ADER_data + ADER_MAT_RHO_WEIGHT] > 0.999999)
    {
        boolean = 1;

        memset(print_data, 0, strlen(print_data));
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatAderCndMem()
{
    char *const test_name = "ADERSetMatAderCndMem";
    char status[5];
    char print_data[256];
    char *mat_name, *ader_mat_cnd_id;
    int append = 0;
    int boolean = 0;
    long mat_ader_data, ader_mat_cnd, mat;

    fprintf(outp, "Begin: Test_ADERSetMatAderCndMem.\n");
    /* This test is unique in that the tested function, ADERSetMatAderMem,
     * does not return a value, rather, it modifies an array. To prevent
     * interference with other tests this test will not call ADERSetMatAderMem
     * to create a new material and what not. Rather, it will check that
     * the test material has the memory.
     */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel has no CNDs attached to it.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    ader_mat_cnd = (long)RDB[mat_ader_data + ADER_MAT_CNDS_PTR];

    while(ader_mat_cnd > VALID_PTR)
    {

        ader_mat_cnd_id = GetText(ader_mat_cnd + ADER_MAT_CND_ID);

        if(strncmp("testCND", ader_mat_cnd_id, 7) == 0)
        {

            memset(print_data, 0, strlen(print_data));

            boolean = 1;

            break;

        }

        ader_mat_cnd = NextItem(ader_mat_cnd);

    }
    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCmpColLowerBounds()
{
    char *const test_name = "ADERSetMatCmpColLowerBounds";
    char *cmp_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    double mat_matrix_col_lower_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long cmp, cmp_col, mat, mat_ader_data, mat_matrix_data, mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatCmpColLowerBounds.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBe cmp not found in material FLiBeFuel.\n");

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBe cmp found but has bad column.\n");

            cmp_col = (long)RDB[cmp + ADER_MAT_CMP_COL_ID];

            if(cmp_col == 0)
            {

                mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

                mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

                for(i = 0; i < cmp_col; i++)
                {

                    mat_matrix_col = NextItem(mat_matrix_col);

                }

                mat_matrix_col_lower_bound = RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_LOWER_BOUND];

                sprintf(print_data, "FLiBe cmp has good column but column \n \
entry has bad lower bound of %f.\n", mat_matrix_col_lower_bound);

                if((mat_matrix_col_lower_bound > 0.19999999) &&
                   (mat_matrix_col_lower_bound < 0.20000001))
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                }

            }

            break;

        }

        cmp = NextItem(cmp);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCmpColId()
{
    char *const test_name = "ADERSetMatCmpColId";
    char *cmp_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long cmp, cmp_col, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatCmpColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF cmp not found in material FLiBeFuel.\n");

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("ActF", cmp_name, 4) == 0)
        {

            sprintf(print_data, "ActF cmp found but has bad column.\n");

            cmp_col = (long)RDB[cmp + ADER_MAT_CMP_COL_ID];

            if(cmp_col == 1)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        cmp = NextItem(cmp);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCmpColUpperBounds()
{
    char *const test_name = "ADERSetMatCmpColUpperBounds";
    char *cmp_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    double mat_matrix_col_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long cmp, cmp_col, mat, mat_ader_data, mat_matrix_data, mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatCmpColUpperBounds.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBe cmp not found in material FLiBeFuel.\n");

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", cmp_name, 5) == 0)
        {

            sprintf(print_data, "FLiBe cmp found but has bad column.\n");

            cmp_col = (long)RDB[cmp + ADER_MAT_CMP_COL_ID];

            if(cmp_col == 0)
            {

                mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

                mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

                for(i = 0; i < cmp_col; i++)
                {

                    mat_matrix_col = NextItem(mat_matrix_col);

                }

                mat_matrix_col_upper_bound = RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_UPPER_BOUND];

                sprintf(print_data, "FLiBe cmp has good column but column \n \
entry has bad upper bound of %f.\n", mat_matrix_col_upper_bound);

                if(mat_matrix_col_upper_bound > 1E+17)
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                }

            }

            break;

        }

        cmp = NextItem(cmp);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCmpSumRowId()
{
    char *const test_name = "ADERSetMatCmpSumRowId";
    char *cmp_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long cmp, cmp_sum_row, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatCmpSumRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF cmp not found in material FLiBeFuel.\n");

    cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(cmp > VALID_PTR)
    {

        cmp_name = GetText(cmp + ADER_MAT_CMP_ID);

        if(strncmp("ActF", cmp_name, 4) == 0)
        {

            cmp_sum_row = (long)RDB[cmp + ADER_MAT_CMP_SUM_GRPS_ROW_ID];

            sprintf(print_data, "ActF cmp found but has bad sum row of %ld.\n",
                    cmp_sum_row);

            if(cmp_sum_row == 4)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        cmp = NextItem(cmp);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCntEleFutRowUpperBound()
{
    char *const test_name = "ADERSetMatCntEleFutRowUpperBound";
    char status[5];
    char print_data[256];
    char *mat_name;
    double mat_matrix_row_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long ele, ele_row, ele_z, mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_row_bound;

    fprintf(outp, "Begin: Test_ADERSetMatCntEleFutRowUpperBound.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element Li not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 3)
        {

            ele_row = (long)RDB[ele + ADER_MAT_ELE_FUT_ROW_ID];

            sprintf(print_data, "Element Li found but has bad row of %ld.\n",
                    ele_row);

            if(ele_row == 19)
            {

                mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

                mat_matrix_row_bound = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

                for(i = 0; i < ele_row; i++)
                {

                    mat_matrix_row_bound = NextItem(mat_matrix_row_bound);

                }

                mat_matrix_row_upper_bound = RDB[mat_matrix_row_bound + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

                sprintf(print_data, "Row has bad upper bound of %f.\n",
                        mat_matrix_row_upper_bound);

                if((mat_matrix_row_upper_bound > -0.0000000001) &&
                   (mat_matrix_row_upper_bound < 0.00000000001))
                {

                    boolean = 1;

                    memset(print_data, 0, strlen(print_data));

                }

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatCompMatrixElement()
{
    char *const test_name = "ADERSetMatCompMatrixElement";
    char status[5];
    char print_data[256];
    char *mat_name;
    double mat_matrix_old_value;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col;
    long mat_matrix_col_row;

    fprintf(outp, "Begin: Test_ADERSetMatCompMatrixElement.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel comp matrix has no columns.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < 3; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_col_row = (long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR];

    for(i = 0; i < 4; i++)
    {

        mat_matrix_col_row = NextItem(mat_matrix_col_row);

    }

    mat_matrix_old_value = RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY];

    /* Go ahead and use the function to set the test value                    */
    ADERSetMaterialCompMatrixElement(3, 4, mat_matrix_data, 54.32);

    sprintf(print_data, "FLiBeFuel comp matrix has value %f at (3, 4) and should have %f.\n",
            RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY], 54.32);

    if(RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 54.31 &&
       RDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 54.33)
    {

        memset(print_data, 0, strlen(print_data));

        boolean = 1;

    }

    /* Reset the value of the matrix so it doesn't mess with future tests     */

    WDB[mat_matrix_col_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = mat_matrix_old_value;

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }

}

int Test_ADERSetMatEleBalRowId()
{
    char *const test_name = "ADERSetMatEleBalRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_row, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleBalRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {

            ele_row = (long)RDB[ele + ADER_MAT_ELE_BAL_ROW_ID];

            sprintf(print_data, "Element H found but has bad row of %ld.\n",
                    ele_row);

            if(ele_row == 9)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleControl()
{
    char *const test_name = "ADERSetMatEleControl";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleControl.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element Li not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 3)
        {

            sprintf(print_data, "Element Li found but has bad control indicator of 0.\n");

            if((long)RDB[ele + ADER_MAT_ELE_CONTROL_FLAG] > 0)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleDelColId()
{
    char *const test_name = "ADERSetMatEleDelColId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_col, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleDelColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {


            ele_col = (long)RDB[ele + ADER_MAT_ELE_DEL_COL_ID];

            sprintf(print_data, "Element H found but has bad column of %ld.\n",
                    ele_col);

            if(ele_col == 18)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleDelColPtr()
{
    char *const test_name = "ADERSetMatEleDelColPtr";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long ele, ele_col, ele_col_ptr, ele_z, mat, mat_ader_data;
    long mat_matrix_data, mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatEleDelColPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {


            ele_col = (long)RDB[ele + ADER_MAT_ELE_DEL_COL_ID];

            sprintf(print_data, "Element H found but has bad column ptr.\n");

            mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

            mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

            for(i = 0; i < ele_col; i++)
            {

                mat_matrix_col = NextItem(mat_matrix_col);

            }

            ele_col_ptr = (long)RDB[ele + ADER_MAT_ELE_MATRIX_DEL_COL_PTR];

            if(ele_col_ptr == mat_matrix_col)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleDelRowId()
{
    char *const test_name = "ADERSetMatEleDelRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_row, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleDelRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {

            ele_row = (long)RDB[ele + ADER_MAT_ELE_DEL_ROW_ID];

            sprintf(print_data, "Element H found but has bad row of %ld.\n",
                    ele_row);

            if(ele_row == 10)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleFutColId()
{
    char *const test_name = "ADERSetMatEleFutColId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_col, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleFutColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {


            ele_col = (long)RDB[ele + ADER_MAT_ELE_FUT_COL_ID];

            sprintf(print_data, "Element H found but has bad column of %ld.\n",
                    ele_col);

            if(ele_col == 19)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleFutColPtr()
{
    char *const test_name = "ADERSetMatEleFutColPtr";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long ele, ele_col, ele_col_ptr, ele_z, mat, mat_ader_data;
    long mat_matrix_data, mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatEleDelColPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {


            ele_col = (long)RDB[ele + ADER_MAT_ELE_FUT_COL_ID];

            sprintf(print_data, "Element H found but has bad column ptr.\n");

            mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

            mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

            for(i = 0; i < ele_col; i++)
            {

                mat_matrix_col = NextItem(mat_matrix_col);

            }

            ele_col_ptr = (long)RDB[ele + ADER_MAT_ELE_MATRIX_FUT_COL_PTR];

            if(ele_col_ptr == mat_matrix_col)
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleFutRowId()
{
    char *const test_name = "ADERSetMatEleFutRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_row, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleFutRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {

            ele_row = (long)RDB[ele + ADER_MAT_ELE_FUT_ROW_ID];

            sprintf(print_data, "Element H found but has bad row of %ld.\n",
                    ele_row);

            if(ele_row == 11)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleIsoAderMatIsoPtr()
{
    char *const test_name = "ADERSetMatEleIsoAderMatIsoPtr";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_iso, ele_z, mat, mat_ader_data, mat_iso, iso, nuc;

    fprintf(outp, "Begin: Test_ADERSetMatEleIsoAderMatIsoPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element Li not found in FLiBeFuel ADER ele list.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 3)
        {


            ele_iso = (long)RDB[ele + ADER_MAT_ELE_ISOS_PTR];

            sprintf(print_data, "Element Li found but has no isotopes.\n");

            while(ele_iso > VALID_PTR)
            {

                sprintf(print_data, "Element Li found but has no Li-6.\n");

                mat_iso = (long)RDB[ele_iso + ADER_MAT_ELE_ISO_ADER_MAT_ISO_PTR];

                iso = (long)RDB[mat_iso + ADER_MAT_ISO_PTR];

                nuc = (long)RDB[iso + COMPOSITION_PTR_NUCLIDE];

                if((long)RDB[nuc + NUCLIDE_ZAI] == 30060)
                {

                    memset(print_data, 0, strlen(print_data));

                    boolean = 1;

                    break;

                }

                ele_iso = NextItem(ele_iso);

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatEleIsoRowId()
{
    char *const test_name = "ADERSetMatEleIsoRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long ele, ele_row, ele_z, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatEleIsoRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Element H not found in material FLiBeFuel.\n");

    ele = (long)RDB[mat_ader_data + ADER_MAT_ELES_PTR];

    while(ele > VALID_PTR)
    {

        ele_z = (long)RDB[ele + ADER_MAT_ELE_Z];

        if(ele_z == 1)
        {

            ele_row = (long)RDB[ele + ADER_MAT_ELE_ISO_ROW_ID];

            sprintf(print_data, "Element H found but has bad row of %ld.\n",
                    ele_row);

            if(ele_row == 12)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        ele = NextItem(ele);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}


int Test_ADERSetMatIsoBalRowId()
{
    char *const test_name = "ADERSetMatIsoBalRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, iso_row, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatIsoBalRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_row = (long)RDB[iso + ADER_MAT_ISO_BAL_ROW_ID];

    sprintf(print_data, "First isotope has bad column of %ld.\n", iso_row);

    if(iso_row == (9 + (NUMBER_OF_ELEMENTS * 4)))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoControl()
{
    char *const test_name = "ADERSetMatEleControl";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, mat, mat_ader_data, mat_iso, nuc;

    fprintf(outp, "Begin: Test_ADERSetMatEleControl.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "Isotope Pu-239 not found in material FLiBeFuel.\n");

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(iso > VALID_PTR)
    {

        mat_iso = (long)RDB[iso + ADER_MAT_ISO_PTR];

        nuc = (long)RDB[mat_iso + COMPOSITION_PTR_NUCLIDE];

        if((long)RDB[nuc + NUCLIDE_ZAI] == 942390)
        {

            sprintf(print_data, "Isotope Pu-239 found but has bad control indicator of 0.\n");

            if((long)RDB[iso + ADER_MAT_ISO_CONTROL_FLAG] > 0)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        iso = NextItem(iso);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoDelColId()
{
    char *const test_name = "ADERSetMatIsoDelColId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, iso_col, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatIsoDelColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_col = (long)RDB[iso + ADER_MAT_ISO_DEL_COL_ID];

    sprintf(print_data, "First isotope has bad column of %ld.\n", iso_col);

    if(iso_col == (18 + (2 * NUMBER_OF_ELEMENTS)))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoDelColPtr()
{
    char *const test_name = "ADERSetMatIsoDelColPtr";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long iso, iso_col, iso_col_ptr, mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatIsoDelColPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_col = (long)RDB[iso + ADER_MAT_ISO_DEL_COL_ID];

    sprintf(print_data, "First isotope has bad column ptr.\n");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    iso_col_ptr = (long)RDB[iso + ADER_MAT_ISO_MATRIX_DEL_COL_PTR];

    if(iso_col_ptr == mat_matrix_col)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoDelRowId()
{
    char *const test_name = "ADERSetMatIsoDelRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, iso_row, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatIsoDelRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_row = (long)RDB[iso + ADER_MAT_ISO_DEL_ROW_ID];

    sprintf(print_data, "First isotope has bad column of %ld.\n", iso_row);

    if(iso_row == (10 + (NUMBER_OF_ELEMENTS * 4)))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoFutColId()
{
    char *const test_name = "ADERSetMatIsoFutColId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, iso_col, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatIsoFutColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_col = (long)RDB[iso + ADER_MAT_ISO_FUT_COL_ID];

    sprintf(print_data, "First isotope has bad column of %ld.\n", iso_col);

    if(iso_col == (19 + (2 * NUMBER_OF_ELEMENTS)))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoFutColPtr()
{
    char *const test_name = "ADERSetMatIsoFutColPtr";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    int i;
    long iso, iso_col, iso_col_ptr, mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_col;

    fprintf(outp, "Begin: Test_ADERSetMatIsoFutColPtr.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_col = (long)RDB[iso + ADER_MAT_ISO_FUT_COL_ID];

    sprintf(print_data, "First isotope has bad column ptr.\n");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < iso_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    iso_col_ptr = (long)RDB[iso + ADER_MAT_ISO_MATRIX_FUT_COL_PTR];

    if(iso_col_ptr == mat_matrix_col)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatIsoFutRowId()
{
    char *const test_name = "ADERSetMatIsoFutRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long iso, iso_row, mat, mat_ader_data;

    fprintf(outp, "Begin: Test_ADERSetMatIsoFutRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    iso_row = (long)RDB[iso + ADER_MAT_ISO_FUT_ROW_ID];

    sprintf(print_data, "First isotope has bad column of %ld.\n", iso_row);

    if(iso_row == (11 + (NUMBER_OF_ELEMENTS * 4)))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatKMaxRowBounds()
{
    char *const test_name = "ADERSetMatKMaxRowBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double k_max_row_lower_bound, k_max_row_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_rows;
    long mat_matrix_row, mat_rho_max_row;

    fprintf(outp, "Begin: Test_ADERSetMatKMaxRowBounds.\n");

    /*Clear the print_data */
    sprintf(print_data, "No matrix data for material FLiBeFuel.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_rho_max_row = (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID];

    if(mat_matrix_data > VALID_PTR)
    {

        mat_matrix_rows = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS];

        mat_matrix_row = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

        for(i = 0; i < mat_rho_max_row; i++)
        {

            mat_matrix_row = NextItem(mat_matrix_row);

        }

        k_max_row_lower_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

        k_max_row_upper_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

        sprintf(print_data, "K max row, row %ld, has bad bounds of %f \n \
and %f for lower and upper bounds respectively.\n", (mat_matrix_rows - 3),
                k_max_row_lower_bound, k_max_row_upper_bound);

        if((k_max_row_lower_bound == 0) &&
           (k_max_row_upper_bound > 1E+17))
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));
        }

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatKMaxRowId()
{
    char *const test_name = "ADERSetMatKMaxRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_iso, mat_matrix_data, mat_rho_max_row;
    long mat_num_isos = 0;

    fprintf(outp, "Begin: Test_ADERSetMatKMaxRowId.\n");

    /*Clear the print_data */
    sprintf(print_data, "Rho max row for material FLiBeFuel has bad row id.");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_num_isos++;

        mat_iso = NextItem(mat_iso);

    }

    mat_rho_max_row = (long)RDB[mat_ader_data + ADER_MAT_RHO_MAX_ROW_ID];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    sprintf(print_data, "Rho max row for material FLiBeFuel has bad row of %ld \n\
with expected row of %ld.\n",
            mat_rho_max_row, ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 4));

    if(mat_rho_max_row == ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 4))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatKMinRowBounds()
{
    char *const test_name = "ADERSetMatKMinRowBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double k_min_row_lower_bound, k_min_row_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_rows;
    long mat_matrix_row, mat_rho_min_row;

    fprintf(outp, "Begin: Test_ADERSetMaKMinRowBounds.\n");

    /*Clear the print_data */
    sprintf(print_data, "No matrix data for material FLiBeFuel.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_rho_min_row = (long)RDB[mat_ader_data + ADER_MAT_RHO_MIN_ROW_ID];

    if(mat_matrix_data > VALID_PTR)
    {

        mat_matrix_rows = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS];

        mat_matrix_row = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

        for(i = 0; i < mat_rho_min_row; i++)
        {

            mat_matrix_row = NextItem(mat_matrix_row);

        }

        k_min_row_lower_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

        k_min_row_upper_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

        sprintf(print_data, "K min row, row %ld, has bad lower bound of %f \n \
or bad upper bound of %f.\n",
                (mat_matrix_rows - 2),
                k_min_row_lower_bound,
                k_min_row_upper_bound);

        if((k_min_row_lower_bound < -1E+17) && (k_min_row_upper_bound == 0))
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));
        }

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatKMinRowId()
{
    char *const test_name = "ADERSetMatKMinRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_iso, mat_matrix_data, mat_rho_min_row;
    long mat_num_isos = 0;

    fprintf(outp, "Begin: Test_ADERSetMatKMinRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_num_isos++;

        mat_iso = NextItem(mat_iso);

    }

    mat_rho_min_row = (long)RDB[mat_ader_data + ADER_MAT_RHO_MIN_ROW_ID];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    sprintf(print_data, "Rho min row for material FLiBeFuel has bad row of %ld \n\
with expected row of %ld.\n",
            mat_rho_min_row, ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 3));

    if(mat_rho_min_row == ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 3))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjGroup()
{
    char *const test_name = "ADERSetMatObjGroup";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_cmp_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_cmp, mat_cmp_target_col, mat_matrix_data;
    long mat_matrix_col, mat_matrix_row, mat_opt;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjGroup.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no cmp groups.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_cmp = (long)RDB[mat_ader_data + ADER_MAT_CMPS_PTR];

    while(mat_cmp > VALID_PTR)
    {

        mat_cmp_name = GetText(mat_cmp + ADER_MAT_CMP_ID);

        if(strncmp("FLiBe", mat_cmp_name, 4) == 0)
        {

            mat_cmp_target_col = (long)RDB[mat_cmp + ADER_MAT_CMP_COL_ID];

            break;

        }

        mat_cmp = NextItem(mat_cmp);

    }

    /* Here we modify the optimization settings */

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("group");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("FLiBe");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_cmp_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value 1.0.\n",
            mat_cmp_target_col, RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

    if(RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.99999999 &&
       RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.00000001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjFeed()
{
    char *const test_name = "ADERSetMatObjFeed";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff, src_mat_adens;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjFeed.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Argon40 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", mat_stream_name, 4) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel not found");

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Get the matrix material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 7) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no matrix data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Save FLiBeFuel's adens for later                                       */

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    src_mat_adens = RDB[mat + MATERIAL_ADENS];

    /* Get the target value                                                   */

    adens_corr_factor = parent_mat_adens / src_mat_adens;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("feed");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
            RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
            adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
                    adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjFeedAndRemoval()
{
    char *const test_name = "ADERSetMatObjFeedAndRemoval";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff, src_mat_adens;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjFeedAndRemoval.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Argon40 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", mat_stream_name, 4) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel not found.\n");

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Get the matrix material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 7) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no matrix data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    src_mat_adens = RDB[mat + MATERIAL_ADENS];

    adens_corr_factor = parent_mat_adens / src_mat_adens;

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("feed_and_remv");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
			RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
			adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		        adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjReac()
{
    char *const test_name = "ADERSetMatObjReac";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff, src_mat_adens;
    int append = 0;
    int boolean = 0;
    long ader_mat_stream_shadow, ader_mat_stream_src_mat;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjReac.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REAC_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("U233", mat_stream_name, 4) == 0)
        {

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            ader_mat_stream_shadow = (long)RDB[mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

            src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

            adens_corr_factor = src_mat_adens / parent_mat_adens;

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("reac");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
			RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
			adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		        adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjRedox()
{
    char *const test_name = "ADERSetMatObjRedox";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff, src_mat_adens;
    int append = 0;
    int boolean = 0;
    long ader_mat_stream_shadow, ader_mat_stream_src_mat;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjRedox.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    parent_mat_adens = RDB[mat + MATERIAL_ADENS];

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", mat_stream_name, 8) == 0)
        {

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            ader_mat_stream_shadow = (long)RDB[mat_stream + ADER_MAT_STREAM_SHADOW_PTR];

            ader_mat_stream_src_mat = (long)RDB[ader_mat_stream_shadow + ADER_MAT_STREAM_MAT_PTR];

            src_mat_adens = RDB[ader_mat_stream_src_mat + MATERIAL_ADENS];

            adens_corr_factor = src_mat_adens / parent_mat_adens;

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("redox");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
			RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
			adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		        adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjRemoval()
{
    char *const test_name = "ADERSetMatObjRemoval";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col, parent_mat;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjRemoval.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material Fluorine0 not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine0", mat_name, 9) == 0)
        {

            sprintf(print_data, "Fluorine0 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the parent mat adens and get the adens corr factor                 */

    parent_mat = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    parent_mat_adens = RDB[parent_mat + MATERIAL_ADENS];

    adens_corr_factor = RDB[mat + MATERIAL_ADENS] / parent_mat_adens;

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", mat_stream_name, 8) == 0)
        {

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Get FLiBeFuel to get the matrix data                                   */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no matrix data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("remv");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
			RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
			adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		        adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.00001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjStream()
{
    char *const test_name = "ADERSetMatObjStream";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_col, mat_matrix_row, mat_opt, mat_stream;
    long mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjStream.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("Beryllium", mat_stream_name, 9) == 0)
        {

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Here we modify the optimization settings */

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("spec_stream");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("Beryllium");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value 1.0.\n",
            mat_stream_target_col, RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

    if(RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.99999999 &&
       RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.00000001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjStreams()
{
    char *const test_name = "ADERSetMatObjStreams";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_col, mat_matrix_row, mat_opt, mat_stream;
    long mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjStreams.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", mat_stream_name, 5) == 0)
        {

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Here we modify the optimization settings */

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("streams");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value 1.0.\n",
            mat_stream_target_col, RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY]);

    if(RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] > 0.99999999 &&
       RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] < 1.00000001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatObjTransfers()
{
    char *const test_name = "ADERSetMatObjTransfers";
    char status[5];
    char print_data[256];
    char *mat_name, *mat_stream_name;
    double adens_corr_factor, parent_mat_adens, percent_diff, src_mat_adens;
    int append = 0;
    int boolean = 0;
    long ader_mat_parent;
    long mat, mat_ader_data, mat_matrix_data, mat_matrix_col, mat_matrix_row;
    long mat_opt, mat_stream, mat_stream_target_col;
    long i;

    fprintf(outp, "Begin: Test_ADERSetMatObjTransfers.\n");

    /* Execution of the Obj row tests requires manipulation of the WDB array */
    /* directly to avoid an overly complicated input file                    */

    /*Clear the print_data */
    sprintf(print_data, "Material Fluorine0 not found");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Fluorine0", mat_name, 9) == 0)
        {

            sprintf(print_data, "Fluorine0 has no streams.\n");

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    /* Get the parent adens                                                   */

    ader_mat_parent = (long)RDB[mat_ader_data + ADER_MAT_CLUSTER_PARENT_PTR];

    parent_mat_adens = RDB[ader_mat_parent + MATERIAL_ADENS];

    /* Get the adens_corr_factor                                              */

    src_mat_adens = RDB[mat + MATERIAL_ADENS];

    adens_corr_factor = src_mat_adens / parent_mat_adens;

    /* Get the target stream and retrieve its column index */

    mat_stream = (long)RDB[mat_ader_data + ADER_MAT_REDOX_STREAMS_PTR];

    while(mat_stream > VALID_PTR)
    {

        mat_stream_name = GetText(mat_stream + ADER_MAT_STREAM_ID);

        if(strncmp("Fluorine", mat_stream_name, 8) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel not found");

            mat_stream_target_col = (long)RDB[mat_stream + ADER_MAT_STREAM_COL_ID];

            break;

        }

        mat_stream = NextItem(mat_stream);

    }

    /* Get the matrix material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "FLiBeFuel has no matrix data.\n");

            break;

        }

        mat = NextItem(mat);

    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }


    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("action");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("transfers");

    ADERFillMaterialCompMatrixObjRow(mat);

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    for(i = 0; i < mat_stream_target_col; i++)
    {

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

    sprintf(print_data, "FLiBeFuel matrix column %ld final row has value %f and needs value %f.\n",
            mat_stream_target_col,
			RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY],
			adens_corr_factor);

    percent_diff = (RDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] -
    		        adens_corr_factor) / adens_corr_factor;

    if(fabs(percent_diff) < 0.0001)
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    /* Here we re-reset the objective row so that future tests can rely on the*/
    /* input file                                                             */

    /* Here we modify the optimization settings */

    mat_opt = (long)RDB[mat_ader_data + ADER_MAT_OPT_PTR];

    WDB[mat_opt + ADER_MAT_OPT_TYPE] = (double)PutText("spec_stream");

    WDB[mat_opt + ADER_MAT_OPT_TYPE_TARGET] = (double)PutText("Beryllium");

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    /* Here we wipe the old objective row */

    mat_matrix_col = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_COLS_PTR];

    while(mat_matrix_col > VALID_PTR)
    {

        mat_matrix_row = LastItem((long)RDB[mat_matrix_col + ADER_MAT_MATRIX_COL_ROWS_PTR]);

        WDB[mat_matrix_row + ADER_MAT_MATRIX_COL_ROW_ENTRY] = 0.0;

        mat_matrix_col = NextItem(mat_matrix_col);

    }

    ADERFillMaterialCompMatrixObjRow(mat);

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatOxiRowBounds()
{
    char *const test_name = "ADERSetMatOxiRowBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double oxi_row_lower_bound, oxi_row_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_row, mat_oxi_data, mat_oxi_row;

    fprintf(outp, "Begin: Test_ADERSetMatOxiRowBounds.\n");

    /*Clear the print_data */
    sprintf(print_data, "No matrix data for material FLiBeFuel.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_oxi_data = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    mat_oxi_row = (long)RDB[mat_oxi_data + ADER_MAT_OXI_ROW_ID];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    sprintf(print_data, "Oxi row for material FLiBeFuel has bad row of %ld \n\
with max number of rows %ld.\n",
            mat_oxi_row, (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS]);

    if(mat_matrix_data > VALID_PTR)
    {

        mat_matrix_row = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

        for(i = 0; i < mat_oxi_row; i++)
        {

            mat_matrix_row = NextItem(mat_matrix_row);

        }

        oxi_row_lower_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

        oxi_row_upper_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

        sprintf(print_data, "Oxi row, row %ld, has bad bounds of %f \n \
and %f for lower and upper bounds respectively.\n", mat_oxi_row,
                oxi_row_lower_bound, oxi_row_upper_bound);

        if((oxi_row_lower_bound > -0.00000001) && (oxi_row_lower_bound < 0.00000001) &&
           (oxi_row_upper_bound > 0.00099999) && (oxi_row_upper_bound < 0.00100001))
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));
        }

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatOxiRowId()
{
    char *const test_name = "ADERSetMatOxiRowId";
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_iso, mat_matrix_data, mat_oxi_data, mat_oxi_row;
    long mat_num_isos = 0;

    fprintf(outp, "Begin: Test_ADERSetMatOxiRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_num_isos++;

        mat_iso = NextItem(mat_iso);

    }

    mat_oxi_data = (long)RDB[mat_ader_data + ADER_MAT_OXI_PTR];

    mat_oxi_row = (long)RDB[mat_oxi_data + ADER_MAT_OXI_ROW_ID];

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    sprintf(print_data, "FLiBeFuel Oxi has bad row of %ld.\n", mat_oxi_row);

    if(mat_oxi_row == ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 5))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatParentMPINum()
{
    char *const test_name = "ADERSetMatParentMPINum";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_mpi_num;

    fprintf(outp, "Begin: Test_ADERSetMatParentMPINum.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found.\n");

    /* Get the material*/

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }


    sprintf(print_data, "Material FLiBeFuel has bad MPI number.\n");

    mat_mpi_num = (long)RDB[mat + MATERIAL_MPI_ID];

    if(mat_mpi_num == 0)
    {

        boolean = 1;

        sprintf(print_data, "WARNING!!!: NOT TESTED ON PARALLEL PLATFORM.\n");

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }

}

int Test_ADERSetMatPreserveRowBounds()
{
    char *const test_name = "ADERSetMatPreserveRowBounds";
    char status[5];
    char print_data[256];
    char *mat_name;
    double pres_row_lower_bound, pres_row_upper_bound;
    int append = 0;
    int boolean = 0;
    int i;
    long mat, mat_ader_data, mat_matrix_data;
    long mat_matrix_row, mat_pres_row, mat_preserve_ent;

    fprintf(outp, "Begin: Test_ADERSetMatPreserveRowBounds.\n");

    /*Clear the print_data */
    sprintf(print_data, "No matrix data for material FLiBeFuel.\n");

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_preserve_ent = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    while(mat_preserve_ent > VALID_PTR)
    {

        if(strncmp("mols", GetText(mat_preserve_ent + ADER_MAT_PRESERVE_ENT), 4) == 0)
        {

            mat_pres_row = (long)RDB[mat_preserve_ent + ADER_MAT_PRESERVE_ROW_ID];

            break;

        }

        mat_preserve_ent = NextItem(mat_preserve_ent);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    sprintf(print_data, "Preserve row for material FLiBeFuel has bad row of %ld \n\
with max number of rows %ld.\n",
            mat_pres_row, (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS]);

    if(mat_matrix_data > VALID_PTR)
    {

        mat_matrix_row = (long)RDB[mat_matrix_data + ADER_MAT_MATRIX_ROW_BOUNDS_PTR];

        for(i = 0; i < mat_pres_row; i++)
        {

            mat_matrix_row = NextItem(mat_matrix_row);

        }

        pres_row_lower_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_LOWER_BOUND];

        pres_row_upper_bound = RDB[mat_matrix_row + ADER_MAT_MATRIX_ROW_UPPER_BOUND];

        sprintf(print_data, "Preserve row, row %ld, has bad bounds of %f \n \
and %f for lower and upper bounds respectively.\n", mat_pres_row,
                pres_row_lower_bound, pres_row_upper_bound);

        if((pres_row_lower_bound > -0.00000001) && (pres_row_lower_bound < 0.00000001) &&
           (pres_row_upper_bound > -0.00000001) && (pres_row_lower_bound < 0.00000001))
        {

            boolean = 1;

            memset(print_data, 0, strlen(print_data));

        }

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatPreserveRowId()
{
    char *const test_name = "ADERSetMatPreserveRowId";
    char *mat_name;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, mat_iso, mat_matrix_data;
    long mat_preserve_ent, mat_preserve_row;
    long mat_num_isos = 0;

    fprintf(outp, "Begin: Test_ADERSetMatPreserveRowId.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material FLiBeFuel not found. \n");

    /* Get the first test group */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    mat_iso = (long)RDB[mat_ader_data + ADER_MAT_ISOS_PTR];

    while(mat_iso > VALID_PTR)
    {

        mat_num_isos++;

        mat_iso = NextItem(mat_iso);

    }

    mat_matrix_data = (long)RDB[mat_ader_data + ADER_MAT_MATRIX_PTR];

    mat_preserve_ent = (long)RDB[mat_ader_data + ADER_MAT_PRESERVES_PTR];

    while(mat_preserve_ent > VALID_PTR)
    {

        if(strncmp("mols", GetText(mat_preserve_ent + ADER_MAT_PRESERVE_ENT), 4) == 0)
        {

            mat_preserve_row = (long)RDB[mat_preserve_ent + ADER_MAT_PRESERVE_ROW_ID];

            break;

        }

        mat_preserve_ent = NextItem(mat_preserve_ent);

    }

    sprintf(print_data, "FLiBeFuel Preserve has bad row of %ld with needed row of %ld.\n",
            mat_preserve_row,
            ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 2));

    if(mat_preserve_row == ((long)RDB[mat_matrix_data + ADER_MAT_MATRIX_NUM_ROWS] - 1 - 12 * NUMBER_OF_ELEMENTS - 9 * mat_num_isos - 2))
    {

        boolean = 1;

        memset(print_data, 0, strlen(print_data));

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmColId()
{
    char *const test_name = "ADERSetMatStrmColId";
    char *strm_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_col;

    fprintf(outp, "Begin: Test_ADERSetMatStrmColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "FLiBe feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("FLiBe", strm_name, 5) == 0)
        {

            strm_col = (long)RDB[strm + ADER_MAT_STREAM_COL_ID];

            sprintf(print_data, "FLiBe feed stream found but has bad column of %ld.\n",
                    strm_col);

            if(strm_col == 5)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmShadowColId()
{
    char *const test_name = "ADERSetMatStrmShadowColId";
    char *mat_name, *strm_id;
    char status[5], print_data[256];
    int append = 0;
    int boolean = 0;
    long col, mat, mat_ader_data, strm;

    fprintf(outp, "Begin: Test_ADERSetMatStrmShadowColId.\n");

    /*Clear the print_data */
    sprintf(print_data, "Material Argon40 not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            sprintf(print_data, "Material Argon40 has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "Argon40 has no reproc stream.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            col = (long)RDB[strm + ADER_MAT_STREAM_COL_ID];

            break;

        }

        strm = NextItem(strm);

    }

    sprintf(print_data, "Material FLiBeFuel not found. \n");

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {
        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            sprintf(print_data, "Material FLiBeFuel has no streams.\n");

            break;

        }

        mat = NextItem(mat);
    }

    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    strm = (long)RDB[mat_ader_data + ADER_MAT_REMV_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        sprintf(print_data, "FLiBeFuel has no reproc stream.\n");

        strm_id = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("reproc", strm_id, 6) == 0)
        {

            sprintf(print_data, "Mismatch between Argon40 col, %ld, \n \
and FLiBeFuel reproc col of %ld.\n", col, (long)RDB[strm + ADER_MAT_STREAM_COL_ID]);

            if(col == (long)RDB[strm + ADER_MAT_STREAM_COL_ID])
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);
    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmShadowSumColId()
{
    char *const test_name = "ADERSetMatStrmShadowSumColId";
    char *strm_name, *strm_sum_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, shadow_sum_strm_col, strm, strm_sum, strm_sum_ent;

    fprintf(outp, "Begin: Test_ADERSetMatStrmShadowSumColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "ActF feed stream found but has no sum streams.\n");

            strm_sum_ent = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(strm_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "ActF feed stream sum streams found but has no sum stream 'Uranium'.\n");

                strm_sum_name = GetText(strm_sum_ent + ADER_MAT_GRP_SUM_GRP_ID);

                if(strncmp("Uranium", strm_sum_name, 7) == 0)
                {

                    strm_sum = (long)RDB[strm_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    sprintf(print_data, "Argon40 material not found.\n");

                    shadow_sum_strm_col = (long)RDB[strm_sum + ADER_MAT_STREAM_COL_ID];

                    break;

                }

                strm_sum_ent = NextItem(strm_sum_ent);

            }

            break;

        }

        strm = NextItem(strm);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material Argon40.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "ActF feed stream found but has no sum streams.\n");

            strm_sum_ent = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(strm_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "ActF feed stream sum streams found but has no sum stream 'Uranium'.\n");

                strm_sum_name = GetText(strm_sum_ent + ADER_MAT_GRP_SUM_GRP_ID);

                if(strncmp("Uranium", strm_sum_name, 7) == 0)
                {

                    strm_sum = (long)RDB[strm_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    sprintf(print_data, "Argon40 ActF feed stream sum group 'Uranium' has column %ld \n\
while ActF removal stream sum group Uranium in FLiBeFuel has column %ld.\n",
                            (long)RDB[strm_sum + ADER_MAT_STREAM_COL_ID],
                            shadow_sum_strm_col);

                    if((long)RDB[strm_sum + ADER_MAT_STREAM_COL_ID] == shadow_sum_strm_col)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                strm_sum_ent = NextItem(strm_sum_ent);

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmShadowSumRowId()
{
    char *const test_name = "ADERSetMatStrmShadowSumRowId";
    char *strm_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, shadow_sum_row, strm;

    fprintf(outp, "Begin: Test_ADERSetMatStrmShadowSumRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "Argon40 material not found.\n");

            shadow_sum_row = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_ROW_ID];

            break;

        }

        strm = NextItem(strm);

    }

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("Argon40", mat_name, 7) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material Argon40.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

            sprintf(print_data, "Argon40 ActF feed stream found but has sum row of %ld\n \
while FLiBeFuel ActF removal stream has sum row of %ld.\n",
                    (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_ROW_ID],
                    shadow_sum_row);

            if(shadow_sum_row == (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_ROW_ID])
            {

                boolean = 1;

                memset(print_data, 0, strlen(print_data));

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmSumColId()
{
    char *const test_name = "ADERSetMatStrmSumColId";
    char *strm_name, *strm_sum_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_sum, strm_sum_ent;

    fprintf(outp, "Begin: Test_ADERSetMatStrmSumColId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

        	if(strcmp("NULL", GetText(strm + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		strm = NextItem(strm);

        		continue;

        	}

            sprintf(print_data, "ActF feed stream found but has no sum streams.\n");

            strm_sum_ent = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_PTR];

            while(strm_sum_ent > VALID_PTR)
            {

                sprintf(print_data, "ActF feed stream sum streams found but has no sum stream 'Uranium'.\n");

                strm_sum_name = GetText(strm_sum_ent + ADER_MAT_GRP_SUM_GRP_ID);

                if(strncmp("Uranium", strm_sum_name, 7) == 0)
                {

                    strm_sum = (long)RDB[strm_sum_ent + ADER_MAT_GRP_SUM_GRP_PTR];

                    sprintf(print_data, "Uranium sum stream found but has bad column of %ld.\n",
                            (long)RDB[strm_sum + ADER_MAT_STREAM_COL_ID]);

                    if((long)RDB[strm_sum + ADER_MAT_STREAM_COL_ID] == 8254)
                    {

                        boolean = 1;

                        memset(print_data, 0, strlen(print_data));

                    }

                    break;

                }

                strm_sum_ent = NextItem(strm_sum_ent);

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_ADERSetMatStrmSumRowId()
{
    char *const test_name = "ADERSetMatStrmSumRowId";
    char *strm_name;
    char status[5];
    char print_data[256];
    char *mat_name;
    int append = 0;
    int boolean = 0;
    long mat, mat_ader_data, strm, strm_sum_row;

    fprintf(outp, "Begin: Test_ADERSetMatStrmSumRowId.\n");

    /*Clear the print_data */
    memset(print_data, 0, strlen(print_data));

    /* Get the test material */

    mat = (long)RDB[DATA_PTR_M0];

    while(mat > VALID_PTR)
    {

        mat_name = GetText(mat + MATERIAL_PTR_NAME);

        if(strncmp("FLiBeFuel", mat_name, 9) == 0)
        {

            break;

        }

        mat = NextItem(mat);

    }

    /* Get material ADER data */
    mat_ader_data = (long)RDB[mat + MATERIAL_ADER_DATA];

    sprintf(print_data, "ActF feed stream not found in material FLiBeFuel.\n");

    strm = (long)RDB[mat_ader_data + ADER_MAT_FEED_STREAMS_PTR];

    while(strm > VALID_PTR)
    {

        strm_name = GetText(strm + ADER_MAT_STREAM_ID);

        if(strncmp("ActF", strm_name, 4) == 0)
        {

        	if(strcmp("NULL", GetText(strm + ADER_MAT_STREAM_SRC)) == 0)
        	{

        		strm = NextItem(strm);

        		continue;

        	}

            strm_sum_row = (long)RDB[strm + ADER_MAT_STREAM_SUM_GRPS_ROW_ID];

            sprintf(print_data, "ActF feed stream found but has bad row of %ld.\n",
                    strm_sum_row);

            if(strm_sum_row == 12694)
            {

                memset(print_data, 0, strlen(print_data));

                boolean = 1;

            }

            break;

        }

        strm = NextItem(strm);

    }

    if (boolean == 1)
    {
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else
    {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

int Test_RunTests()
{
    char *const test_name = "RunTests";
    const char *const expect = "Hello World!";
    const char *const test_value = "Hello World!";
    char status[5];
    char print_data[256];
    int append = 0;

    fprintf(outp, "Begin: Test_RunTests.\n");

    memset(print_data, 0, strlen(print_data));

    if (strncmp(expect, test_value, 12) == 0){
        strcpy(status, "pass");
        PrintTest(test_name, status, print_data, append);
        return(1);
    }
    else {
        strcpy(status, "fail");
        PrintTest(test_name, status, print_data, append);
        return(-1);
    }
}

/*****************************************************************************/
